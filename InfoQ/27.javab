<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Cassandra CLI Internals Using JArchitect</h3><p>Relational Database Management Systems (RDBMS) are the most commonly used systems to store and use data, but for extremely large amounts of data, these databases don’t scale up well.</p>
<p>The concept of <a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a> has been gaining lot of popularity in the recent years due to the growing demand for relational database alternatives. The biggest motivation behind NoSQL is scalability. NoSQL database solutions offer a way to store and use extremely large amounts of data, but with less overhead, less work, better performance, and less downtime.</p>
<p><a href="http://cassandra.apache.org/">Apache Cassandra</a> is a Column based NoSQL database. It was developed at Facebook to power their Inbox Search feature, and it became an Apache open source project. <a href="http://nosql.mypopescu.com/post/407159447/cassandra-twitter-an-interview-with-ryan-king#_blank">Twitter</a>, <a href="http://nosql.mypopescu.com/post/441535855/digg-going-the-cassandra-way#_blank">Digg</a>, Reddit and quite a few other organizations started using it.</p>
<p>Cassandra ships with a very basic interactive command line interface (CLI). Using the CLI you can connect to remote nodes in the cluster to create or update your schema and set and retrieve records.</p>
<p>The CLI is a useful tool for Cassandra administrators, and even if it provides only basic commands, it’s a good example to know how to implement a Cassandra client. We have to understand how the CLI works internally to develop our custom Cassandra clients or even extend the CLI tool.</p>
<p>In this article, we will explore Cassandra CLI architecture model using the <a href="http://www.jarchitect.com">JArchitect</a> tool and the CQLinq language to analyze its code base. JArchitect tool is used to analyze code structure and specify design rules to achieve better code quality. With JArchitect, software quality can be measured using code metrics, visualized using graphs and treemaps, and enforced using standard and custom rules.</p>
<div id="lowerFullwidthVCR"></div>
<p>Here’s the dependency graph after analysis:</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/1Fig1.png" alt="" _href="img://1Fig1.png" _p="true" /></p>
<p>Cassandra uses some known jars like antlr, log4j, slf4j, commons-lang, and also some less known jars like the following:</p>
<ul> 
 <li><a href="http://thrift.apache.org/">Libthrift</a>: it’s an API spanning a variety of programming languages and use cases. The goal is to make reliable, performant communication and data serialization across languages as efficient and seamless as possible.</li> 
 <li><a href="https://code.google.com/p/snakeyaml/">Snakeyaml</a> : YAML is a data serialization format designed for human readability and interaction with scripting languages. Cassandra us this format for its configuration files.</li> 
 <li><a href="http://jackson.codehaus.org/">Jackson</a>: A High-performance JSON processor.</li> 
 <li><a href="https://code.google.com/p/snappy/">Snappy</a>: The snappy-java is a Java port of the snappy, a fast compresser/decompresser written in C++, originally developed by Google.</li> 
 <li><a href="https://github.com/stephenc/high-scale-lib">High-scale-lib</a>: A collection of Concurrent and Highly Scalable Utilities. These are intended as direct replacements for the java.util.* or java.util.concurrent.* collections but with better performance when many CPUs are using the collection concurrently.</li> 
</ul>
<p>The Matrix view below gives us more details about the dependency weight between these JAR files.</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig2.png" alt="" _href="img://Fig2.png" _p="true" /></p>
<h2>Cassandra Command Line Interface</h2>
<p>The command line interface logic is implemented in org.apache.cassandra.cli package, and the entry point is the CliMain class.</p>
<p>Let’s search for the methods invoked from the main method by using the following CQLinq query:&nbsp;</p>
<pre><font color="#0000ff">from</font> m <font color="#0000ff">in</font> Methods <font color="#0000ff">where</font> m.IsUsedBy (<font color="#800000">&quot;org.apache.cassandra.cli.CliMain.main(String[])&quot;</font>) <br /><font color="#0000ff">select new</font> { m, m.NbBCInstructions }<span style="font-family: Arial, Verdana, sans-serif; font-size: 12px;">&nbsp;</span></pre>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig3.png" alt="" _href="img://Fig3.png" _p="true" /></p>
<p>The main method uses <a href="http://jline.sourceforge.net/">JLine</a> which is a Java library for handling console input. It can be used to write nice CLI applications without much effort. It has out of the box support for Command History, Tab completion, Line editing, Custom Key Bindings, and Character masking.</p>
<p>And two interesting methods are used from the main method are:</p>
<ul> 
 <li>connect: The connect method is used to connect to the Cassandra database server.</li> 
 <li>processStatetementInteractive: This method is used to execute commands from the user.</li> 
</ul>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig4.png" alt="" _href="img://Fig4.png" _p="true" />&nbsp;</p>
<p>&nbsp;</p>
<h2>Communication between CLI and Cassandra Server</h2>
<p>Before interacting with Cassandra server the client must connect to it using the connect method.</p>
<p>Let’s search for all methods used directly or indirectly by the connect method:</p>
<pre><font color="#0000ff">from</font> m <font color="#0000ff">in</font> Methods<br /><font color="#0000ff">let</font> depth0 = m.DepthOfIsUsedBy(<font color="#800000">&quot;org.apache.cassandra.cli.CliMain.connect(String,int)&quot;</font>)<br /><font color="#0000ff">where</font> depth0 &gt;= <font color="#ffff00">0</font> <font color="#0000ff">orderby</font> depth0<br /><font color="#0000ff">select new</font> { m, depth0 }</pre>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig5.png" alt="" _href="img://Fig5.png" _p="true" /></p>
<p>The CLI communicates with the server using Thrift library which allows you to define the data types and service interfaces in a simple definition file. Taking that file as input, the compiler generates code to be used to easily build RPC clients and servers that communicate seamlessly across programming languages. Instead of writing a lot of boilerplate code to serialize and transport your objects and invoke remote methods, you can get right down to business.</p>
<p>Here’s a simple example of an implementation of a Thrift server:</p>
<pre>
public class Server {<br />
       public static class SomethingHandler implements Something.Iface {<br />
              public SomethingHandler() {}<br />
              public int ping() {<br />
                     return 1;<br />
                     }<br />
       }<br />
public static void main(String [] args) {<br />
       SomethingHandler handler = new SomethingHandler();<br />
       Something.Processor processor = new Something.Processor(handler);<br />
       TServerTransport serverTransport = new TServerSocket(9090);<br />
       TServer server = new TSimpleServer(processor, serverTransport);<br />
       //Or Use this for a multithreaded server<br />
       // server = new TThreadPoolServer(processor, serverTransport)<br />
       server.serve();<br />
}<br />
}</pre>
<p>The Thrift server implements org.apache.thrift.server.TServer interface and the constructor of its implementation takes as parameters a processor and a server transport specification. The processor needs a handler to treat the incoming requests.</p>
<p>Let’s discover all these elements in the Cassandra server. For that we can begin by searching all classes that inherit from TServer class.</p>
<pre><font color="#0000ff">from</font> t <font color="#0000ff">in</font> Types<br /><font color="#0000ff">let</font> depth0 = t.DepthOfDeriveFrom(<font color="#800000">&quot;org.apache.thrift.server.TServer&quot;</font>)<br /><font color="#0000ff">where</font> depth0 &gt;= <font color="#ffff00">0</font> <font color="#0000ff">orderby</font> depth0<br /><font color="#0000ff">select new</font> { t, depth0 }</pre>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig6.png" alt="" _href="img://Fig6.png" _p="true" /></p>
<p>Cassandra defines:</p>
<p>CustomTThreadPoolServer: It’s a slightly modified version of the Apache Thrift TThreadPoolServer which would use a thread pool to serve incoming requests.</p>
<p>CustomTHsHaServer: The goal of this server is to avoid sticking to one CPU for IO's. For better throughput it is spread across multiple threads. Number of selector threads can be the number of CPUs available.</p>
<p>CustomTNonBlockingServer: which uses a nonblocking socket transport.</p>
<p>And here’s what happens when the ThriftServer is started:</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig7.png" alt="" _href="img://Fig7.png" _p="true" /></p>
<p>A factory is used to create a TServer and the CassandraSever handler is created to treat incoming requests, it implements Cassandra.Iface which contains all commands supported by Cassandra. Below diagram shows some of these methods:</p>
<p>&nbsp;</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig8.png" alt="" _href="img://Fig8.png" _p="true" /></p>
<p>As shown in the previous Thrift server example, we need the processors to process incoming requests; all these processors inherit from ProcessFunction.</p>
<p>Here are some Cassandra processors:</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig9.png" alt="" _href="img://Fig9.png" _p="true" /></p>
<p>After discovering the Cassandra thrift server parts, let’s come back to the client and discover what happen when the connect method is invoked from the main method.</p>
<p><img title="clip_image014" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="clip_image014" src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig10.png" _href="img://Fig10.png" _p="true" /></p>
<p>The <strong>org.apache.thrift.TServiceClien</strong><strong>t</strong> is used to communicate between the client and the server, and the method sendBase is invoked to send a message to the thrift server.</p>
<p>On the server, the login processor receives this request and invokes the login method.</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig11.png" alt="" _href="img://Fig11.png" _p="true" /></p>
<p>And here’s the dependency graph showing some methods invoked from the login method.</p>
<p><img src="http://www.infoq.com/resource/articles/cassandra-cli-internals/en/resources/Fig12.png" alt="" _href="img://Fig12.png" _p="true" /></p>
<p>Steps to extend the CLI by adding a new method MyMethod.</p>
<p>After discovering how the CLI works internally, we can easily add a new method to it, and here are the major steps needed to do it:</p>
<p>I – extending the server:</p>
<ul> 
 <li>Add the method to <strong>Cassandra.Iface</strong></li> 
 <li>Add the method implementation to the <strong>CassandraServer</strong> class</li> 
 <li>Add a new class <strong>Cassandra.Processor.MyMethod&lt;l&gt;</strong> inheriting from <strong>ProcessFunction&lt;T&gt;</strong>.</li> 
 <li>Add an instance of the new processor in the Map returned by the <strong>Cassandra.Processor&lt;l&gt;.getProcessMap</strong> method.</li> 
</ul>
<p>II- Extending the client:</p>
<ul> 
 <li>Add a new switch and process it from <strong>CliOptions.processArgs</strong> method.</li> 
 <li>Add a method to the <strong>Cassandra.Client</strong> class and invoke the server by using the <strong>TServiceClient.sendBase</strong> method.</li> 
</ul>
<h2>Conclusion</h2>
<p>The command line interface is a good example to learn how to implement a Cassandra client, and learn from real projects is preferable than just search for samples in the web.&nbsp;So to develop a Cassandra client don’t hesitate to go inside its source code and enjoy.</p>
<h2>About the Author</h2>
<p><strong>Dane Dennis</strong> is the JArchitect Product Manager. He works at <a href="http://www.codergears.com">CoderGears</a>, a company developing tools for developers and architects.</p><br><br><br><br><br><br></body></html>