<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>PostgreSQL: Armazenamento de dados em formato "schemaless"</h3><p>Schemaless &eacute; um recurso oferecido por sistemas gerenciadores de banco de dados que fazem uso da abordagem NoSQL para armazenar dados sem que seja necess&aacute;rio se importar com a normaliza&ccedil;&atilde;o dos mesmos. Produtos como o MongoDB e o Cassandra fazem uso deste recurso para permitir que informa&ccedil;&otilde;es sejam armazenadas deixando toda a l&oacute;gica de tratamento e organiza&ccedil;&atilde;o da informa&ccedil;&atilde;o no lado da aplica&ccedil;&atilde;o.</p>
<p>Nos &uacute;ltimos anos, a escala para cria&ccedil;&atilde;o de aplica&ccedil;&otilde;es que tratam documentos de forma n&atilde;o estruturada vem crescendo cada vez mais e com isso muitos desenvolvedores s&atilde;o incentivados a utilizar produtos capazes de armazenar informa&ccedil;&otilde;es sem se preocupar com a modelagem dos dados que uma abordagem de banco de dados relacional normalmente costuma utilizar. Este artigo, apresenta uma sugest&atilde;o para utiliza&ccedil;&atilde;o do PostgreSQL como forma de armazenar dados no formato schemaless utilizando um m&oacute;dulo contrib do PostgreSQL, dispon&iacute;vel para uso desde a vers&atilde;o 8.4.</p>
<h2>Schemaless e modelagem tradicional de dados</h2>
<p>Utilizar shemaless, basicamente significa n&atilde;o se preocupar com os tipos de dados, nomes de colunas, nomes de tabelas e seus relacionamentos no formato relacional de um banco de dados, ou seja, n&atilde;o h&aacute; necessidade de fazer normaliza&ccedil;&atilde;o uma vez que a <a href="http://en.wikipedia.org/wiki/Document-oriented_database">recupera&ccedil;&atilde;o da informa&ccedil;&atilde;o pode ser realizada via endere&ccedil;amento de refer&ecirc;ncia simulando um vetor</a>. Em teoria, o que este recurso permite &eacute; armazenar todos os dados sem o conhecimento pr&eacute;vio das chaves ou tipos de dados.</p>
<p>A informa&ccedil;&atilde;o &eacute; geralmente constitu&iacute;da por uma cadeia que representa a chave e os dados reais, e &eacute; nomeado de relacionamento &quot;<a href="http://blog.marc-seeger.de/assets/papers/Ultra_Large_Sites_SS09-Seeger_Key_Value_Stores.pdf">chave - valor</a>&quot;. As informa&ccedil;&otilde;es em si s&atilde;o armazenadas em forma de algum dos tipos primitivos de uma linguagem de programa&ccedil;&atilde;o (uma string, um inteiro, um array ou um objeto) e s&atilde;o geridos por qualquer linguagem de programa&ccedil;&atilde;o capaz de realizar o gerenciamento do armazenamento das chaves e valores. A sugest&atilde;o desta abordagem, &eacute; de substituir a necessidade de modelo de dados fixa e tornar a exig&ecirc;ncia de dados devidamente formatados menos rigorosa.</p>
<p>Em um SGBD tradicional, muito tempo &eacute; dispensado para cria&ccedil;&atilde;o de um bom esquema que reflita da melhor forma poss&iacute;vel a modelagem de neg&oacute;cio. Perguntas como:</p>
<ul class="c7 lst-kix_pnvj9nkiat1h-0 start"> 
 <li>o campo CNPJ &eacute; um int ?</li> 
 <li>a data da consulta &eacute; do tipo time ou timestamp?</li> 
 <li>O n&uacute;mero do CPF pode ser armazenado como small int?</li> 
 <li>Ou podemos armazena-lo como varchar?</li> 
 <li>&Eacute; um char?</li> 
 <li>O campo CNPJ poder&aacute; ser indexado para que os usu&aacute;rios possam realizar pesquisas utilizando ele?</li> 
</ul>
<p>Durante o processo de modelagem de um banco de dados tradicional s&atilde;o realizadas ao extremo a fim de montar o melhor modelo de dados que possa atender &agrave;s necessidades de um determinado produto/neg&oacute;cio.</p>
<div id="lowerFullwidthVCR"></div>
<p>Segundo os defensores da abordagem NoSQL, a resposta a essas perguntas resume-se a apenas micro otimiza&ccedil;&otilde;es. Imagine um cen&aacute;rio em que o campo CNPJ seja do tipo big int. Com o passar do tempo, mais e mais informa&ccedil;&otilde;es s&atilde;o inseridas em uma tabela e ap&oacute;s algum tempo, &eacute; decidido que o campo precisa ser alterado para long. Ao final, se o banco de dados n&atilde;o for escal&aacute;vel horizontalmente n&atilde;o importar&aacute; a escolha feita pois ap&oacute;s 100, 1000, ou um bilh&atilde;o de registros, possivelmente o tipo de dado n&atilde;o suportar&aacute; mais informa&ccedil;&otilde;es ou n&atilde;o haver&aacute; mais espa&ccedil;o em disco o que acarretar&aacute; em uma substitui&ccedil;&atilde;o de hardware ou mesmo poder&atilde;o ocorrer situa&ccedil;&otilde;es de lentid&atilde;o muito grande no banco de dados.</p>
<p>Diante de um cen&aacute;rio como este, muitos arquitetos, desenvolvedores e engenheiros de software buscam alternativas para constru&ccedil;&atilde;o de modelos de dados que lhes permitam n&atilde;o se preocupar com modelagem de dados tradicional e seus tipos de dados. Como exemplo, nos &uacute;ltimos anos, muitas empresas vem buscando criar aplica&ccedil;&otilde;es m&oacute;veis para seus produtos e devido ao grande e merecido crescimento de produtos como o MongoDB e Cassandra que oferecem armazenamento de dados com relacionamentos chave/valor, essas empresas s&atilde;o levadas a &quot;adotar&quot; novas tecnologias sem levar em conta os recursos que produtos j&aacute; conhecidos por seus times de desenvolvimento sejam utilizados para suprir suas necessidades arquiteturais.</p>
<h2>O Hstore</h2>
<p><a href="http://www.postgresql.org/docs/current/static/hstore.html">Hstore</a> &eacute; um m&oacute;dulo contrib dispon&iacute;vel desde a vers&atilde;o 8.4 do PostgreSQL. Sua proposta consiste em ser &uacute;til para armazenar conjuntos de dados compostos por chave e valor e que s&atilde;o armazenados em uma &uacute;nica coluna de uma tabela conforme a proposta schemaless de produtos como o MongoDB e Cassandra. Tornou-se mais popular com o lan&ccedil;amento da vers&atilde;o 9.1 do PostgreSQL e recentemente com o <a href="http://www.infoq.com/br/news/2013/09/novo-postgresql93">lan&ccedil;amento da vers&atilde;o 9.3</a> uma abordagem mais simples de se trabalhar com este tipo de armazenamento de informa&ccedil;&otilde;es foi inclu&iacute;da. Al&eacute;m destes fatores, o suporte por muitos frameworks como o <a href="https://github.com/jordanm/django-hstore">Django</a>, <a href="https://github.com/softa/activerecord-postgres-hstore">Rails/ActiveRecord</a>, <a href="https://github.com/pvh/sequel-hstore">Sequel</a>, e <a href="https://github.com/mikl/node-hstore">Node.js</a> ajudaram a difundir seu uso.</p>
<p>Recentemente, em uma <a href="http://www.linkedin.com/groupAnswers?viewQuestionAndAnswers=&amp;discussionID=277135950&amp;gid=51776&amp;goback=%2Enmp_*1_*1_*1_*1_*1_*1_*1_*1_*1_*1#commentID_null">lista de profissionais PostgreSQL</a>, <a href="http://www.linkedin.com/profile/view?id=286625&amp;goback=%2Enmp_*1_*1_*1_*1_*1_*1_*1_*1_*1_*1%2Egde_51776_member_277135950">Dave Sisk</a> Arquiteto de Dados e DBA na <a href="http://appia.com/">Appia.com</a> lan&ccedil;ou o seguinte questionamento:</p>
<blockquote> 
 <p>Quem precisa de MongoDB se no PostgreSQL podemos simular o mesmo comportamento de schemaless com Hstore?</p> 
</blockquote>
<p>Dave Sisk, defende seu questionamento argumentando que o PostgreSQL &eacute; capaz de desempenhar muitas tarefas com pares de chave/valor que n&atilde;o s&atilde;o poss&iacute;veis fazer com MongoDB. Ele sugere a utiliza&ccedil;&atilde;o de express&otilde;es que indexam informa&ccedil;&otilde;es e realizam filtragem de &iacute;ndices para fazer algumas otimiza&ccedil;&otilde;es avan&ccedil;adas que n&atilde;o s&atilde;o pass&iacute;veis de se fazer com o MongoDB e cita por exemplo, a cria&ccedil;&atilde;o de <a href="http://www.postgresql.org/docs/9.3/static/indexes-partial.html">&iacute;ndices parciais</a> que podem ser utilizados apenas em linhas onde existam um determinado par chave/valor como nos casos em que uma <a href="http://stackoverflow.com/questions/2593250/representing-sparse-data-in-postgresql">chave esparsa</a>, ou seja, uma chave para situa&ccedil;&otilde;es em que a maioria das linhas s&atilde;o do tipo null, com isso, &eacute; poss&iacute;vel ter um &iacute;ndice bastante seletivo, r&aacute;pido em que o otimizador estar&aacute; preparado para utiliz&aacute;-lo.</p>
<p>Apesar de todo esse avan&ccedil;o, Dave Sisk n&atilde;o deixa de citar que &eacute; um fato n&atilde;o ser poss&iacute;vel alcan&ccedil;ar a capacidade de <a href="http://docs.mongodb.org/manual/core/sharded-cluster-shards/">distribui&ccedil;&atilde;o de dados</a> entre v&aacute;rios servidores apresentado pelo MongoDB. Por&eacute;m, para substituir essa necessidade, com o PostgreSQL &eacute; poss&iacute;vel fazer particionamento de uma tabela por heran&ccedil;a al&eacute;m de ser poss&iacute;vel &quot;particionar&quot; os <a href="http://www.postgresql.org/docs/9.3/static/indexes-partial.html">&iacute;ndices parcialmente</a>.</p>
<h2>Um exemplo de uso do Hstore</h2>
<p>Imagine um cen&aacute;rio em que seja preciso construir uma loja online que em princ&iacute;pio vende apenas livros. Neste caso, uma tabela de produtos composta pelos campos id, nome e descricao, onde o campo descricao &eacute; do tipo Hstore o qual dar&aacute; flexibilidade sobre o que &eacute; armazenado na tabela:</p>
<pre><p><span># CREATE TABLE produto ( <br /> id serial PRIMARY KEY, <br /> nome varchar, <br /> descricao hstore <br /> );</span></p></pre>
<p>Com isso, inserindo alguns dados na tabela teremos a seguinte estrutura:</p>
<pre><p><span># INSERT INTO produto (nome, descricao) VALUES ( <br /> 'The Bourne Sanction', <br /> 'autor =&gt; &quot;Robert Ludlum's&quot;, <br /> paginas =&gt; 688, <br /> categoria =&gt; fic&ccedil;&atilde;o,<br /> dispositivo =&gt; Kindle,<br /> formato =&gt; ebook' <br /> );</span></p></pre>
<p>Os dados em um campo Hstore podem ser consultados baseados no valor de sua descri&ccedil;&atilde;o:</p>
<pre><p><span># SELECT nome, descricao-&gt;'dispositivo' as dispositivo <br /> FROM produto <br /> WHERE descricao → 'formato' = 'ebook';</span></p></pre>
<p>Ou consultados baseados no valor de suas chaves:</p>
<pre><p><span># SELECT nome, descricao =&gt; 'paginas' <br /> FROM produto <br /> WHERE descricao ? 'paginas';</span></p></pre>
<p>Com o tempo, um diretor informa a seguinte situa&ccedil;&atilde;o: &quot;nossos livros n&atilde;o s&atilde;o lidos ou comprados. Vamos mudar nosso foco! N&oacute;s agora venderemos eletr&ocirc;nicos&quot;.</p>
<p>Esta decis&atilde;o pode precisar de uma mudan&ccedil;a no c&oacute;digo ou mesmo na marca da empresa mas o esquema permanecer&aacute; inalterado.</p>
<pre><p><span># INSERT INTO produto (nome, descricao) <br /> VALUES ( <br /> 'Leica M9', <br /> 'fabricante =&gt; Leica, <br /> tipo =&gt; camera, <br /> megapixels =&gt; 18, <br /> sensor =&gt; &quot;full-frame 35mm&quot;' <br /> ), <br /> ( 'MacBook Air 11', <br /> 'fabricante =&gt; Apple, <br /> tipo =&gt; computer, <br /> memoria_ram =&gt; 4GB, <br /> armazenamento_hd =&gt; 256GB, <br /> processador =&gt; &quot;1.8 ghz Intel i7 core duo&quot;, <br /> peso =&gt; 1kg' <br /> );</span></p></pre>
<p>&Eacute; poss&iacute;vel fazer uso de todos os recursos que um SGDB como PostgreSQL oferece para trabalhar com informa&ccedil;&otilde;es e com isso, campos do tipo Hstore tamb&eacute;m podem ser indexados:</p>
<pre><p><span># CREATE INDEX produto_fabricante <br /> ON produto ((produto.descricao-&gt;'fabricante'));</span></p></pre>
<p>Al&eacute;m de permitir fazer uso de JOINS:</p>
<pre><p><span># SELECT fabricante.pais, produto.nome <br /> FROM produto, fabricante <br /> WHERE produto.descricao -&gt; 'fabricante' = fabricante.nome;</span></p></pre>
<p>A flexibilidade para trabalhar com informa&ccedil;&otilde;es oferecido pelo Hstore torna seu uso cada vez mais vantajoso uma vez que a forma de armazenamento das informa&ccedil;&otilde;es, al&eacute;m de similar a oferecida por produtos NoSQL, &eacute; realizada na estrutura do banco de dados em formato bin&aacute;rio o que deixa seu desempenho ainda maior conforme gr&aacute;fico apresentado por <a href="http://thebuild.com/blog/">Christophe Pettus</a> durante o <a href="http://thebuild.com/presentations/pg-as-nosql-pgday-fosdem-2013.pdf">PgDay FOSDEM 2013</a> realizado na B&eacute;lgica.</p>
<p><img src="http://www.infoq.com/resource/articles/postgresql-schemaless/pt/resources/2image00.png" alt="" _href="img://2image00.png" _p="true" /></p>
<p><b>Tempo de grava&ccedil;&atilde;o em registros por segundo</b></p>
<h2>O que h&aacute; de novo para o Hstore</h2>
<p><a href="https://www.pgcon.org/2013/schedule/speakers/29.en.html">Oleg Bartunov</a>, um dos desenvolvedores mais ativos do n&uacute;cleo do PostgreSQL, <a href="http://obartunov.livejournal.com/172503.html#!">publicou em seu blog pessoal</a> como andam os trabalhos sobre o Hstore e quais as expectativas para este m&oacute;dulo para a pr&oacute;xima vers&atilde;o 9.4 que espera serem aprovados para o lan&ccedil;amento de 2014. Ele detalha alguns pontos importantes que foram apresentados durante o <a href="http://www.pgcon.org/2013/">PGCon-2013</a> em Ottawa.</p>
<blockquote> 
 <p>O m&oacute;dulo Hstore foi projetado originalmente como um tipo de dados para armazenamento de pares chave/valor com um rico conjunto de <a href="http://www.postgresql.org/docs/9.2/static/hstore.html">fun&ccedil;&otilde;es e operadores</a>. No entanto, rapidamente se tornou popular devido ao seu bom desempenho fornecidos pela uso de &iacute;ndices <a href="http://www.postgresql.org/docs/current/static/gin-intro.html">GIN</a> e <a href="http://www.postgresql.org/docs/9.3/static/gist-intro.html">GIST</a> al&eacute;m de fornecer a flexibilidade do modelo chave/valor. &Eacute; um recurso maduro, com mais de 10 anos de libera&ccedil;&atilde;o da 1&ordf; vers&atilde;o e uma extens&atilde;o do PostgreSQL muito est&aacute;vel.</p> 
</blockquote>
<p>O fato &eacute; que o PostgreSQL precisa de um suporte eficiente para modelos baseados em documentos tal como o CouchDB, MongoDB, Cassandra, entre outros. Atualmente, este tipo de recurso pode ser modelado tamb&eacute;m usando o tipo de dados JSON. <a href="http://www.postgresql.org/docs/9.3/static/functions-json.html">JSON</a> &eacute; um tipo de dados relativamente novo no PostgreSQL e possui uma grande desvantagem por ser basicamente uma string. Uma string que precisa ser analisada ​e tratada a cada acesso o que torna seu uso em consultas a grandes volume de dados muito lento.</p>
<p>Em uma compara&ccedil;&atilde;o de desempenho r&aacute;pida usando dados sint&eacute;ticos, &eacute; poss&iacute;vel observar o tempo de execu&ccedil;&atilde;o quando dados s&atilde;o armazenados em formato JSON comparados com Hstore.</p>
<pre><p><span>CREATE TABLE Hstore_test AS (SELECT 'a=&gt;1, b=&gt;2, c=&gt;3, d=&gt;4, e=&gt;5'::Hstore AS v FROM generate_series(1,1000000)); <br /> <br />CREATE TABLE json_test AS (SELECT '{&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4, &quot;e&quot;:5}'::json AS v FROM generate_series(1,1000000)); <br /> <br />SELECT sum((v-&gt;'a')::text::int) FROM json_test; <br /> 1291,060 ms <br /><br />SELECT sum((v-&gt;'a')::int) FROM Hstore_test; <br /> 303,267 ms</span></p></pre>
<p>Oleg Bartunov relata que a decis&atilde;o por desenvolver uma representa&ccedil;&atilde;o bin&aacute;ria para objetos aninhados diferente do JSON foi acordada entre o time principal de desenvolvedores para n&atilde;o afetar o n&uacute;cleo do PostgreSQL e que os novos recursos em desenvolvimento poder&atilde;o ser utilizados tanto com o Hstore como eventualmente com o JSON e cita:</p>
<blockquote> 
 <p>Por que escolhemos Hstore e n&atilde;o simplesmente iniciamos um trabalho mais aprofundado com JSON? A resposta &eacute; que JSON &eacute; um tipo de dados central e importante, as altera&ccedil;&otilde;es no n&uacute;cleo do PostgreSQL certamente iriam requerer muito mais esfor&ccedil;o, enquanto o Hstore ainda &eacute; um m&oacute;dulo, podemos trabalhar a vontade com ele. Para n&oacute;s, ainda n&atilde;o ficou claro se teremos sucesso, por isso decidimos ter uma certa liberdade com nosso prot&oacute;tipo. Uma vez que exista uma representa&ccedil;&atilde;o bin&aacute;ria eficiente, outros desenvolvedores poder&atilde;o escolher por come&ccedil;ar a trabalhar no apoio ao JSON.</p> 
</blockquote>
<p>Mesmo j&aacute; utilizado em muitas situa&ccedil;&otilde;es como a citada por Dave Sisk no in&iacute;cio deste artigo, muitas melhorias ainda s&atilde;o necess&aacute;rias no m&oacute;dulo Hstore para que ele seja incorporado de fato ao n&uacute;cleo do PostgreSQL. A proposta de Oleg Burtanov e seu grupo &eacute; de se empenhar para incrementar o Hstore, e eles esperam conseguir incorporar algumas dessas melhorias no lan&ccedil;amento da pr&oacute;xima vers&atilde;o do PostgreSQL. At&eacute; o momento, o resumo dos resultados alcan&ccedil;ados est&aacute; em:</p>
<ol class="c7 lst-kix_pnhnsu7zdaox-0 start" start="1"> 
 <li>O Hstore agora &eacute; um tipo aninhado de dados que suporta matrizes, o que significa construir um modelo simples de chave/valor para um modelo baseado em documentos ricos(dados n&atilde;o estruturados que originalmente estejam em formato PDF, doc ou similares);</li> 
 <li>O acesso a um determinado campo utilizando Hstore &eacute; mais r&aacute;pido gra&ccedil;as a sua representa&ccedil;&atilde;o bin&aacute;ria;</li> 
 <li>Operadores Hstore podem usar &iacute;ndices GIST e GIN;</li> 
 <li>Usu&aacute;rios JSON podem fazer uso de &iacute;ndices funcionais GIN e com isto conseguir um aumento de velocidade consider&aacute;vel;</li> 
 <li>A representa&ccedil;&atilde;o bin&aacute;ria do tipo de dados Hstore pode ser usada por JSON</li> 
</ol>
<p>Ainda h&aacute; muito trabalho a ser feito, para a vers&atilde;o 9.4 do PostgreSQL, a pretens&atilde;o &eacute; adicionar suporte a representa&ccedil;&otilde;es bin&aacute;rias, para que seja poss&iacute;vel ser usado com tipos de dados JSON melhorando sua indexa&ccedil;&atilde;o. Al&eacute;m disso, h&aacute; a necessidade de desenvolvimento de uma linguagem de consulta Hstore que permitir&aacute; uma melhor manipula&ccedil;&atilde;o de elementos do tipo Hstore.</p>
<h2>Conclus&otilde;es</h2>
<p>O ritmo de desenvolvimento de software atual &eacute; bastante acelerado e a cada dia a exig&ecirc;ncia de prazos menores para que as mudan&ccedil;as ocorram visando as necessidades que o mercado aguarda &eacute; maior. Desenvolvimento &aacute;gil, frameworks para desenvolvimento de aplica&ccedil;&otilde;es mais r&aacute;pidas, plataformas autom&aacute;ticas que permitem deploy em Cloud s&atilde;o os atuais multiplicadores e motores que est&atilde;o conduzindo essas mudan&ccedil;as. O projeto PostgreSQL tem observado essas tend&ecirc;ncias e abra&ccedil;ado estas causas. Se o seu projeto de software precisa de uma mudan&ccedil;a r&aacute;pida de requisitos, ou n&atilde;o se encaixa com esquemas pr&eacute;-definidos tradicionais (aplica&ccedil;&otilde;es que lidam com uma grande quantidade de informa&ccedil;&otilde;es n&atilde;o estruturadas por exemplo), Hstore pode ser a solu&ccedil;&atilde;o para este problema sem que haja necessidade do time de desenvolvimento aprender uma nova tecnologia.</p>
<h2>Sobre o Autor</h2>
<p>Marcelo Costa (<a href="http://www.linkedin.com/in/marcelojscosta">LinkedIn</a>, <a href="http://twitter.com/marcelojscosta">Twitter</a>) &eacute; p&oacute;s-graduado em Engenharia de Software pela UNICAMP. Atua em sistemas de alta complexidade desde 2002, gerenciando equipes multidisciplinares no desenvolvimento de software nas &aacute;reas de educa&ccedil;&atilde;o, sa&uacute;de e finan&ccedil;as. Especializa-se na coleta inteligente de informa&ccedil;&otilde;es na internet e de conte&uacute;do eletronicamente dispon&iacute;vel; atualmente &eacute; Growth Hacker e Engenheiro de Software na <a href="http://www.collect-in.com/">Collect-In Tecnologia</a>. Possui experi&ecirc;ncia com Lean, Kanban, Scrum, SOA, ALM, PostgreSQL, Shell Script, Java, PHP e Python.</p><br><br><br><br><br><br></body></html>