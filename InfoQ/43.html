<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>JSON-LD进入W3C推荐状态</h3><p>W3C RDF工作组已将JSON-LD和JSON-LD 1.0处理算法与API标准推进到推荐状态。JSON-LD是一个标准，旨在向JSON中加入“链接数据（linked data）”语义。JSON-LD文档看上去是像下面这样：</p>
<pre>
{
  &quot;@context&quot;: &quot;http://json-ld.org/contexts/person.jsonld&quot;,
  &quot;name&quot;: &quot;Manu Sporny&quot;,
  &quot;homepage&quot;: &quot;http://manu.sporny.org/&quot;,
  &quot;image&quot;: &quot;http://manu.sporny.org/images/manu.png&quot;
}
</pre>
<p>如果还不熟悉W3C的标准化流程，可以先了解一下：一个规范可以处于三个成熟层次之中。推荐（Recommendation）状态是特定规范的最后一步。W3C的建议是，推荐状态可以“广泛实现”，也就是说，相应规范已经为广泛的公开使用做好准备，而且足够稳定。</p>
<p>人们投入了很多工作才使JSON-LD进入这一状态：在4年多的时间里，有着100次电话会议，281份议题纪要，2 000次代码提交，以及2 500封电子邮件。</p>
<h2>进一步了解JSON-LD</h2>
<p>下面是一个直接选自<a href="http://www.w3.org/TR/2014/REC-json-ld-20140116/">规范</a>的例子：</p>
<pre>
{
  &quot;name&quot;: &quot;Manu Sporny&quot;,
  &quot;homepage&quot;: &quot;http://manu.sporny.org/&quot;,
  &quot;image&quot;: &quot;http://manu.sporny.org/images/manu.png&quot;
}
</pre>
<p>这个JSON文档表示一个人。人们很容易推断这里的语义：“name”是人的名字，“homepage”是其主页，“image”是其某种照片。然而机器不理解“name”和“image”这样的术语。</p>
<p>为解决该问题，我们可以使用链接数据。下面使用JSON-LD表示上面的例子：</p>
<pre>
{
  &quot;http://schema.org/name&quot;: &quot;Manu Sporny&quot;,
  &quot;http://schema.org/url&quot;: { &quot;@id&quot;: &quot;http://manu.sporny.org/&quot; },
  &quot;http://schema.org/image&quot;: { &quot;@id&quot;: &quot;http://manu.sporny.org/images/manu.png&quot; }
}
</pre>
<p>通过链接到schema.org上的定义，我们可以教给机器如何理解“name”、“url”和“image”的语义。不过有点复杂了。通过JSON-LD所谓的“上下文（context）”，我们可以兼顾第一个例子的简洁性和第二个例子的语义理解。基于第一个例子，我们引入一个context：</p>
<pre>
{
  &quot;@context&quot;: &quot;http://json-ld.org/contexts/person.jsonld&quot;,
  &quot;name&quot;: &quot;Manu Sporny&quot;,
  &quot;homepage&quot;: &quot;http://manu.sporny.org/&quot;,
  &quot;image&quot;: &quot;http://manu.sporny.org/images/manu.png&quot;
}
</pre>
<p>我们现在链接到了json-ld.org上的一个context。context文档看上去像下面这样：</p>
<pre>
{
  &quot;@context&quot;:
  {
    &quot;name&quot;: &quot;http://schema.org/name&quot;, 
    &quot;image&quot;: {
      &quot;@id&quot;: &quot;http://schema.org/image&quot;
      &quot;@type&quot;: &quot;@id&quot;
    },
    &quot;homepage&quot;: {
      &quot;@id&quot;: &quot;http://schema.org/url&quot;,
      &quot;@type&quot;: &quot;@id&quot;
    }
  }
}
</pre>
<p>这种方法的另一个优点是，多个文档可以使用同一个context。</p>
<h2>为什么没有选择RDF</h2>
<p>JSON-LD呈现出语义Web技术的风格，但是两者并不完全一样。它们有着类似的目标：围绕某类知识提供共享的上下文。例如，每个网站不应该围绕“name”重复发明概念。假设我们想研究几个不同的服务，以比较人们识别自身的方式。为了得到人们的名字，我们不得不针对每种API重新编写不同的代码，以确定如何取得其名字。</p>
<p>利用语义Web技术，每个服务都会暴露出“这是一个人（<a href="http://schema.org/Person">Person</a>）”这一语义，我们只需要编写一次代码，理解人是什么。而且可以跨多种服务复用代码。</p>
<p>尽管JSON-LD和更为传统的语义Web技术（如RDF）有着同样的最终目标，但是二者没有使用同样的构建块，JSON-LD W3C社区组的主席Manu Sporny就两者之间的关系<a href="http://manu.sporny.org/category/json-ld/">写了一篇博客</a>：</p>
<blockquote> 
 <p>这就是我实现JSON-LD时没有选择大部分语义Web技术栈（TURTLE/SPARQL/Quad Stores），而选择从头做起的原因。这一策略并不适合所有人，但却是唯一适合我们的，而且是我们所能想到的唯一能让更传统的语义Web技术从骄傲自满中醒悟过来的方式。</p> 
</blockquote>
<p>Manu还就规范简洁、清晰的文风做了详细说明：</p>
<blockquote> 
 <p>我们尽最大努力剔除JSON-LD规范中复杂的技术行话。而且我特别注意在JSON-LD 1.0规范中完全不提RDF，因为读者不需要为了理解JSON-LD文档转而去读RDF相关资料。在这一点上我们推回了很多次，我后面还会讲，但是问题在于我们想以相对于典型的Internet和Web规范更具谈话风格的方式传达信息，因为在规范中太早进入学究式风格会定下错误的基调。</p> 
</blockquote>
<p>这两点都表明， JSON-LD尝试将语义Web技术相关的探讨向如下方向推进：简单、不复杂以及面向一般开发人员。</p>
<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/news/2014/02/JSON-LD-W3C-recommendation">JSON-LD Reaches W3C Recommendation Status</a></p><br><br><br><br><br><br></body></html>