<p>Chris Travers recently published a series of articles titled “Building SOLID Databases”. He explains several ideas on how to apply some of the common OOP principles such as Single Responsibility Principle, Interface Segregation, Dependency Inversion to improve data models and database code. While some of the ideas can be applied in part to any relational databases, the articles showcase scenarios involving object-relational features such as table inheritance, available in databases like PostgreSQL.</p> 
<p align="justify">In <a href="http://ledgersmbdev.blogspot.in/2013/01/building-solid-databases-single.html">Single Responsibility And Normalization</a>, Chris explains the similarities and subtle differences between data models and class models. Normalization is normally sufficient for meeting the SRP in pure relational databases, but table inheritance can be further used to manage commonly co-occurring fields which are dependent on other fields in the database. He provides an example -</p> 
<blockquote> 
 <p align="justify">A common case where composition makes a big difference is in managing notes. People may want to attach notes to all kinds of other data in a database, and so one cannot say that the text or subject of a note is mutually dependent.</p> 
 <p align="justify">A typical purely relational approach is to either have many independently managed notes tables or have a single global note table which stores notes for everything, and then have multiple join tables to add join dependencies.</p> 
 <p align="justify">An object-relational approach might be to have multiple notes tables, but have them inherit the table structure of a common notes table.</p> 
</blockquote> 
<p align="justify">In the <a href="http://ledgersmbdev.blogspot.in/2013/01/building-solid-databases-openclosed.html">Open/Closed Principle</a>, the goal would be to keep the system extendable, without causing extensions to break when the base version changes. Again table inheritance can provide a flexible way to provide extension points for data models – the example here is how the pg_message_queue 0.2 can handle various data types by having a separate table to support each data type, all inheriting from a common table. Chris also provides another simple example where a secure API is kept extendable for security controls but closed for modifications.</p> 
<p align="justify">The <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substition Principle</a> is normally not a problem for purely Relational databases, but <a href="http://ledgersmbdev.blogspot.in/2013/02/building-solid-databases-liskov.html">could come to the fore-front</a> when you use table inheritance. An example here is a my_square table inheriting a my_rectangle table –</p> 
<div align="justify"> 
 <pre>
CREATE TABLE my_rectangle ( id serial primary key, height  numeric, width numeric );
CREATE TABLE my_square ( check (height = width) ) INHERITS  (my_rectangle);</pre> 
</div> 
<p align="justify">and run an update on my_rectangle -</p> 
<div align="justify"> 
 <pre>
UPDATE my_rectangle SET height = height * 2</pre> 
</div> 
<p align="justify">then it will cause referential issues in the square table and fail. Ways to handle this would be to either avoid updates altogether (keep rows immutable) or use triggers to delete rows from my_square and insert into my_rectangle whenever such updates are run.</p> 
<p align="justify"><a href="http://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation</a> <a href="http://ledgersmbdev.blogspot.in/2013/02/building-solid-databases-interface.html">when applied to databases</a> would involve mainly user-defined functions or stored procedures. Chris consider these as interfaces to the underlying data and suggests that the ideal function or stored procedure would have one large query with minimal surrounding logic – anything more than 5 queries or large number of optional parameters might point to reducible complexity which should be dealt with by breaking into multiple separate functions or stored procedures, each one for a specific purpose. This again goes hand in hand with the Single Responsibility Principle.</p> 
<p align="justify">In <a href="http://ledgersmbdev.blogspot.in/2013/02/building-solid-databases-dependency.html">Dependency Inversion and Robust DB Interfaces</a>, Chris explains how close binding between application logic and stored procedures can lead to leaky abstractions and suggests a few potential solutions. Some of them are using something akin to a service locator pattern, using Views or functions, using <a href="http://www.postgresql.org/docs/9.1/static/xtypes.html">custom datatypes</a>, triggers and notifications. They key suggestion here is to look at various options and design the database itself as an application exposing an appropriate API.&nbsp;</p> 
<p id="lastElm"></p>