<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>8 Great Java 8 Features No One's Talking about</h3><p>&nbsp;</p>
<p>If you haven’t seen some of the videos or tutorials around Java 8, you’ve probably been super-busy or have a more interesting social life than I do (which isn’t saying much). With new features like lambda expressions and Project Nashorn taking so much of the spotlight, I wanted to focus on some new APIs that have been a bit under the radar, but make Java 8 better in so many ways.</p>
<h2>1. Stamped Locks</h2>
<p>Multi-threaded code has long been the bane of server developers (just ask Oracle Java Language Architect and concurrency guru<a href="https://www.goodreads.com/author/quotes/73409.Brian_Goetz"> Brian Goetz</a>). Over time complex idioms were added to the core Java libraries to help minimize thread waits when accessing shared resources. One of these is the classic ReadWriteLock that lets you divide code into sections that need to be mutually exclusive (writers), and sections that don’t (readers).</p>
<p>On paper this sounds great. The problem is that the ReadWriteLock can be <a href="http://www.takipiblog.com/2014/04/16/java-8-longadders-the-fastest-way-to-add-numbers-concurrently/">super slow</a> (up to 10x), which kind of defeats its purpose. Java 8 introduces a new ReadWrite lock – called<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html"> StampedLock</a>. The good news here is that this guy is seriously fast. The bad news is that it’s more complicated to use and lugs around more state. It’s also not reentrant, which means a thread can have the dubious pleasure of deadlocking against itself.</p>
<p>StampedLock has an &quot;optimistic&quot; mode that issues a stamp that is returned by each locking operation to serve as a sort of admission ticket; each unlock operation needs to be passed its correlating stamp. Any thread that happens to acquire a write lock while a reader was holding an optimistic lock, will cause the optimistic unlock to be invalidated (the stamp is no longer valid). At that point the application can start all over, perhaps with a pessimistic lock (also implemented in StampedLock.) Managing that is up to you, and one stamp cannot be used to unlock another – so be super careful.</p>
<p>Let’s see this lock in action-</p>
<div id="lowerFullwidthVCR"></div>
<pre><font color="#0000ff">long</font> stamp = <font color="#0000ff">lock</font>.tryOptimisticRead(); <font color="#800040">// non blocking path - super fast</font><br />work();<font color="#800040"> // we're hoping no writing will go on in the meanwhile</font><br /><font color="#800040"><font color="#0000ff">if </font>(<font color="#0000ff">lock</font></font><font color="#000000">.validate(stamp)){</font><br /><font color="#800040">       //success! no contention with a writer thread </font><br />}<br /><font color="#800040"><font color="#0000ff">else</font> </font><font color="#000000">{</font><br /><font color="#800040">       //another thread must have acquired a write lock in the meanwhile, changing the stamp.&nbsp;</font><br /><font color="#800040">       //bummer - let's downgrade to a heavier read lock</font>
<br /><font color="#800040"><font color="#000000"> stamp</font> = <font color="#0000ff">lock</font>.<font color="#000000">readLock();</font> //this is a traditional blocking read lock </font><br /><font color="#800040"><font color="#0000ff"> try</font> </font><font color="#000000">{</font><br /><font color="#800040">                 //no writing happening now</font><br />                 work();
<br />       }<br /><font color="#800040"><font color="#0000ff"> finally</font> </font><font color="#000000">{</font><br /><font color="#800040"><font color="#0000ff"> lock</font><font color="#000000">.unlock(stamp);</font> // release using the correlating stamp</font>
       }<br />}</pre>
<h2>2. Concurrent Adders</h2>
<p>Another beautiful addition to Java 8, meant specifically for code running at scale, is the concurrent “Adders”. One of the most basic concurrency patterns is reading and writing the value of a numeric counter. As such, there are many ways in which you can do this today, but none so efficient or elegant as what Java 8 has to offer.</p>
<p>Up until now this was done using Atomics, which used a direct CPU compare and swap (CAS) instruction (via the <a href="http://www.docjar.com/html/api/sun/misc/Unsafe.java.html">sun.misc.Unsafe</a> class) to try and set the value of a counter. The problem was that when a CAS failed due to contention, the AtomicInteger would spin, continually retrying the CAS in an infinite loop until it succeeded. At high levels of contention this could prove to be pretty slow.</p>
<p>Enter Java 8’s<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html"> LongAdder</a>s. This set of classes provides a convenient way to concurrently read and write numeric values at scale. Usage is super simple. Just instantiate a new LongAdder and use its<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html#add-long-"> add()</a> and<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html#intValue--"> intValue()</a> methods to increase and sample the counter.</p>
<p>The difference between this and the old Atomics is that here, when a CAS fails due to contention, instead of spinning the CPU, the Adder will store the delta in an internal cell object allocated for that thread. It will then add this value along with any other pending cells to the result of intValue(). This reduces the need to go back and CAS or block other threads.</p>
<p>If you’re asking yourself when should I prefer to use concurrent Adders over Atomics to manage counters? The simple answer is – always.</p>
<h2>3. Parallel Sorting</h2>
<p>Just as concurrent Adders speed up counting, Java 8 delivers a concise way to speed up sorting. The recipe is pretty simple. Instead of -</p>
<pre><font color="#400080">Array</font>.sort(myArray);</pre>
<p>You can now use –</p>
<pre><font color="#400080">Arrays</font>.parallelSort(myArray);</pre>
<p>This will automatically break up the target collection into several parts, which will be sorted independently across a number of cores and then grouped back together. The only caveat here is that when called in highly multi-threaded environments, such as a busy web container, the benefits of this approach will begin to diminish (by <a href="http://www.takipiblog.com/2014/04/03/new-parallelism-apis-in-java-8-behind-the-glitz-and-glamour/">more than 90%</a>) due to the cost of increased CPU context switches.</p>
<h2>4. Switching to the new Date API</h2>
<p>Java 8 introduces a complete new <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html">date-time</a> API.&nbsp; You kind of know it’s about time when most of the methods of the current one are marked as deprecated... The new API brings ease-of-use and accuracy long provided by the popular Joda time API into the core Java library.</p>
<p>As with any new API the good news is that it’s more elegant and functional. Unfortunately there are still vast amounts of code out there using the old API, and that won’t change any time soon.</p>
<p>To help bridge the gap between the old and new API’s, the venerable Date class now has a new method called<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Date.html#toInstant--"> toInstant()</a> which converts the Date into the new representation. This can be especially effective in those cases where you're working on an API that expects the classic form, but would like to enjoy everything the new API has to offer.</p>
<h2>5. Controlling OS Processes</h2>
<p>Launching an OS process from within your code is right there with JNI calls – it’s something you do half-knowing there’s a good chance you’re going to get some unexpected results and some really bad exceptions down the line.</p>
<p>Even so, it’s a necessary evil. But processes have another nasty angle to them - they have a tendency to dangle. The problem with launching process from within Java code so far has been that is was hard to control a process once it was launched.</p>
<p>To help us with this Java 8 introduces three new methods in the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Process.html">Process</a> class -</p>
<ol> 
 <li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#destroyForcibly--">destroyForcibly</a> - terminates a process with a much higher degree of success than before.</li> 
 <li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#destroyForcibly--">isAlive</a> tells if a process launched by your code is still alive.</li> 
 <li>A new overload for waitFor() lets you specify the amount of time you want to wait for the process to finish. This returns whether the process exited successfully or timed-out in which case you might terminate it.</li> 
</ol>
<p>Two good use-cases for these new methods are -</p>
<ul> 
 <li>If the process did not finish in time, terminate and move forward:</li> 
</ul>
<pre><font color="#0000ff">if </font>(process.wait(MY_TIMEOUT, <font color="#400080">TimeUnit</font>.MILLISECONDS)){
<font color="#800040">       //success! </font>}<br /><font color="#400080">else</font> {
    process.destroyForcibly();<br />}</pre>
<ul> 
 <li>Make sure that before your code is done, you're not leaving any processes behind. Dangling processes can slowly but surely deplete your OS.</li> 
</ul>
<pre><font color="#400080">for </font>(<font color="#400080">Process</font> p : processes) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff"> if</font> (p.isAlive()) {<br />             p.destroyForcibly();<br />       }
}</pre>
<h2>6. Exact Numeric Operations</h2>
<p>Numeric overflows can cause some of the nastiest bugs due to their implicit nature. This is especially true in systems where int values (such as counters) grow over time. In those cases things that work well in staging, and even during long periods in production, can start breaking in the weirdest of ways, when operations begin to overflow and produce completely unexpected values.</p>
<p>To help with this Java 8 has added several<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#addExact-int-int-"> new “exact” methods</a> to the Math class geared towards protecting sensitive code from implicit overflows, by throwing an unchecked ArithmeticException when the value of an operation overflows its precision.</p>
<pre><font color="#400080">int</font> safeC = <font color="#400080">Math</font>.multiplyExact(bigA, bigB); <font color="#800040">// will throw ArithmeticException if result exceeds +-2^31</font></pre>
<p>The only downside is that it’s up to you to find those places in your code where overflows can happen. Not an automagical solution by any stretch, but I guess it’s better than nothing.</p>
<h2>7. Secure Random Generation</h2>
<p>Java has been under fire for several years for having security holes. Justified or not, a<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html"> lot of work</a> has been done to fortify the JVM and frameworks from possible attacks. Random numbers with a low-level of entropy make systems that use random number generators to create encryption keys or hash sensitive information more susceptible to hacking.</p>
<p>So far selection of the Random Number Generation algorithms has been left to the developer. The problem is that where implementations depend on specific hardware / OS / JVM, the desired algorithm may not be available. In such cases applications have a tendency to default to weaker generators, which can put them at greater risk of attack.</p>
<p>Java 8 has added a new method called<a href="http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html#getInstanceStrong--"> SecureRandom.getInstanceStrong()</a> whose aim is to have the JVM choose a secure provider for you. If you’re writing code without complete control of the OS / hardware / JVM on which it would run (which is very common when deploying to the cloud or PaaS), my suggestion is to give this approach some serious consideration.</p>
<h2>8. Optional References</h2>
<p>NulPointers are like <a href="https://i.chzbgr.com/maxW500/6044325376/hCEF652C1/">stubbing your toes</a> - you’ve been doing it since you could stand up, and no matter how smart you are today - chances are you still do. To help with this age-old problem Java 8 is introducing a new template called <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional&lt;T&gt;</a>.&nbsp;&nbsp;</p>
<p>Borrowing from Scala and Haskell, this template is meant to explicitly state when a reference passed to or returned by a function can be null. This is meant to reduce the guessing game of whether a reference can be null, through over-reliance on documentation which may be out-of-date, or reading code which may change over time.</p>
<pre><font color="#400080">Optional</font>&lt;<font color="#400080">User</font>&gt; tryFindUser(<font color="#0000ff">int</font> userID) {</pre>
<p>or -</p>
<pre><font color="#0000ff">void</font> processUser(<font color="#400080">User</font> user, <font color="#400080">Optional</font>&lt;<font color="#400080">Cart</font>&gt; shoppingCart) {</pre>
<p>The Optional template has a set of functions that make sampling it more convenient, such as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#isPresent--">isPresent() </a>to check if an non-null value is available, or&nbsp; <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#ifPresent-java.util.function.Consumer-">ifPresent()</a> to which you can pass a Lambda function that will be executed if isPresent is true. The downside is that much like with Java 8’s new date-time APIs, it will take time and work till this pattern takes hold and is absorbed into the libraries we use and design everyday.</p>
<p>New Lambda syntax for printing an optional value -</p>
<pre>
value.ifPresent(<font color="#400080">System</font>.<font color="#0000ff">out</font>::<font color="#0000ff">print</font>);</pre>
<h2>About the Author</h2>
<p><a href="https://plus.google.com/+TalWeissGx?rel=author"><strong><img src="http://www.infoq.com/resource/articles/Java-8-Quiet-Features/en/resources/Tal-Weiss.png" vspace="3" hspace="3" align="left" alt="" _href="img://Tal-Weiss.png" _p="true" />Tal Weiss</strong></a>&nbsp;is the CEO of <a href="http://www.takipi.com/">Takipi</a>. Tal has been designing scalable, real-time Java and C++ applications for the past 15 years. He still enjoys analyzing a good bug though, and instrumenting Java code. In his free time Tal plays Jazz drums.</p><br><br><br><br><br><br></body></html>