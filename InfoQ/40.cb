<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Asserções Customizadas em Testes</h3><p>Escrever asser&ccedil;&otilde;es para testes parece ser bem simples: tudo o que precisa-se &eacute; comparar os resultados com as espectativas. Normalmente utilizando m&eacute;todos de asser&ccedil;&otilde;es, como por exemplo assertTrue() e assertEquals(), dispon&iacute;veis por frameworks de teste. Entretanto, em cen&aacute;rios mais complexos pode parecer estranho verificar o resultado utilizando asser&ccedil;&otilde;es t&atilde;o b&aacute;sicas.</p>
<p>O ponto &eacute; que utilizando estas asser&ccedil;&otilde;es b&aacute;sicas, os testes tornam-se obscuros com tantos detalhes de baixo n&iacute;vel.</p>
<p>Neste artigo, ser&aacute; mostrado como pode-se utilizar as chamadas &quot;bibliotecas de matcher&quot; para implementar asser&ccedil;&otilde;es customizadas a fim de tornar os testes mais leg&iacute;veis e de f&aacute;cil manuten&ccedil;&atilde;o.</p>
<p>Como demonstra&ccedil;&atilde;o, ser&aacute; considerada a seguinte tarefa: desenvolver uma classe para o m&oacute;dulo de relat&oacute;rio da uma aplica&ccedil;&atilde;o de modo que fornecendo duas datas (&quot;inicio&quot; e &quot;fim&quot;), seja retornado os intervalos de uma hora entre essas duas datas. Os intervalos s&atilde;o usados posteriormente para recuperar dados necess&aacute;rios da base de dados e apresent&aacute;-los para o usu&aacute;rio final na forma de gr&aacute;ficos.</p>
<h2>Abordagem Padr&atilde;o</h2>
<p>Primeiramente ser&aacute; apresentado o modo padr&atilde;o de escrita de asser&ccedil;&otilde;es. Ser&aacute; utilizado o <a href="http://junit.org/">JUnit</a> , por&eacute;m podendo ser aplicado da mesma forma, por exemplo, ao <a href="http://testng.org">TestNG</a>. Aqui ser&atilde;o utilizados os m&eacute;todos de asser&ccedil;&otilde;es como assertTrue(), assertNotNull() e assertSame().</p>
<p>A seguir &eacute; exibido um dos muitos testes pertencentes a classe HourRangeTest. O teste primeiro recupera a lista de intervalos de horas de duas datas do mesmo dia no m&eacute;todo getRanges(). Depois verifica se o conjunto retornado &eacute; exatamente como deveria ser.</p>
<div id="lowerFullwidthVCR"></div>
<pre><p><span> private final static SimpleDateFormat SDF = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); <br /><br /> @Test <br /> public void shouldReturnHourlyRanges() throws ParseException { <br /> // given <br /> Date dateFrom = SDF.parse(&quot;2012-07-23 12:00&quot;); <br /> Date dateTo = SDF.parse(&quot;2012-07-23 15:00&quot;); <br /> // when <br /> final List&lt;Range&gt; ranges = HourlyRange.getRanges(dateFrom, dateTo); <br /> // then <br /> assertEquals(3, ranges.size()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 12:00&quot;).getTime(), ranges.get(0).getStart()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 13:00&quot;).getTime(), ranges.get(0).getEnd()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 13:00&quot;).getTime(), ranges.get(1).getStart()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 14:00&quot;).getTime(), ranges.get(1).getEnd()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 14:00&quot;).getTime(), ranges.get(2).getStart()); <br /> assertEquals(SDF.parse(&quot;2012-07-23 15:00&quot;).getTime(), ranges.get(2).getEnd()); <br /> }</span></p>

</pre>
<p>Este &eacute;, sem sobra de d&uacute;vidas, um teste v&aacute;lido; entretanto, h&aacute; muitos fragmentos repetidos na parte ap&oacute;s o //then. Obviamente eles foram criados usando o recurso de copiar e colar, o que leva inevitavelmente &agrave; erros. Al&eacute;m do mais, se for necess&aacute;rio escrever mais testes como este (e &eacute; claro que se deve escrever mais testes para verificar a classe HourlyRange!), as mesmas linhas de asser&ccedil;&otilde;es se repetiriam mais e mais vezes em cada teste.</p>
<p>A legibilidade do teste atual &eacute; enfraquecida pelo excesso de asser&ccedil;&otilde;es, mas tamb&eacute;m pela complicada natureza de cada asser&ccedil;&atilde;o. H&aacute; v&aacute;rios detalhes de baixo n&iacute;vel, que n&atilde;o ajudam &agrave; compreender o cen&aacute;rio central do teste. Trechos de c&oacute;digo s&atilde;o lidos muito mais frequentemente do que escritos (tamb&eacute;m se aplica aos testes), sendo assim, deve-se sempre ter a legibilidade como foco de aperfei&ccedil;oamento.</p>
<p>Outro ponto negativo do teste, desta vez relacionado &agrave; mensagem de erro recebida quando algo da errado. Por exemplo, se um dos intervalos retornados pelo m&eacute;todo getRanges() possuir um tempo diferente do esperado, tudo que vamos ver &eacute; algo como:</p>
<pre><p><span>org.junit.ComparisonFailure: <br /> Expected :1343044800000 <br /> Actual :1343041200000</span></p>

</pre>
<p>Essa mensagem n&atilde;o &eacute; muito clara e pode ser melhorada.</p>
<h2>M&eacute;todos Privados</h2>
<p>A fim de aperfei&ccedil;oar o exemplo anterior pode-se extrair a asser&ccedil;&atilde;o para um m&eacute;todo privado.</p>
<pre><p><span> private void assertThatRangeExists(List&lt;Range&gt; ranges, int rangeNb, <br /> String start, String stop) throws ParseException { <br /> assertEquals(ranges.get(rangeNb).getStart(), SDF.parse(start).getTime()); <br /> assertEquals(ranges.get(rangeNb).getEnd(), SDF.parse(stop).getTime()); <br /> } <br /> @Test <br /> public void shouldReturnHourlyRanges() throws ParseException { <br /> // given <br /> Date dateFrom = SDF.parse(&quot;2012-07-23 12:00&quot;); <br /> Date dateTo = SDF.parse(&quot;2012-07-23 15:00&quot;); <br /> // when <br /> final List&lt;Range&gt; ranges = HourlyRange.getRanges(dateFrom, dateTo); <br /> // then <br /> assertEquals(ranges.size(), 3); <br /> assertThatRangeExists(ranges, 0, &quot;2012-07-23 12:00&quot;, &quot;2012-07-23 13:00&quot;); <br /> assertThatRangeExists(ranges, 1, &quot;2012-07-23 13:00&quot;, &quot;2012-07-23 14:00&quot;); <br /> assertThatRangeExists(ranges, 2, &quot;2012-07-23 14:00&quot;, &quot;2012-07-23 15:00&quot;); <br /> }</span></p>

</pre>
<p>A quantidade de c&oacute;digo repetido foi reduzida e a legibilidade aumentou.</p>
<p>Outra vantagem dessa abordagem &eacute; ter melhor controle para permitir aprimorar a mensagem de erro que &eacute; exibida na verifica&ccedil;&atilde;o que falhou. O c&oacute;digo de asser&ccedil;&atilde;o &eacute; extra&iacute;do em um m&eacute;todo, permitindo alterar a asser&ccedil;&atilde;o com mensagens de erro mais leg&iacute;veis com facilidade.</p>
<p>O reuso de m&eacute;todos de asser&ccedil;&atilde;o como este pode ser facilitado movendo-os para uma classe base que a classe de testes precisaria estender.</p>
<p>O habito de utilizar m&eacute;todos privados possui alguns pontos negativos, que tornam-se mais evidentes a medida que a quantidade de c&oacute;digo de teste cresce e estes m&eacute;todos privados come&ccedil;am a ser utilizados em muitos m&eacute;todos de teste:</p>
<ol> 
 <li>&Eacute; dif&iacute;cil lembrar de nomes de m&eacute;todos de asser&ccedil;&otilde;es que retratam claramente o que eles verificam;</li> 
 <li>Seguindo o crescimento dos requisitos, estes m&eacute;todos tendem a receber par&acirc;metros adicionais para verifica&ccedil;&otilde;es mais sofisticadas (o m&eacute;todo assertThatRangeExists() recebe 4 par&acirc;metros, o que j&aacute; &eacute; muito!);</li> 
 <li>&Agrave;s vezes, a fim de reutilizar o m&eacute;todo em muitos testes, alguma l&oacute;gica complicada &eacute; adicionado ao m&eacute;todo (normalmente, na forma de flags booleanas que verificam ou ignoram alguns casos especiais).</li> 
</ol>
<p>Tudo isso significa que ao longo do tempo pode-se encontrar problemas relacionados com a legibilidade e manutenibilidade dos testes escritos com a ajuda de m&eacute;todos de asser&ccedil;&atilde;o privados. A seguir ser&aacute; apresentada outra solu&ccedil;&atilde;o livre desses pontos negativos.</p>
<h2>Bibliotecas de Matcher</h2>
<p>Como foi mencionado anteriormente, as asser&ccedil;&otilde;es providas pelo JUnit ou TestNG n&atilde;o s&atilde;o flex&iacute;veis o suficiente. No mundo Java h&aacute; pelo menos duas bibliotecas open source que suprem essas necessidades: <a href="http://joel-costigliola.github.io/assertj">AssertJ</a> (um fork do projeto FEST Fluent Assertions) e o <a href="http://hamcrest.org">Hamcrest</a>. Os dois s&atilde;o bastante poderosos e permitem atingir efeitos similares. A principal diferen&ccedil;a do AssertJ sobre o Hamcrest &eacute; sua API, baseada em interfaces fluentes, que &eacute; perfeitamente suportada pelas IDEs.</p>
<p>Para integrar o AssertJ com o JUnit ou TestNG basta somente realizar os imports necess&aacute;rios, parar de utilizar as asser&ccedil;&otilde;es padr&otilde;es do framework de teste e iniciar o uso das asser&ccedil;&otilde;es fornecidas pelo AssertJ.</p>
<p>O AssertJ fornece muitas asser&ccedil;&otilde;es que seguem o mesmo padr&atilde;o: come&ccedil;am com o m&eacute;todo assertThat(), um m&eacute;todo est&aacute;tico da classe Assertions que recebe o objeto testado como par&acirc;metro. Logo em seguida s&atilde;o os m&eacute;todos de asser&ccedil;&atilde;o, no qual cada um verifica as propriedades do objeto testado:</p>
<pre><p><span> assertThat(myDouble).isLessThanOrEqualTo(2.0d); <br /> <br /> assertThat(myListOfStrings).contains(&quot;a&quot;); <br /> <br /> assertThat(&quot;some text&quot;) <br /> .isNotEmpty() <br /> .startsWith(&quot;some&quot;) <br /> .hasLength(9);</span></p></pre>
<p>O AssertJ prov&ecirc; um conjunto muito mais rico de asser&ccedil;&otilde;es que o JUnit ou TestNG. Pode-se encadear os m&eacute;todos entre si, assim como &eacute; mostrado no exemplo anterior, permitindo que a IDE sugira os m&eacute;todos que podem ser utilizados baseado no tipo de objeto sendo testado. Por exemplo, no caso de uma vari&aacute;vel de ponto flutuante, ap&oacute;s assertEquals(myDouble) e CTRL+SPACE pressionado (dependendo da IDE), ser&aacute; exibido uma lista de m&eacute;todos como isEqualTo(expectedDouble), isNegative() ou isGreaterThan(otherDouble) - todos que fazem sentido com a verifica&ccedil;&atilde;o do valor de ponto flutuante.</p>
<h3><img src="http://www.infoq.com/resource/articles/custom-assertions/pt/resources/14Fig1.png" alt="Suggest&otilde;es da IDE" _href="img://14Fig1.png" _p="true" /></h3>
<h2>Asser&ccedil;&otilde;es Customizadas</h2>
<p>Outra caracter&iacute;stica das bibliotecas de matcher &eacute; permitir a escrita de asser&ccedil;&otilde;es customizadas. Essas asser&ccedil;&otilde;es customizadas v&atilde;o se comportar exatamente como as asser&ccedil;&otilde;es do AssertJ se comportam - por exemplo, ser&aacute; poss&iacute;vel encade&aacute;-las.</p>
<p>Antes de implementar uma asser&ccedil;&atilde;o customizada, a seguir &eacute; exibido como pode ficar o teste da classe HourlyRange, sendo utilizado o m&eacute;todo assertThat() da classe RangeAssert.</p>
<pre><p><span> @Test <br /> public void shouldReturnHourlyRanges() throws ParseException { <br /> // given <br /> Date dateFrom = SDF.parse(&quot;2012-07-23 12:00&quot;); <br /> Date dateTo = SDF.parse(&quot;2012-07-23 15:00&quot;); <br /> // when <br /> List&lt;Range&gt; ranges = HourlyRange.getRanges(dateFrom, dateTo); <br /> // then <br /> RangeAssert.assertThat(ranges) <br /> .hasSize(3) <br /> .isSortedAscending() <br /> .hasRange(&quot;2012-07-23 12:00&quot;, &quot;2012-07-23 13:00&quot;) <br /> .hasRange(&quot;2012-07-23 13:00&quot;, &quot;2012-07-23 14:00&quot;) <br /> .hasRange(&quot;2012-07-23 14:00&quot;, &quot;2012-07-23 15:00&quot;); <br /> }</span></p>

</pre>
<p>Algumas das vantagem de asser&ccedil;&otilde;es customizadas podem ser vistas at&eacute; mesmo em um pequeno exemplo como o mostrado anteriormente. A primeira coisa &agrave; se notar sobre o teste &eacute; que a parte do //then ficou menor e bem mais leg&iacute;vel agora.</p>
<p>Outras vantagens ir&atilde;o aparacer quando eles forem aplicados em uma base de c&oacute;digo maior. Continuando &agrave; utlizar a asser&ccedil;&atilde;o customizada, nota-se que:</p>
<ol start="1"> 
 <li>N&atilde;o &eacute; necess&aacute;rio utilizar todas as asser&ccedil;&otilde;es, mas pode-se selecionar aquelas que s&atilde;o mais importantes para o caso de teste especifico;</li> 
 <li>Para cen&aacute;rios de teste espec&iacute;ficos, pode-se mudar as asser&ccedil;&otilde;es de acordo com a prefer&ecirc;ncia (por exemplo, passando objetos Date ao inv&eacute;s de String) com muita facilidade, favorecendo uma DSL. O que &eacute; mais importante, uma mudan&ccedil;a como essa n&atilde;o afetaria nenhum outro teste;</li> 
 <li>Maior legibilidade - n&atilde;o h&aacute; dificuldade em nomear corretamente um m&eacute;todo de verifica&ccedil;&atilde;o, visto que a asser&ccedil;&atilde;o &eacute; composta por muitas pequenas asser&ccedil;&otilde;es, cada uma focada em um pequeno aspecto da verifica&ccedil;&atilde;o.</li> 
</ol>
<p>A &uacute;nica desvantagem das asser&ccedil;&otilde;es customizadas, comparadas com m&eacute;todos de asser&ccedil;&atilde;o privados, &eacute; a quantidade de esfor&ccedil;o na cria&ccedil;&atilde;o delas. Vamos dar uma olhada no c&oacute;digo da nossa asser&ccedil;&atilde;o customizada para analisar o tamanho do trabalho extra.</p>
<p>Para se criar uma asser&ccedil;&atilde;o customizada, basta estender a classe AbstractAssert do AssertJ ou algumas de suas muitas subclasses. Como mostrado a seguir, a classe RangeAssert estende da classe ListAssert do AssertJ. Isso faz sentido pois ser&aacute; verificado o conte&uacute;do de uma lista de intervalos (List&lt;Range&gt;).</p>
<p>Cada asser&ccedil;&atilde;o customizada escrita com o AssertJ cont&eacute;m c&oacute;digo que &eacute; respons&aacute;vel pela cria&ccedil;&atilde;o do objeto de asser&ccedil;&atilde;o e a inje&ccedil;&atilde;o do objeto testado, para que os outros m&eacute;todos possam operar sobre ele. Como mostrado na listagem a seguir, tanto o construtor como o m&eacute;todo est&aacute;tico assertThat() recebem como par&acirc;metro um objeto do tipo List&lt;Range&gt;.</p>
<pre><p><span> public class RangeAssert extends ListAssert&lt;Range&gt; { <br /> <br /> protected RangeAssert(List&lt;Range&gt; ranges) { <br /> super(ranges); <br /> } <br /> <br /> public static RangeAssert assertThat(List&lt;Range&gt; ranges) { <br /> return new RangeAssert(ranges); <br /> }</span></p>

</pre>
<p>Os m&eacute;todos hasRange() e isSortedAscending (mostrados na pr&oacute;xima listagem) s&atilde;o exemplos t&iacute;picos de m&eacute;todos de asser&ccedil;&atilde;o customizados da classe RangeAssert. Eles compartilham as seguintes propriedades:</p>
<ol start="1"> 
 <li>Os dois come&ccedil;am com uma chamada para o m&eacute;todo isNotNull() que verifica se o objeto testado est&aacute; nulo. Isso garante que a verifica&ccedil;&atilde;o n&atilde;o falhe devido &agrave; algum NullPointerException (este passo n&atilde;o &eacute; necess&aacute;rio, mas &eacute; recomendado);</li> 
 <li>Os dois m&eacute;todos retornam &quot;this&quot; (o pr&oacute;prio objeto da asser&ccedil;&atilde;o customizada - da classe RangeAssert, neste caso), permitindo que as chamadas possam ser encadeadas;</li> 
 <li>A verifica&ccedil;&atilde;o &eacute; feita utilizando asser&ccedil;&otilde;es fornecidas pela classe Assertions (parte do framework do AssertJ);</li> 
 <li>Os dois m&eacute;todos usam um objeto &quot;actual&quot; (fornecido pela superclasse ListAssert), que mant&eacute;m a lista de Ranges (List&lt;Range&gt;) sendo verificada.</li> 
</ol>
<pre><p><span> private final static SimpleDateFormat SDF <br /> = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); <br /> <br /> public RangeAssert isSortedAscending() { <br /> isNotNull(); <br /> long start = 0; <br /> for (int i = 0; i &lt; actual.size(); i++) { <br /> Assertions.assertThat(start) <br /> .isLessThan(actual.get(i).getStart()); <br /> start = actual.get(i).getStart(); <br /> } <br /> return this; <br /> } <br /> <br /> public RangeAssert hasRange(String from, String to) throws ParseException { <br /> isNotNull(); <br /> <br /> Long dateFrom = SDF.parse(from).getTime(); <br /> Long dateTo = SDF.parse(to).getTime(); <br /> <br /> boolean found = false; <br /> for (Range range : actual) { <br /> if (range.getStart() == dateFrom &amp;&amp; range.getEnd() == dateTo) { <br /> found = true; <br /> } <br /> } <br /> Assertions <br /> .assertThat(found) <br /> .isTrue(); <br /> return this; <br /> <br /> } <br /> }</span></p>

</pre>
<p>O AssertJ permite adicionar uma mensagem de erro personalizada facilmente. Neste caso, como se trata de uma compara&ccedil;&atilde;o de valores, o m&eacute;todo as() &eacute; suficiente, como no exemplo a seguir:</p>
<pre><p><span> Assertions <br /> .assertThat(actual.size()) <br /> .as(&quot;number of ranges&quot;) <br /> .isEqualTo(expectedSize);</span></p>

</pre>
<p>O m&eacute;todo as() &eacute; outro m&eacute;todo fornecido pelo framework AssertJ. Agora, quando o teste falha, uma mensagem personalizada &eacute; impressa ajudando a identificar o problema imediatamente.</p>
<pre><p><span> org.junit.ComparisonFailure: [number of ranges] <br /> Expected :4 <br /> Actual :3</span></p>

</pre>
<p>&Agrave;s vezes &eacute; necess&aacute;rio mais do que o nome do objeto testado para compreender o que ocorreu. Seria muito bom poder imprimir todos os intervalos durante a falha. Isso pode ser feito utilizando o m&eacute;todo overriginErrorMessage(), como a seguir:</p>
<pre><p><span> public RangeAssert hasRange(String from, String to) throws ParseException { <br /> ... <br /> String errMsg = String.format(&quot;ranges\n%s\ndo not contain %s-%s&quot;, <br /> actual ,from, to); <br /> <br /> ... <br /> Assertions.assertThat(found) <br /> .overridingErrorMessage(errMsg) <br /> .isTrue(); <br /> ... <br /> }</span></p>

</pre>
<p>Durante a falha, pode-se observar uma mensagem de erro muito mais detalhada. Seu conte&uacute;do dependeria do m&eacute;todo toString() da classe Range:</p>
<pre><p><span> HourlyRange{Mon Jul 23 12:00:00 CEST 2012 to Mon Jul 23 13:00:00 CEST 2012}, <br /> HourlyRange{Mon Jul 23 13:00:00 CEST 2012 to Mon Jul 23 14:00:00 CEST 2012}, <br /> HourlyRange{Mon Jul 23 14:00:00 CEST 2012 to Mon Jul 23 15:00:00 CEST 2012}] <br /> do not contain 2012-07-23 16:00-2012-07-23 14:00</span></p>

</pre>
<h2>Conclus&otilde;es</h2>
<p>Neste artigo foram abordadas algumas formas de escrever asser&ccedil;&otilde;es. Primeiro foi tratado o modelo &quot;tradicional&quot;, baseado nas asser&ccedil;&otilde;es dispon&iacute;veis pelos frameworks de teste. Mesmo sendo suficiente em muitos casos, pode-se perceber que &agrave;s vezes n&atilde;o possui flexibilidade para expressar o objetivo do teste. Na sequ&ecirc;ncia, foram introduzidos os m&eacute;todos de asser&ccedil;&atilde;o privados, que tamb&eacute;m n&atilde;o se apresentaram como a solu&ccedil;&atilde;o ideal. Por &uacute;ltimo, foram apresentadas as asser&ccedil;&otilde;es customizadas com o AssertJ, onde se atingiu maior legibilidade e manutenabilidade do c&oacute;digo de teste.</p>
<p>Segue uma dica sobre asser&ccedil;&otilde;es: elas podem melhor significantemente os testes se ao inv&eacute;s de utilizar as asser&ccedil;&otilde;es fornecidas pelos framework de testes (como o JUnit e TestNG), forem utilizadas as asser&ccedil;&otilde;es fornecidas por bibliotecas de matcher (como o AssertJ ou Hamcrest).</p>
<p>Mesmo que o custo de escrever asser&ccedil;&otilde;es customizadas for muito pequeno, n&atilde;o &eacute; necess&aacute;rio adicion&aacute;-los somente pela facilidade. Use-os quando a legibilidade e/ou manutenabilidade do seu c&oacute;digo de teste est&aacute; em perigo. Tente introduzir asser&ccedil;&otilde;es customizadas nos seguintes cen&aacute;rios:</p>
<ul> 
 <li>Quando encontrar dificuldade em expressar o objetivo do teste com as asser&ccedil;&otilde;es fornecidas pelas bibliotecas de matcher;</li> 
 <li>No lugar dos m&eacute;todos privados de asser&ccedil;&atilde;o.</li> 
</ul>
<p>Em testes unit&aacute;rios raramente ser&aacute; necess&aacute;rio asser&ccedil;&otilde;es customizadas. Entretanto, elas podem ser insubstitu&iacute;veis no caso de testes de integra&ccedil;&atilde;o e ponto-a-ponto (funcionais). Estes testes permitem escrever c&oacute;digo na linguagem de dom&iacute;nio, encapsulando detalhes t&eacute;cnicos, e tornando nosso teste muito mais simples de manter.</p>
<h2>Sobre o autor</h2>
<p><strong><img src="http://www.infoq.com/resource/articles/custom-assertions/pt/resources/1tomek_kaczanowski_250.png" alt="Tomek Kaczanowski" _href="img://1tomek_kaczanowski_250.png" _p="true" />Tomek Kaczanowski</strong> trabalha como desenvolver Java para a CodeWise (Krakow, Pol&ocirc;nia) focando em qualidade de c&oacute;digo, testes e automa&ccedil;&atilde;o. Entusiasta TDD, proponente open source e adorador &aacute;gil. Tamb&eacute;m &eacute; <a href="http://practicalunittesting.com">autor de livro</a>, <a href="http://kaczanowscy.pl/tomek">blogueiro</a> e palestrante. Twitter: @tkaczanowski</p><br><br><br><br><br><br></body></html>