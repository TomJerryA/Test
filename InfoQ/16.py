<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>関数を理解するマージツール</h3><p><a target="_blank" href="http://www.infoq.com/news/2013/04/Semantic-Merge;jsessionid=5E013354535A66D9DF6C767ED1C63076"><em>原文(投稿日：2013/04/16)へのリンク</em></a></p> 
<div class="clearer-space">
 &nbsp;
</div> 
<div id="newsContent"> 
 <p><a target="_blank" href="http://plasticscm.com/">Plastic SCM</a> を開発したCodice Softwareが，セマンティックマージツール (Semantic Merge Tool) のプレビュー版をリリースした。このツールはコードを解析することで，行単位で比較する多くの同種ツールよりも正確なマージを行うことができる。同社の主席ソフトウェア技術者であるPablo Santos Luaces氏に話を聞いた。</p> 
 <p><b>InfoQ</b>: セマンティックマージに注目するようになった，そもそものきっかけは何だったのでしょうか？</p> 
 <blockquote> 
  <p><b>Pablo</b>: かなり以前のことですので，本当に長い話になります。</p> 
  <p>実は私たちには，&quot;優れたブランチは優れたマージから&quot; という信念があるのです(笑)。 要するに &quot;タスクごとのブランチ&quot; (http://codicesoftware.blogspot.com/2010/08/branch-per-task-workflow-explained.html) という考え方を強く支持している，ということなのですが，そうすると結果的にたくさんのブランチができてしまいます。ですから常々，もっとよいマージ機構がないものかと思っていました。</p> 
  <p>DVCSは開発になくてはならない存在ですが，使用しているマージアルゴリズムは未だにテキストベースです。基本的には15年前に使っていた &quot;マージエンジン&quot; から何も変わっていません。</p> 
  <p>そんな理由から &quot;セマンティックマージ&quot; を考え始めたのです。もちろん簡単なことではありません。ですから最初は &quot;XdiffとXmerge&quot; http://plasticscm.com/features/xmerge.aspx を使って，現在の &quot;テキストベース&quot; diffとマージアルゴリズムを強化することを考えました。これでもそれなりに便利でしたが，私たちはもっとよいものが欲しかったのです。セマンティックマージがいつも目標でした。</p> 
  <p>その後は &quot;リファクタリングのサポート&quot; 強化を目指して，ファイルやディレクトリのマージ方法の改良に努力してきました。そして Plastic SCMのコア機能に追加したのです: http://plasticscm.com/mergemachine/index.html</p> 
  <p>必要なパーツがすべて揃ったので (2012年中頃のことです)，いよいよセマンティックマージに取りかかりました。それまでのテキストベースの古いファイルマージは捨てて，ソースコードの解析を行って，テキスト行ではなくネームスペースやクラス，メソッドなどを処理するようにしたのです。</p> 
  <p>経緯としては，ざっとこんな感じですね。</p> 
  <p>次のような啓示があったのです: ”現在のマージ技術のことはすべて忘れなさい – 開発者として，あなたがマージ処理に望むことは何ですか？ どのように動作してほしいですか？&quot; 答は： &quot;マージ処理はコードを理解すべきである&quot;，それがすべての始まりなのです。</p> 
 </blockquote> 
 <p><b>InfoQ</b>: &quot;マージごとにブランチ&quot;という信条について，もう少し説明していただけますか？</p> 
 <blockquote> 
  <p><b>Pablo</b>: タスクごとにブランチ(Branch per Task) というのはよく知られたブランチパターンです。これはイシュートラッカ上のタスク単位で作業用のブランチを作る，というアイデアに基づいています。</p> 
  <p>そうすると，イシュートラッカのエントリはひとつの変更，ひとつの新機能ごとに作られますから (新規タスク，バグ，パフォーマンス上の問題など何であれ)，それぞれにブランチが作られることになります。</p> 
  <p>メリットとしては：</p> 
  <p>* メインライン(トランク)だけで行うような(全員が同じブランチで作業するような)開発では，バージョン管理は開発者にとって，単なる &quot;ファイル配信の仕組み&quot; に過ぎません。苦痛，ただそれだけです。<br /> * これに対して，自分自身のブランチ(集中管理であれ，分散環境であれ) があれば，バージョン管理は単なる配信のための仕組みから，生産性ツールに変わります。必要な時にチェックインして(チェックインは単に配信ではなく，自分自身のチェックポイントになります)，コードの変更内容を確認できる ... というように，です。<br /> * これまでのCIで最大の問題は &quot;ビルドのブレーク&quot;です。ブレークは作業を逆行させます。ビルドをブレークしたなら，とにかく修正しなくてはなりません。&quot;メインライン” で作業していると，こういったことが起こります。チェックインしたコードが，メインライン上で干渉するのです。タスクごとにブランチを使用すれば，このようなことにはなりません。<br /> * ブランチを多用するとマージの必要も多くなる，というのは事実ではありません。並行的に作業すれば，確かにマージの機会は増えます。ですが，同じブランチで作業したとしても，同じファイルを同時に修正するかも知れません ... その場合は，やはりマージが必要になります。<br /> * タスクは分離するに越したことはありません。私たちが考えるよりも，タスク同士は独立性が高いものなのです。タスクごとにブランチすれば，リリースサイクルは柔軟になると同時に，管理もしやすくなります。<br /> * マージフェーズの間に，安定したベースライン期間を設ける (１日に１回マージする，というようなことです。タスク単位でブランチするというのは，１ヶ月に１回マージすればよいというような意味ではありません!) ことも，タスクごとにブランチを用意すればごく自然に行うことができます。</p> 
  <p>この話の全体は，以下の場所で読むことができます： <a target="_blank" href="http://www.plasticscm.com/infocenter/quick-start/intro-task-driven-development.aspx">http://www.plasticscm.com/infocenter/quick-start/intro-task-driven-development.aspx</a></p> 
 </blockquote> 
 <p><b>InfoQ</b>: 最初にサポートする言語として，なぜC#を選択したのでしょう？</p> 
 <blockquote> 
  <p><b>Pablo</b>: 理由はいくつかあります。順不同でご説明しましょう。</p> 
  <p>1) 私たちが .NET屋だから! :-) 毎日C#コードを書いていますし，自分たちでツールを試してみるのが一番だと思ったのです :-)</p> 
  <p>2) C#はもっともユーザの多い言語のひとつだから。StackOverflowサイトを見てください，一番人気のタグはC#です！(http://stackoverflow.com/tags) TIOBEインデックスではトップ５です (http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)。 PYPLでは３位上昇中です ... (https://sites.google.com/site/pydatalog/pypl/PyPL-PopularitY-of-Programming-Language) ですから，広く普及した言語であることは間違いありません。</p> 
  <p>3) C#(とJava)はセマンティックマージの概念を導入するのに好都合な言語です。C++より扱いやすい (技術的に見れば) ので，ごく初期の段階から，セマンティックマージ技術に集中することができました。他の言語では，こうは行かないでしょう。</p> 
  <p>おもな理由としては，こんな感じですね。</p> 
 </blockquote> 
 <p><b>InfoQ</b>: 今後，他の言語やファイル形式をサポートする予定はありますか？</p> 
 <blockquote> 
  <p><b>Pablo</b>: 目標としてはVB.NETサポートのリリース，次にJava，それからCとC++に進みたいと思っています。その後はアーリーアダプタを対象に <a target="_blank" href="http://plasticscm.uservoice.com/forums/196398-mergebegins">調査</a> を行って，次に必要なものを見つけるつもりです。</p> 
 </blockquote> 
 <p><b>InfoQ</b>: ほとんどのマージツールは，ファイルを行単位で &quot;見て&quot; います。この製品はどうなのでしょう？関数，ステートメント，あるいはブロックなのでしょうか？ステートメント中の式ですか？</p> 
 <blockquote> 
  <p><b>Pablo</b>: semanticmergeでは，ソースファイルをツリー形式で認識しています - ネームスペース，クラス，その中のメソッド ... といった具合です。基本的には構造として捉えているのです。ツールでは &quot;メソッド内のコード&quot; は見ていません。メソッド，プロパティ，あるいはフィールドのレベルです。メソッドあるいはプロパティ本体のマージは，テキストベースの方法で実行しています。例えば &quot;ifステートメント&quot; を &quot;セマンティック&quot; にマージするようなことはしていません。今のところ，ですが ;-)</p> 
  <p>３ウェイマージをメソッドベースのマージにするようなことも，もちろん可能です。最初にメソッドの &quot;先祖&quot; と２つの継承を見つけ出してしまえば，その後の処理は，テキストベースのマージでメソッドボディを扱うようなシンプルなものになります。</p> 
 </blockquote> 
 <p><b>InfoQ</b>: 開発者は折に触れて，ファイル内を &quot;クリーンアップ&quot; するツールを実行します。プロパティからメソッド，その後でアルファベット順，というように，ソートを行うのです。言うまでもありませんが，行ベースのマージツールではそう簡単には成果を上げられません。 このようなシナリオもサポートされているのでしょうか？</p> 
 <blockquote> 
  <p><b>Pablo</b>: まさに私好みのケースですね！セマンティックマージツールなら，このようなシナリオでもきれいに対処できます。事実として，要素の位置による影響は受けません。場所に関係なく，メソッドが同じメソッドであることを理解できるのです :-)。これによってリファクタリング機能も大幅に向上しています。ファイルを可能な限り読みやすいものにしても，それを防ぐ人はいません。</p> 
 </blockquote> 
 <p>今回のクローズドベータについては，<a target="_blank" href="http://www.plasticscm.com/sm/index.html">http://www.plasticscm.com/sm/index.html</a> で確認することができる。</p> 
 <p id="lastElm">&nbsp;</p> 
</div> 
<p id="lastElm"></p><br><br><br><br><br><br></body></html>