<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>序列化 .NET中的不可变集合</h3><p>.NET不可变集合的序列化问题现在非常糟糕。如果你使用DataMember属性标记一个ImmutableList&lt;T&gt;类型的属性，那么标准的反序列化器好像会忽略它。没有运行时错误，但是数据就是不存在。</p>
<p>你可以将属性改为IList类型从而防止数据丢失，但是这会导致一个语义问题。尽管你可以将一个不可变列表存储到一个IList中，但是这种做法令人难以接受，因为大多数人心里面都认为一个给定的IList不会是只读的。另外，类型检查器不能在编译时捕获这种错误。</p>
<p>为了解决语义错误，用户认为可以提供一个IReadOnlyList类型的属性替代。不幸的是，这样做会在序列化期间抛出一个异常，除非添加了KnownType属性。但是一旦添加了该属性在对其序列化时就又会产生无声的错误。</p>
<p>同样地，传统的序列化机制（使用Serializable属性）也不支持。Immo Landwerth写道：</p>
<blockquote> 
 <p>是的。首先，我们使用的可移植子集（portable subset）不支持二进制序列化（<a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3701316-make-the-new-immutable-collection-types-serializab">visualstudio.uservoice.com/.../3701316-make-the-new-immutable-collection-types-serializab</a>）。其次，我们喜欢一个能够在核心数据结构之外实现序列化的模型，因为这样在客户端/服务器场景下使用的时候就可以更加有弹性地实现变化、解决跨版本序列化问题。流行的序列化类库已经计划为不可变集合增加支持，例如JSON.NET、protobuf-net。</p> 
</blockquote>
<p>这样我们可以选择第三方类库，例如JSON.NET。截至版本5.0r7，<a href="http://james.newtonking.com/archive/2013/10/14/json-net-5-0-release-7-immutable-collections">JSON.NET已经支持.NET官方的不可变集合类库</a>。该版本中的新内容还包括JsonExtensionData，它会将一个被反序列化类中的所有没有属性表示的附加数据存储起来。</p>
<p>Marc Gravell还宣称<a href="http://marcgravell.blogspot.com/2013/09/fun-with-immutable-collections.html">protobuf-net将会支持不可变集合</a>，</p>
<blockquote> 
 <p><a href="http://code.google.com/p/protobuf-net/">protobuf-net</a>（r666）的主干现在已经支持不可变列表（List）、数组（Array）、字典（Dictionary）、哈希集合（Hash-Set）、排序集合（Sorted-Set）、排序字典（Sorted-Dictionary），同时它们的所有接口都有双份。但是所有内容都在一个单例模式识别块中。</p> 
</blockquote>
<p><b>查看英文原文</b>：<a href="http://www.infoq.com/news/2013/11/Serialization-Immutable">Serializing Immutable Collections in .NET</a></p><br><br><br><br><br><br></body></html>