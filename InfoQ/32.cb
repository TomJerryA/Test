<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Java Garbage Collection Essencial</h3><p>Serial, Parallel, Concurrent, CMS, G1, Young Gen, New Gen, Old Gen, Perm Gen, Eden, Tenured, Survivor Spaces, Safepoints e as centenas de flags de inicializa&ccedil;&atilde;o da JVM. Deixam tudo confuso quando se est&aacute; tentando otimizar o garbage collector para obter a taxa de transfer&ecirc;ncia e lat&ecirc;ncia necess&aacute;ria para a aplica&ccedil;&atilde;o Java? A documenta&ccedil;&atilde;o sobre a coleta de lixo parece um manual para aeronaves. Cada bot&atilde;o e seletor est&aacute; explicado detalhadamente, mas em nenhum lugar &eacute; poss&iacute;vel encontrar um guia sobre como voar. Este artigo vai tentar explicar as vantagens e desvantagens na escolha e ajuste dos algoritmos do garbage collector em uma determinada carga de trabalho.</p>
<p>O foco ser&aacute; nos coletores da Oracle Hotspot JVM e do OpenJDK que s&atilde;o de uso mais comum. No final, outras JVMs comerciais ser&atilde;o discutidas para mostrar alternativas.</p>
<p><strong>Vantagens e desvantagens</strong></p>
<p>O s&aacute;bio povo continua nos dizendo: &quot;n&atilde;o se consegue nada de gra&ccedil;a&quot;. Quando queremos algo geralmente temos que abrir m&atilde;o de algo em troca. Quando se trata da coleta de lixo trabalhamos com 3 principais vari&aacute;veis que definem metas para os coletores:</p>
<ol start="1"> 
 <li>Taxa de transfer&ecirc;ncia: O total de trabalho realizado por uma aplica&ccedil;&atilde;o como uma propor&ccedil;&atilde;o do tempo gasto no GC. Configurando a taxa de transfer&ecirc;ncia para <strong>‑XX:GCTimeRatio=99,</strong> 99 &eacute; o padr&atilde;o que equivale a 1% do tempo do GC.</li> 
 <li>Lat&ecirc;ncia: O tempo gasto pelos sistemas em resposta a eventos que s&atilde;o afetados por pausas introduzidas atrav&eacute;s da coleta de lixo. Configure a lat&ecirc;ncia para pausas do GC com <strong>-XX: MaxGCPauseMillis = &lt;n&gt;.</strong></li> 
 <li>Mem&oacute;ria: A quantidade de mem&oacute;ria que nossos sistemas usam para guardar o estado, que &eacute; frequentemente copiado e movido quando est&atilde;o sendo geridos. O conjunto de objetos ativos mantidos pela aplica&ccedil;&atilde;o em qualquer tempo &eacute; conhecido como Live Set. Tamanho m&aacute;ximo da heap (Maximum heap size) <strong>-Xmx&lt;n&gt;</strong> &eacute; um par&acirc;metro de ajuste para configurar o heap size dispon&iacute;vel para uma aplica&ccedil;&atilde;o.</li> 
</ol>
<p>Observa&ccedil;&atilde;o: Muitas vezes o Hotspot n&atilde;o pode alcan&ccedil;ar essas metas e vai silenciosamente continuar sem nenhum aviso, mesmo ap&oacute;s ter falhado por uma grande margem.</p>
<p>Lat&ecirc;ncia &eacute; a distribui&ccedil;&atilde;o entre eventos. Pode ser aceit&aacute;vel ter um aumento m&eacute;dio de lat&ecirc;ncia para reduzir o pior caso de lat&ecirc;ncia, ou torn&aacute;-los menos frequentes. N&atilde;o devemos interpretar o termo &quot;real-time&quot; como menor lat&ecirc;ncia poss&iacute;vel; mas sim que se refere a ter uma lat&ecirc;ncia determin&iacute;stica, independentemente da taxa de transfer&ecirc;ncia.</p>
<div id="lowerFullwidthVCR"></div>
<p>Para cargas de trabalho de algumas aplica&ccedil;&otilde;es, a taxa de transfer&ecirc;ncia &eacute; a meta mais importante. Um exemplo seria um processamento em lote de longa dura&ccedil;&atilde;o, n&atilde;o importa se o processamento em lote &eacute; ocasionalmente interrompido por alguns segundos enquanto a coleta de lixo &eacute; executada, desde que o processamento em lote possa ser conclu&iacute;do logo.</p>
<p>Para praticamente todas as outras cargas de trabalho, desde aplica&ccedil;&otilde;es interativas com humanos a sistemas de com&eacute;rcio financeiro, se um sistema n&atilde;o responder ap&oacute;s alguns segundos ou milissegundos, isso pode significar um desastre. Em neg&oacute;cios financeiros frequentemente vale a pena negociar alguma taxa de transfer&ecirc;ncia em troca de lat&ecirc;ncia consistente. Podemos tamb&eacute;m ter aplica&ccedil;&otilde;es que s&atilde;o limitadas pela quantidade de mem&oacute;ria f&iacute;sica dispon&iacute;vel e ter que se manter presente, neste caso temos que melhorar o desempenho em ambos, lat&ecirc;ncia e taxa de transfer&ecirc;ncia.</p>
<p>A seguir algumas vantagens e desvantagens:</p>
<ul> 
 <li>Em grande parte o custo da coleta de lixo, como um custo amortizado, pode ser reduzido fornecendo ao garbage collector algoritmos com mais mem&oacute;ria.</li> 
 <li>Os piores casos observados de pausas induzidas por lat&ecirc;ncia devido &agrave; coleta de lixo podem ser reduzidos limitando o live set e mantendo a heap pequena.</li> 
 <li>A frequ&ecirc;ncia com que as pausas ocorrem pode ser reduzida pelo gerenciamento da heap e o tamanho das gera&ccedil;&otilde;es, e controlando a taxa de aloca&ccedil;&atilde;o de objetos.</li> 
 <li>A grande frequ&ecirc;ncia de pausas pode ser reduzida pela execu&ccedil;&atilde;o do GC concorrentemente com a aplica&ccedil;&atilde;o, &agrave;s vezes &agrave; custa da taxa de transfer&ecirc;ncia.</li> 
</ul>
<p><strong>Ciclo de vida dos Objetos</strong></p>
<p>Os algoritmos de coleta de lixo s&atilde;o frequentemente otimizados na expectativa de que a maioria dos objetos viva por um curto per&iacute;odo de tempo, enquanto que relativamente poucos vivem por muito tempo. Na maioria das aplica&ccedil;&otilde;es, os objetos que vivem por um per&iacute;odo significativo de tempo tendem a constituir uma porcentagem muito pequena dos objetos alocados ao longo do tempo. Na teoria, esse comportamento observado na coleta de lixo &eacute; conhecido como &quot;mortalidade infantil&quot; ou &quot;hip&oacute;tese geracional fraca&quot;. Por exemplo, loops em Iterators s&atilde;o em sua maioria de curta dura&ccedil;&atilde;o enquanto que Strings s&atilde;o efetivamente imortais.</p>
<p>A experi&ecirc;ncia tem demonstrado que os garbage collectors geracionais normalmente podem suportar uma taxa de transfer&ecirc;ncia maior que os collectors n&atilde;o geracionais, portanto s&atilde;o quase sempre usados em servidores JVMs. Pela separa&ccedil;&atilde;o das gera&ccedil;&otilde;es de objetos, sabemos que a regi&atilde;o na qual os novos objetos s&atilde;o alocados &eacute; provavelmente muito escassa para objetos vivos. Portanto, um collector que varre procurando por objetos vivos nessa regi&atilde;o e os copia para outra regi&atilde;o de objetos mais velhos pode ser muito eficiente. Os coletores de lixo do Hotspot gravam a idade de um objeto de acordo com o n&uacute;mero de ciclos do GC que sobreviveu.</p>
<p>Observa&ccedil;&atilde;o: Se uma aplica&ccedil;&atilde;o sempre gera um monte de objetos que vivem por um tempo bastante longo, ent&atilde;o &eacute; de se esperar que essa aplica&ccedil;&atilde;o gaste uma por&ccedil;&atilde;o significativa deste tempo com a coleta de lixo, assim como tenha que se gastar um tempo significativo ajustando o coletor de lixo do Hotspot. Isto &eacute; devido &agrave; redu&ccedil;&atilde;o da efici&ecirc;ncia do GC que acontece quando o &quot;filtro&quot; geracional &eacute; menos efetivo, e ao custo resultante de coletar gera&ccedil;&otilde;es vivas h&aacute; mais tempo com uma maior frequ&ecirc;ncia. Gera&ccedil;&otilde;es mais velhas s&atilde;o menos escassas e, como resultado, a efici&ecirc;ncia dos algoritmos de coleta das gera&ccedil;&otilde;es mais velhas tendem a ser bem ruim. Os Garbage Collectors geracionais tendem a operar em dois ciclos de coletas distintos: as coletas Menores (Minor collections), em que os objetos de curta dura&ccedil;&atilde;o s&atilde;o coletados, e as menos frequentes coletas Maiores (Major collections), em que as regi&otilde;es mais velhas s&atilde;o coletadas.</p>
<p><strong>Eventos do tipo Para-O-Mundo (Stop-The-World)</strong></p>
<p>As pausas sofridas pelas aplica&ccedil;&otilde;es durante a coleta de lixo s&atilde;o devidas aos, como s&atilde;o conhecidos, &quot;eventos do tipo stop-the-world&quot;. Por raz&otilde;es pr&aacute;ticas de engenharia, para que o garbage collector opere, &eacute; necess&aacute;rio parar a aplica&ccedil;&atilde;o em execu&ccedil;&atilde;o periodicamente para que a mem&oacute;ria possa ser gerenciada. Dependendo dos algoritmos, diferentes coletores disparar&atilde;o o evento stop-the-world em espec&iacute;ficos pontos da execu&ccedil;&atilde;o, variando o tempo da parada. Para fazer uma aplica&ccedil;&atilde;o parar totalmente &eacute; necess&aacute;rio pausar todas as threads em execu&ccedil;&atilde;o. Os garbage collectors fazem isso avisando as threads para parar quando elas estiverem em um &quot;ponto seguro&quot;, que &eacute; o ponto durante a execu&ccedil;&atilde;o do programa no qual &eacute; conhecido por todos os GC e todos os objetos na heap est&atilde;o consistentes. Dependendo do que a thread estiver executando, pode demorar algum tempo at&eacute; ela alcan&ccedil;ar um ponto seguro. Pontos seguros s&atilde;o normalmente estabelecidos nos retornos de m&eacute;todo e nos finais dos loops, mas podem ser otimizados para alguns pontos diferentes, tornando-os dinamicamente mais raros. Por exemplo, se uma Thread est&aacute; copiando um grande array, clonando um objeto grande, ou executando um loop, pode demorar muitos milissegundos antes de um ponto seguro ser atingido. O tempo para atingir um ponto seguro &eacute; uma preocupa&ccedil;&atilde;o importante em aplica&ccedil;&otilde;es com baixa lat&ecirc;ncia. Este tempo pode ser visualizado habilitando a flag <strong>‑XX:+PrintGCApplicationStoppedTime</strong> junto com as outras flags do GC.</p>
<p>Observa&ccedil;&atilde;o: Para aplica&ccedil;&otilde;es com um n&uacute;mero grande de threads em execu&ccedil;&atilde;o, quando um evento stop-the world ocorre, o sistema sofrer&aacute; uma press&atilde;o enorme assim que as threads estiverem liberadas dos pontos seguros. Por isso que algoritmos meno sependentes de eventos stop-the-world s&atilde;o potencialmente mais eficientes.</p>
<p><strong>Organiza&ccedil;&atilde;o da Heap no Hotspot</strong></p>
<p>Para entender como os diferentes coletores funcionam &eacute; melhor explorar como a Heap &eacute; organizada para suportar os coletores geracionais.</p>
<p>O <i>Eden</i> &eacute; a regi&atilde;o na qual a maioria dos objetos s&atilde;o inicialmente alocados. Os objetos que sobreviveram a uma coleta no Eden s&atilde;o temporariamente armazenados nos <i>survivor spaces.</i> O uso do Survivor ser&aacute; descrito quando as coletas menores forem discutidas. O <i>Eden</i> e o <i>Survivor</i> s&atilde;o espa&ccedil;os conhecidos como gera&ccedil;&atilde;o &quot;young&quot; e &quot;new&quot;, respectivamente.</p>
<p>Os objetos que vivem durante um tempo longo o suficiente s&atilde;o eventualmente promovidos para a <i>tenured space</i>.</p>
<p>A <i>perm gen</i> &eacute; o lugar em que a Runtime (JVM) armazena os objetos &quot;conhecidos&quot; por serem efetivamente imortais, tais como Classes e Strings est&aacute;ticas. Infelizmente o uso comum do carregamento de classes de forma cont&iacute;nua em muitas aplica&ccedil;&otilde;es motiva a equivocada suposi&ccedil;&atilde;o de que por tr&aacute;s da <i>perm gen</i> as classes s&atilde;o imortais. No Java 7 as Strings internas foram movidas da <i>perm gen</i> para a<i> tenured</i>, e a partir do Java 8 a <i>perm gen</i> n&atilde;o existir&aacute; mais, e n&atilde;o ser&aacute; abordada neste artigo. A maioria dos coletores comerciais n&atilde;o usa uma <i>perm gen</i> separada e tende a tratar todos os objetos de longa dura&ccedil;&atilde;o na <i>tenured</i>.</p>
<p>Observa&ccedil;&atilde;o: As &aacute;reas virtuais permitem que os coletores ajustem o tamanho das regi&otilde;es para cumprir as metas de taxa de transfer&ecirc;ncia e lat&ecirc;ncia. Os coletores mant&ecirc;m estat&iacute;sticas para cada fase da coleta e ajustam o tamanho da regi&atilde;o na tentativa de cumprir as metas.</p>
<p><strong>Aloca&ccedil;&atilde;o de Objetos</strong></p>
<p>Para evitar disputas, cada thread &eacute; atribu&iacute;da a um buffer de aloca&ccedil;&atilde;o de thread local (Thread Local Allocation Buffer - TLAB) no qual os objetos s&atilde;o alocados. O uso de TLABs permite que a aloca&ccedil;&atilde;o de objetos possa escalar de acordo com n&uacute;mero de threads, evitando disputas de um &uacute;nico recurso na mem&oacute;ria. A aloca&ccedil;&atilde;o de objetos via TLAB &eacute; uma opera&ccedil;&atilde;o muito barata, a TLAB simplesmente aponta o ponteiro para o tamanho do objeto que leva cerca de 10 instru&ccedil;&otilde;es na maioria das plataformas. A aloca&ccedil;&atilde;o da pilha de mem&oacute;ria para o Java &eacute; ainda mais barato do que usar o malloc do runtime existente no C.</p>
<p class="image-wide"><img src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/pt/resources/Figure1.jpg" alt="" _href="img://Figure1.jpg" _p="true" /></p>
<p>Observa&ccedil;&atilde;o: Visto que a aloca&ccedil;&atilde;o individual de objetos &eacute; muito barata, a taxa &agrave; qual coletas menores devem ocorrer &eacute; diretamente proporcional &agrave; taxa de aloca&ccedil;&atilde;o do objeto.</p>
<p>Quando uma TLAB est&aacute; exausta uma thread simplesmente socilita uma nova para o <i>Eden</i>. Quando o <i>Eden</i> est&aacute; cheio uma coleta menor &eacute; iniciada.</p>
<p>Pode acontecer de n&atilde;o ser poss&iacute;vel alocar grandes objetos (-XX:PretenureSizeThreshold=n) na <i>young gen</i> e assim eles ter&atilde;o de ser alocados na<i> old gen</i>, por exemplo um grande array. Se o limite configurado &eacute; menor que o tamanho do TLAB, ent&atilde;o os objetos que couberem no TLAB n&atilde;o ser&atilde;o criados na <i>old gen</i>. O novo coletor G1 manipula grandes objetos diferentemente e o mesmo ser&aacute; discutido mais adiante.</p>
<p><strong>Coletas</strong><strong> menores</strong></p>
<p>Uma coleta menor &eacute; disparada quando o Eden fica cheio. Todo os objetos vivos na <i>new generation</i> s&atilde;o copiados para o <i>survivor</i> <i>space</i> ou o <i>tenured</i> space, conforme a necessidade.</p>
<p>A c&oacute;pia para o <i>tenured</i> <i>space</i> &eacute; conhecida como uma promo&ccedil;&atilde;o ou amadurecimento. Promo&ccedil;&otilde;es ocorrem para objetos que s&atilde;o suficientemente velhos (-- <strong>XX:maxTenuringThreshold</strong>), ou quando o <i>survivor space</i> estoura.</p>
<p>Objetos vivos s&atilde;o objetos que podem ser acessados pela aplica&ccedil;&atilde;o, quaisquer outros objetos que n&atilde;o possam ser acessados podem portanto ser considerados mortos. Em uma coleta menor, a c&oacute;pia dos objetos vivos &eacute; feita primeiramente pelo que &eacute; conhecido como GC Roots, e de forma iterativa copia qualquer objeto acess&iacute;vel para o <i>survivor space.</i> GC Roots normalmente incluem refer&ecirc;ncias da aplica&ccedil;&atilde;o e campos est&aacute;ticos internos da JVM, e pilhas de threads, tudo o que efetivamente aponta para gr&aacute;ficos de objetos acess&iacute;veis da aplica&ccedil;&atilde;o.</p>
<p>Em coletas geracionais, os GC Roots para os gr&aacute;ficos de objetos alcan&ccedil;&aacute;veis da <i>new gen</i> tamb&eacute;m incluem qualquer refer&ecirc;ncia da <i>old gen</i> para a <i>new gen</i>. Estas refer&ecirc;ncias devem tamb&eacute;m ser processadas para garantir que todos objetos alcan&ccedil;&aacute;veis na <i>new gen</i> sobrevivem a coleta menor. Identificar essas refer&ecirc;ncias entre gera&ccedil;&otilde;es &eacute; poss&iacute;vel atrav&eacute;s do uso de um &quot;cart&atilde;o de mesa&quot;.</p>
<p>O cart&atilde;o de mesa do Hotspot &eacute; um array de bytes no qual cada byte &eacute; usado para marcar a potencial exist&ecirc;ncia de refer&ecirc;ncias entre gera&ccedil;&otilde;es em uma regi&atilde;o correspondente a 512 bytes da <i>old gen</i>. As refer&ecirc;ncias s&atilde;o armazenadas na heap, a &quot;barreira de armazenamento&quot; de c&oacute;digo marcar&aacute; os cart&otilde;es para indicar que uma potencial refer&ecirc;ncia da <i>old gen</i> para a <i>new gen</i> possa existir na regi&atilde;o 512 byte associada. No momento da coleta, o cart&atilde;o de mesa &eacute; usado para procurar por refer&ecirc;ncias entre gera&ccedil;&otilde;es, que efetivamente representam GC Roots adicionais para a <i>new gen</i>. Entretanto um custo fixo significativo nas coletas menores &eacute; diretamente proporcional ao tamanho da <i>old gen</i>.</p>
<p>Existem duas survivor spaces na <i>new gen</i> da Hotspot, que se alternam em suas regras em seus &quot;<i>espa&ccedil;o destino</i>&quot; e &quot;<i>espa&ccedil;o origem</i>&quot;. No in&iacute;cio de uma coleta menor, o &quot;<i>espa&ccedil;o destino</i>&quot; <i>survivor</i> space &eacute; sempre vazio, e atua como uma &aacute;rea de c&oacute;pia para a coleta menor. O survivor space da coleta <i>menor</i> anterior &eacute; parte do &quot;espa&ccedil;o origem&quot;, que tamb&eacute;m inclui o <i>Eden</i>, local que os objetos vivos que precisam ser copiados podem ser encontrados.</p>
<p>O custo de um GC de coleta menor &eacute; geralmente dominado pelo custo da c&oacute;pia de objetos para os <i>survivor spaces</i> e <i>tenured spaces</i>. Objetos que n&atilde;o sobrevivem a coleta menor est&atilde;o efetivamente livres para serem tratados. O trabalho realizado durante a coleta menor &eacute; diretamente proporcional ao n&uacute;mero de objetos vivos encontrados, e n&atilde;o ao tamanho da <i>new gen</i>. O tempo total gasto executando a coleta menor pode ser praticamente reduzida a metade cada vez que o tamanho do <i>Eden</i> &eacute; dobrado. A mem&oacute;ria portanto pode ser trocada por taxa de transfer&ecirc;ncia. A duplica&ccedil;&atilde;o do tamanho <i>Eden</i> resultar&aacute; no aumento do tempo de coleta por ciclo, mas isso &eacute; relativamente pequeno se tanto o n&uacute;mero de objetos a serem promovidos como o tamanho de gera&ccedil;&atilde;o mais velha &eacute; constante.</p>
<p>Observa&ccedil;&atilde;o: Na Hotspot as coletas menores s&atilde;o eventos stop-the-world. Isso est&aacute; rapidamente se tornando uma quest&atilde;o importante conforme nossas heaps ficam maiores com mais objetos vivos. J&aacute; vemos a necessidade de coletas concorrentes da <i>young gen</i> para atingirmos as metas de pausa de tempo.</p>
<p><strong>Coletas maiores</strong></p>
<p>Coletas maiores ocorrem na <i>old gen</i> para que os objetos possam ser promovidos da <i>young gen</i>. Na maioria das aplica&ccedil;&otilde;es, na grande maioria os estados dos programas terminam na <i>old gen</i>. H&aacute; uma grande variedade de algoritmos existentes para a <i>old gen</i>. Alguns v&atilde;o compactar todo o espa&ccedil;o quando encher, enquanto outros v&atilde;o coletar concorrentemente com a aplica&ccedil;&atilde;o para tentar impedi-lo de encher.</p>
<p>O coletor da <i>old gen</i> vai tentar adivinhar quando &eacute; necess&aacute;rio coletar para evitar um fracasso na promo&ccedil;&atilde;o da <i>young gen</i>. Os coletores monitoram um limite de preenchimento para a <i>old gen</i> e come&ccedil;am a coletar quando este limite &eacute; ultrapassado. Se este limite n&atilde;o &eacute; suficiente para atender as necessidades de promo&ccedil;&atilde;o, ent&atilde;o um &quot;FullGC&quot; &eacute; acionado. O FullGC envolve a promo&ccedil;&atilde;o de todos os objetos vivos da <i>new gen</i> seguidas por uma coleta e compacta&ccedil;&atilde;o da <i>old gen</i>. A falha de promo&ccedil;&atilde;o &eacute; uma opera&ccedil;&atilde;o muito cara e os objetos promovidos a partir deste ciclo deve ser desfeitos para que o evento FullGC possa ocorrer.</p>
<p>Observa&ccedil;&atilde;o: Para evitar a falha na promo&ccedil;&atilde;o ser&aacute; necess&aacute;rio ajustar o preenchimento que a <i>old gen</i> permite para acomodar promo&ccedil;&otilde;es (‑XX:PromotedPadding=&lt;n&gt;).</p>
<p>Observa&ccedil;&atilde;o: Quando a Heap precisa aumentar um FullGC &eacute; acionado. Esse redimensionamento da Heap por FullGCs podem ser evitado ajustando <strong>-Xms</strong> e <strong>-Xmx</strong> para o mesmo valor.</p>
<p>Al&eacute;m do FullFC, uma compacta&ccedil;&atilde;o da <i>old gen</i> &eacute; prov&aacute;velmente o maior evento stop-the-world que uma aplica&ccedil;&atilde;o vai experimentar. O tempo para esta compacta&ccedil;&atilde;o tende a crescer linearmente com o n&uacute;mero de objetos vivos no <i>tenured space</i>.</p>
<p>A taxa &agrave; qual a <i>tenured space</i> se enche por vezes pode ser reduzido incrementando o tamanho do <i>survivor space</i> e a idade dos objetos antes de serem promovidos para a <i>tenured gen.</i> Entretanto, aumentando o tamanho do <i>survivor space</i> e a idade dos objetos nas coletas menores (-XX:MaxTenuringThreshold) antes da promo&ccedil;&atilde;o tamb&eacute;m pode aumentar os custos e tempos de pausa nas coletas menores devido ao aumento do custo de c&oacute;pia entre os survivor space em cole&ccedil;&otilde;es menores.</p>
<p><strong>Coleta em s&eacute;rie</strong></p>
<p>A coleta em s&eacute;rie (-XX:+UseSerialGC) &eacute; o coletor mais simples e uma boa op&ccedil;&atilde;o para sistemas com um &uacute;nico processador. Ele tamb&eacute;m tem o menor tamanho de qualquer coletor. Ele usa uma &uacute;nica thread para a coleta <i>menor</i> e <i>maior</i>. Os objetos s&atilde;o alocados no <i>tenured space</i> usando um simples algoritmo de colis&atilde;o de ponteiros. Coletas maiores s&atilde;o acionadas quando o <i>tenured space</i> est&aacute; cheio.</p>
<p><strong>Coletor paralelo</strong></p>
<p>O coletor Paralelo vem em duas formas. O Coletor Paralelo (‑XX:+UseParallelGC) que usa m&uacute;ltiplas threads para executar cole&ccedil;&otilde;es menores da <i>young gen</i> e uma &uacute;nica thread para coletas maiores na <i>old gen</i>. O Coletor Paralelo Antigo (‑XX:+UseParallelOldGC), o padr&atilde;o desde o Java 7u4, usa m&uacute;ltiplas threads para coletas menores e m&uacute;ltiplas threads para coletas maiores. Os objetos s&atilde;o alocados no <i>tenured space</i> usando um simples algoritmo de colis&atilde;o de ponteiros. Coletas maiores s&atilde;o acionadas quando o espa&ccedil;o <i>tenured</i> est&aacute; cheio.</p>
<p>Em sistemas com muitos processadores o Coletor Paralelo Antigo vai dar melhor vaz&atilde;o que qualquer coletor. Ele n&atilde;o impacta em uma aplica&ccedil;&atilde;o em execu&ccedil;&atilde;o at&eacute; a coleta acontecer, e ent&atilde;o vai coletar em paralelo usando m&uacute;ltiplas threads usando um algoritmo mais eficiente. Isso faz o Coletor Paralelo Antigo muito eficiente para aplica&ccedil;&atilde;o em batch.</p>
<p>O custo de coletar as gera&ccedil;&otilde;es <i>old</i> &eacute; afetado pelo n&uacute;mero de objetos mantendo uma maior extens&atilde;o do que o tamanho da heap. Portanto a efici&ecirc;ncia do Coletor Paralelo Antigo pode ser aumentada para alcan&ccedil;ar uma maior taxa de transfer&ecirc;ncia, fornecendo mais mem&oacute;ria e aceitando maiores, mas em n&uacute;mero menor, pausas para coleta.</p>
<p>Espere coletas menores mais r&aacute;pidas com este coletor porque a promo&ccedil;&atilde;o para o <i>tenured space</i> &eacute; um simples opera&ccedil;&atilde;o de c&oacute;pia e acerto de ponteiros.</p>
<p>Para servidores de aplica&ccedil;&otilde;es o Coletor Paralelo Old deve ser a porta de entrada. Entretanto se as pausas para coletas maiores s&atilde;o maiores que a aplica&ccedil;&atilde;o pode tolerar ent&atilde;o ser&aacute; preciso considerar empregar um coletor concorrente que colete os objetos na <i>tenured</i> concorrentemente enquanto a aplica&ccedil;&atilde;o est&aacute; em execu&ccedil;&atilde;o.</p>
<p>Observa&ccedil;&atilde;o: Espere pausas em ordem de 1 a 5 segundos por GB de informa&ccedil;&atilde;o viva em m&aacute;quinas modernas enquanto a <i>old gen</i> &eacute; compactada.</p>
<p><strong>Coletor</strong> <strong>Concurrent Mark Sweep (CMS)</strong></p>
<p>O coletor Concurrent Mark Sweep (CMS) (-XX:+UseConcMarkSweepGC) &eacute; executado na <i>old gen</i> coletando objetos maduros que n&atilde;o s&atilde;o mais acess&iacute;veis durante a coleta maior. Ele &eacute; executado concorrentemente na aplica&ccedil;&atilde;o com o objetivo de manter espa&ccedil;o livre o suficiente na <i>old gen</i>, ent&atilde;o falhas de promo&ccedil;&atilde;o na <i>young gen</i> n&atilde;o ocorrem.</p>
<p>A falha de promo&ccedil;&atilde;o ir&aacute; desencadear um FullGC. O CMS segue um processo de v&aacute;rias etapas:</p>
<ol start="1"> 
 <li>Marca&ccedil;&atilde;o inicial &lt;stop-the-world&gt;: Procura GC Roots;</li> 
 <li>Marca&ccedil;&atilde;o concorrente: Marca todos os objetos acess&iacute;veis pelo GC Roots;</li> 
 <li>Pr&eacute;-limpeza concorrente: Verifica refer&ecirc;ncias de objetos que foram atualizadas e objetos que foram promovidos durante a fase de remarca&ccedil;&atilde;o concorrente;</li> 
 <li>Remarca&ccedil;&atilde;o &lt;stop-the-world&gt;: Captura refer&ecirc;ncias de objetos que foram atualizados desde a fase de pr&eacute;-limpeza;</li> 
 <li>Varredura concorrente: Atualiza as listas livre com a recupera&ccedil;&atilde;o da mem&oacute;ria ocupada por objetos mortos;</li> 
 <li>Reinicio concorrente: Reinicia a estrutura de dados para a pr&oacute;xima execu&ccedil;&atilde;o.</li> 
</ol>
<p>Assim que os objetos maduros se tornam inacess&iacute;veis, o espa&ccedil;o &eacute; recuperado pelo CMS e colocado em listas livres. Quando a promo&ccedil;&atilde;o acontece, deve ser pesquisado um local de tamanho adequado para as listas livres para o objeto promovido. Isso aumenta o custo da promo&ccedil;&atilde;o e assim aumenta o custo da coleta menor comparado ao Coletor Paralelo.</p>
<p>Observa&ccedil;&atilde;o: O CMS n&atilde;o &eacute; um coletor de compacta&ccedil;&atilde;o, o que ao longo do tempo pode resultar na fragmenta&ccedil;&atilde;o da <i>old gen.</i> A promo&ccedil;&atilde;o do objeto pode falhar, pois um objeto grande pode n&atilde;o caber nos locais dispon&iacute;veis na <i>old gen</i>. Quando isso acontece uma mensagem &quot;promo&ccedil;&atilde;o falha&quot; &eacute; registrada e um FullGC &eacute; acionado para compactar os objetos maduros vivos. Para tais compacta&ccedil;&otilde;es orientadas ao FullGCs, espere pausas piores que das coletas maiores usando o Coletor Paralelo Antigo porque CMS usa uma simples thread para a compacta&ccedil;&atilde;o.</p>
<p>O CMS &eacute; na maior parte concorrente com a aplica&ccedil;&atilde;o, que tem um n&uacute;mero de implica&ccedil;&otilde;es. Primeiro, o tempo da CPU &eacute; consumido pelo coletor, deste modo reduzindo a CPU dispon&iacute;vel para a aplica&ccedil;&atilde;o. O total de tempo requerido pelo CMS aumenta linearmente com o montante de objetos promovidos para o <i>tenured space</i>. Segundo, para algumas fases concorrentes do ciclo do GC, todas as threads tem que ser trazidas para um ponto a salvo para o GC Roots marcar e realizar uma remarca&ccedil;&atilde;o paralela para verificar se h&aacute; muta&ccedil;&otilde;es.</p>
<p>Observa&ccedil;&atilde;o: Se uma aplica&ccedil;&atilde;o percebe muta&ccedil;&otilde;es significantes nos objetos maduros, ent&atilde;o uma fase de remarca&ccedil;&atilde;o pode ser significante, nos extremos pode levar mais tempo do que uma compacta&ccedil;&atilde;o completa com o Coletor Paralelo Antigo.</p>
<p>O CMS faz do FullGC um evento menos frequente &agrave; custa da redu&ccedil;&atilde;o da taxa de transfer&ecirc;ncia, coletas menores s&atilde;o mais caras, e mais marcantes. A redu&ccedil;&atilde;o na taxa de transfer&ecirc;ncia pode ser qualquer coisa entre 10% a 40% em rela&ccedil;&atilde;o ao Coletor Paralelo, dependendo da taxa de promo&ccedil;&atilde;o. O CMS tamb&eacute;m exige 20% mais mem&oacute;ria para acomodar estruturas de dados adicionais e &quot;lixo flutuante&quot; que pode ser perdido durante a marca&ccedil;&atilde;o simult&acirc;nea que ser&aacute; transferida para o pr&oacute;ximo ciclo.</p>
<p>Altas taxas de promo&ccedil;&atilde;o e fragmenta&ccedil;&atilde;o resultante podem &agrave;s vezes ser reduzidas pelo aumento do tamanho de ambos a <i>young gen</i> e <i>old gen</i>.</p>
<p>Observa&ccedil;&atilde;o: O CMS pode sofrer &quot;falhas de modo concorrente&quot;, que pode ser visto nos logs, quando deixa de coletar a uma taxa suficiente para manter-se com a promo&ccedil;&atilde;o. Isso pode ser causado quando a coleta come&ccedil;a tarde, que podem ser definidos por meio de ajuste. Mas isso tamb&eacute;m pode acontecer quando a taxa de coleta n&atilde;o consegue acompanhar a alta taxa de promo&ccedil;&atilde;o ou a alta muta&ccedil;&atilde;o de objetos de algumas aplica&ccedil;&otilde;es. Se o taxa de promo&ccedil;&atilde;o ou muta&ccedil;&atilde;o da aplica&ccedil;&atilde;o &eacute; t&atilde;o alta, ent&atilde;o sua aplica&ccedil;&atilde;o pode necessitar de algumas mudan&ccedil;as para reduzir a press&atilde;o da promo&ccedil;&atilde;o. Adicionando mais mem&oacute;ria para um sistema deste tipo, por vezes, pode piorar a situa&ccedil;&atilde;o, porque o CMS teria mais mem&oacute;ria para examinar.</p>
<p><strong>Coletor Garbage First</strong> <strong>(G1)</strong></p>
<p>O Garbage First (G1) (-XX:+UseG1GC) &eacute; um novo coletor introduzido no Java 6 e agora oficialmente suportado no Java 7. &Eacute; um algoritmo parcialmente concorrente que tamb&eacute;m tenta compactar o <i>tenured space</i> em pequenas e incrementais pausas stop-the-world para tentar minimizar os eventos FullGC que aflige o CMS por causa da fragmenta&ccedil;&atilde;o. G1 &eacute; um coletor geracional que organiza a heap diferentemente dos outros coletores dividindo-o em regi&otilde;es de tamanho fixo de efeito vari&aacute;vel, ao inv&eacute;s de regi&otilde;es cont&iacute;guas com o mesmo objetivo.</p>
<p>O G1 adota a abordagem de concorrentemente marcar regi&otilde;es para rastrear refer&ecirc;ncias entre regi&otilde;es, e concentra a coleta nas regi&otilde;es com mais espa&ccedil;o livre. Estas regi&otilde;es s&atilde;o ent&atilde;o coletadas em uma pausa stop-the-world descarregando os objetos vivos para uma regi&atilde;o vazia, assim compactando no processo. Objetos maiores que 50% da regi&atilde;o s&atilde;o alocados em uma regi&atilde;o monstruosa, que &eacute; um m&uacute;ltiplo do tamanho da regi&atilde;o. A aloca&ccedil;&atilde;o e coleta de objetos monstruosos podem ser muito caros para o G1, e at&eacute; agora teve pouco ou nenhum esfor&ccedil;o de otimiza&ccedil;&atilde;o aplicada.</p>
<p class="image-wide"><img src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/pt/resources/Figure2.jpg" alt="" _href="img://Figure2.jpg" _p="true" /></p>
<p>O desafio com qualquer coletor de compacta&ccedil;&atilde;o n&atilde;o &eacute; o de mover objetos mas o de atualizar as refer&ecirc;ncias destes objetos. Se um objeto &eacute; referenciado em v&aacute;rias regi&otilde;es, ent&atilde;o atualizar estas refer&ecirc;ncias podem demorar significativamente mais do que mover o objeto. O G1 rastreia quais objetos em uma regi&atilde;o tem refer&ecirc;ncias de outras regi&otilde;es via &quot;Remembered Sets&quot; (Conjuntos lembrados). Se um Remembered Set tornar-se grande, ent&atilde;o o G1 pode desacelerar significativamente. Quando liberando objetos de uma regi&atilde;o para outra, o tamanho dos eventos stop-the-world associados tendem a ser proporcionais ao n&uacute;mero de regi&otilde;es com refer&ecirc;ncias que precisam ser escaneadas e potencialmente corrigidas.</p>
<p>Manter os Remembered Sets aumenta o custo das coletas menores resultando pausas maiores do que visto com o Coletor Paralelo Antigo ou o CMS para cole&ccedil;&otilde;es menores.</p>
<p>O G1 &eacute; configurado baseado na lat&ecirc;ncia <strong>-XX:MaxGCPauseMillis=&lt;n&gt;,</strong> valor padr&atilde;o = 200ms. A meta ir&aacute; influenciar a quantidade de trabalho realizado em cada ciclo somente na base nos melhores esfor&ccedil;os. Estabelecer metas em dezenas de milissegundos &eacute; mais f&uacute;til, e da forma como foi escrito, tentar alvejar dezenas de milissegundos n&atilde;o foi o foco do G1.</p>
<p>O G1 &eacute; em geral um bom coletor para grandes pilhas que tem a tend&ecirc;ncia de se tornar fragmentado quando uma aplica&ccedil;&atilde;o pode tolerar pausas entre 0.5 e 1.0 segundo para compacta&ccedil;&otilde;es incrementais. O G1 tende a reduzir a frequ&ecirc;ncia dos piores casos de pausa visto no CMS devido a fragmenta&ccedil;&atilde;o ao custo das coletas menores e compacta&ccedil;&atilde;o incremental da <i>old gen</i>. Mais pausas acabam sendo obrigat&oacute;rias para o desenvolvimento regional ao inv&eacute;s de compacta&ccedil;&otilde;es de pilhas cheias.</p>
<p>Como o CMS, o G1 pode deixar de manter-se com as taxas de promo&ccedil;&atilde;o, e voltar&aacute; para um FullGC stop-the-world. Assim como o CMS tem &quot;concorrente modo de falha&quot;, G1 pode sofrer uma falha de evacua&ccedil;&atilde;o, visto nos logs como &quot;estouro de espa&ccedil;o&quot;. Isso ocorre quando n&atilde;o existem regi&otilde;es livres na qual os objetos possam ser evacuados, que &eacute; similar a uma falha de promo&ccedil;&atilde;o. Se isso ocorrer, tente usar uma grande pilha e mais threads de marca&ccedil;&atilde;o, mas em alguns casos mudan&ccedil;as na aplica&ccedil;&atilde;o s&atilde;o necess&aacute;rias para reduzir os custos de aloca&ccedil;&atilde;o.</p>
<p>Um problema desafiador para o G1 &eacute; lidar com objetos populares e regi&otilde;es. Compacta&ccedil;&atilde;o incremental stop-the-world funciona bem quando regi&otilde;es tem objetos vivos que n&atilde;o s&atilde;o fortemente referenciados em outras regi&otilde;es. Se um objeto ou regi&atilde;o &eacute; popular ent&atilde;o o Remembered Set ser&aacute; grande e o G1 evitar&aacute; coletar estes objetos. Eventualmente ele pode n&atilde;o ter escolha, que resultar&aacute; em muitas pausas frequentes de m&eacute;dia dura&ccedil;&atilde;o at&eacute; que a heap seja compactada.</p>
<p><strong>Coletores Concorrentes Alternativos</strong></p>
<p>CMS e G1 s&atilde;o frequentemente chamados de coletores concorrentes. Quando olhamos o trabalho total realizado &eacute; claro que a <i>young gen</i>, promo&ccedil;&atilde;o e at&eacute; mesmo o trabalho da <i>old gen</i> n&atilde;o &eacute; concorrente ao todo. O CMS &eacute; mais concorrente para a <i>old gen</i>; O G1 &eacute; muito mais do que um coletor incremental do tipo stop-the-world. Ambos CMS e G1 tem significantes e regulares ocorr&ecirc;ncias dos eventos stop-the-world, e nos piores cen&aacute;rios que frequentemente tornam-nos impr&oacute;prios para rigorosas aplica&ccedil;&otilde;es de baixa lat&ecirc;ncia, como uma negocia&ccedil;&atilde;o financeira or interfaces reativas ao usu&aacute;rio.</p>
<p>Coletores alternativos como Oracle JRockit Real Time, IBM Websphere Real Time e Azul Zing est&atilde;o dispon&iacute;veis. Os coletores JRockit e Websphere levam vantagem na lat&ecirc;ncia na maioria dos casos sobre o CMS e G1, mas frequentemente veem limita&ccedil;&otilde;es na faixa de transfer&ecirc;ncia e continuam sofrendo significantes eventos stop-the-world. Zinf &eacute; o &uacute;nico coletor Java conhecido por este autor que pode ser verdadeiramente concorrente para coleta e compacta&ccedil;&atilde;o enquanto mant&eacute;m uma alta taxa de transfer&ecirc;ncia para todas as gera&ccedil;&otilde;es. Zing tem algumas fra&ccedil;&otilde;es de milisengundos em eventos stop-the-world, mas h&aacute; trocas de fases no ciclo de coleta que n&atilde;o est&atilde;o relacionados ao tamanho do conjunto vivo.</p>
<p>JRockit RT pode alcan&ccedil;ar tempos de pausa t&iacute;picos em dezenas de milisegundos para altas taxas de aloca&ccedil;&atilde;o contidas no tamanho da pilha, mas as vezes tem que deixar para traz a pausa para a compacta&ccedil;&atilde;o completa. Websphere RT pode alcan&ccedil;ar pausas de poucos milisegundos atrav&eacute;s de taxa de aloca&ccedil;&atilde;o restrita e tamanho de conjuntos vivos. O Zing pode alcan&ccedil;ar pausas de fra&ccedil;&otilde;es de milisegundos com altas taxas de aloca&ccedil;&atilde;o por ser concorrente por todas fases, incluindo durante as coletas menores. O Zing tem condi&ccedil;&otilde;es de manter esse comportamento consistente gra&ccedil;as ao tamanho da heap, permitindo que o usu&aacute;rio aplique grandes tamanhos de heap conforme preciso, acompanhando a taxa de tranfer&ecirc;ncia do aplicativo ou a necessidade dos estados dos objetos, sem medo de maiores tempos de pausa.</p>
<p>Para todos os coletores concorrentes focados na lat&ecirc;ncia &eacute; necess&aacute;rio dar um pouco de taxa de transfer&ecirc;ncia e ganho de rastro. Dependendo da efici&ecirc;ncia do coletor concorrente pode-se dar um pouco de taxa de transfer&ecirc;ncia, mas est&aacute; sempre adicionando rastro significativo. Se for realmente concorrente, com poucos eventos stop-the-world, ent&atilde;o mais n&uacute;cleos de CPU ser&atilde;o necess&aacute;rios para habilitar a concorr&ecirc;ncia e manter a vaz&atilde;o.</p>
<p>Observa&ccedil;&atilde;o: Todos coletores concorrentes tendem a funcionar mais eficientemente quando h&aacute; espa&ccedil;o suficiente para a aloca&ccedil;&atilde;o. Como regra de ponto de partida tente reservar uma heap com pelo menos duas ou tr&ecirc;s vezes o tamanho dos conjuntos vivos, para a opera&ccedil;&atilde;o ser eficiente. Entretanto, o espa&ccedil;o necess&aacute;rio para manter as opera&ccedil;&otilde;es concorrentes aumentam com a taxa de transfer&ecirc;ncia da aplica&ccedil;&atilde;o, e est&aacute; associada a aloca&ccedil;&atilde;o e taxas de promo&ccedil;&atilde;o. Ent&atilde;o para aplica&ccedil;&otilde;es de maior vaz&atilde;o, uma heap maior para um conjunto vivo proporcional pode ser justificado. Dados os enormes espa&ccedil;os de mem&oacute;ria dispon&iacute;veis para os sistemas de hoje o uso da mem&oacute;ria raramente &eacute; um problema no lado do servidor.</p>
<p><strong>Monitorando e Ajustando a Coleta de Lixo</strong></p>
<p>Para entender como a aplica&ccedil;&atilde;o e o garbage collector est&atilde;o se comportando, inicie a JVM com as seguintes configura&ccedil;&otilde;es:</p>
<pre>
-verbose:gc
-Xloggc:&lt;filename&gt;
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintTenuringDistribution
-XX:+PrintGCApplicationConcurrentTime
-XX:+PrintGCApplicationStoppedTime
</pre>
<p>Ent&atilde;o carregue os logs dentro de uma ferramenta como <a href="https://github.com/chewiebug/GCViewer">Chewiebug</a> para realizar as analises.</p>
<p>Para ver a natureza din&acirc;mica do GC, execute o JVisualVM e instale o plugin Visual GC que permitir&aacute; a visualiza&ccedil;&atilde;o do GC em a&ccedil;&atilde;o, como por exemplo na aplica&ccedil;&atilde;o a seguir.</p>
<p class="image-wide"><img src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/pt/resources/Figure3.jpg" alt="" _href="img://Figure3.jpg" _p="true" /></p>
<p>Para entender o que o GC da aplica&ccedil;&atilde;o precisa &eacute; necess&aacute;rio carregar testes representativos que possam ser rodados repetidamente. &Agrave; medida que se familiariza com a forma como cada coletor trabalha, ent&atilde;o execute os teste de carga com diferentes configura&ccedil;&otilde;es at&eacute; chegar na taxa de transfer&ecirc;ncia e lat&ecirc;ncia desejadas. &Eacute; importante medir a lat&ecirc;ncia da perspectiva do usu&aacute;rio final. Isso pode ser alcan&ccedil;ado capturando o tempo de resposta de cada requisi&ccedil;&atilde;o do teste em um historograma, e &eacute; poss&iacute;vel ler mais sobre isso <a href="https://github.com/giltene/HdrHistogram">aqui</a>. Se houver picos de lat&ecirc;ncia que est&atilde;o fora do range aceit&aacute;vel, ent&atilde;o tente relacion&aacute;-las com os logs do GC para determinar se o problema &eacute; o GC. &Eacute; poss&iacute;vel que outras quest&otilde;es possam causar os picos de lat&ecirc;ncia. Outra ferramenta &uacute;til a considerar &eacute; o <a href="http://www.jhiccup.com/">jHiccup</a> que pode ser usado para acompanhar as pausas dentro da JVM e atrav&eacute;s do sistema como um todo.</p>
<p>Se os picos de lat&ecirc;ncia s&atilde;o devidos ao GC, ent&atilde;o invista em ajustar o CMS ou G1 para ver se suas m&eacute;tricas de lat&ecirc;ncia podem ser cumpridas. As vezes isso n&atilde;o &eacute; poss&iacute;vel devido a alta aloca&ccedil;&atilde;o e taxas de promo&ccedil;&atilde;o combinadas com os requisitos de baixa lat&ecirc;ncia. Os ajustes do GC podem se tornar um exerc&iacute;cio altamente necess&aacute;rio e que muitas vezes requer mudan&ccedil;as de aplicativos para reduzir as taxas de aloca&ccedil;&atilde;o ou ciclo de vida dos objetos. Se for o caso, ent&atilde;o avalie a economia de tempo e recursos gastos no ajustes do GC e mudan&ccedil;as na aplica&ccedil;&atilde;o com a compra de um dos concorrentes comerciais de compacta&ccedil;&atilde;o de JVMs como JRockit Real Time Azul ou Zing.</p><br><br><br><br><br><br></body></html>