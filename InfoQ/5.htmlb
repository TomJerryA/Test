<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>可视化Java垃圾回收</h3><p>垃圾回收，就像双陆棋一样，只需几分钟来学习，但要用一生来精通。</p>
<p>Ben Evans是一名资深培训师兼顾问，他在演讲<a href="http://www.infoq.com/presentations/Visualizing-Java-GC">可视化垃圾回收</a>中从基础谈起讨论了垃圾回收。</p>
<p>以下是对其演讲的简短总结。</p>
<h2><b>基础</b></h2>
<p>当谈到释放不再使用的内存，垃圾回收已经在很大程度上取代了早期技术，比如手动内存管理和引用计数。</p>
<p>这是件好事，因为内存管理令人厌烦，学究式地簿记是计算机擅长的，而不是人擅长的。在这方面，语言的运行时环境比人强。</p>
<p>现代的垃圾回收非常高效，远远超过早期语言中典型的手工分配。通常，具有其它语言背景的人只盯着垃圾回收造成的中断，却没有完全理解自动内存管理发生作用的上下文环境。</p>
<div id="lowerFullwidthVCR"></div>
<p>标记&amp;清除是Java（及其它运行时环境）用于垃圾回收的基本算法。</p>
<p>在标记&amp;清除算法中，引用会从每个线程栈的桢指向程序的堆。所以，从栈开始，循着指针找到所有可能的引用，然后再循着这些引用递归下去。</p>
<p>当递归完成，就找到了所有的活对象，其它的都是垃圾。</p>
<p>请注意，人们经常漏掉的一点是，运行时环境本身也有一个“分配清单（allocation list）”，上面列出了指向每个对象的指针，该列表由垃圾回收器负责维护，并帮助垃圾回收器进行垃圾清理。因此，运行时环境总是可以找出由它创建但尚未回收的对象。</p>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108001.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图一</b></p>
<p>上面插图中所示的栈只是一个与单个应用程序线程相关的栈；每个应用程序线程都有一个类似的栈，每个栈本身都有一组指向堆的指针。</p>
<p>如果垃圾回收器试图在应用程序运行过程中获取活对象的快照，那么它就要追踪运动着的目标，那样很容易漏掉一些严重超时的对象分配，因而无法获得一个准确的快照。因此，“Stop the World”是有必要的；也就是，停止应用程序线程足够长的时间，以便捕获活对象的快照。</p>
<p>下面是垃圾回收器必须遵循的两条黄金法则：</p>
<ol> 
 <li>垃圾回收器必须回收所有的垃圾。</li> 
 <li>垃圾回收器必须从不回收任何活对象。</li> 
</ol>
<p>但这两条规则并不是对等的；如果违反了第二条规则，结果会使数据遭到破坏。</p>
<p>另一方面，如果违反了第一条规则，则会是另一种情况，系统并不总是能够回收所有的垃圾，但最终会回收所有的垃圾，那么这是可以接受的，而实际上，这是垃圾回收器的基本原理。</p>
<h2><b>HotSpot</b></h2>
<p>现在，我们来说下HotSpot，它实际上是一个C、C++以及许多特定于平台的汇编程序组成的混合体。</p>
<p>当人们想到解释器，就会想到一个很大的while循环，其中包含一个很长的switch语句。但HotSpot解释器比那个要复杂的多（由于性能原因）。在开始阅读JDK源代码的时候，就会发现HotSpot中实在是有许多汇编程序代码。</p>
<h2><b>对象创建</b></h2>
<p>Java会预先分配大量的连续空间，就是我们所说的“堆”。之后，HotSpot完全在用户空间里管理这块内存。</p>
<p>如果一个Java进程占用了大量的系统（或内核）时间，那么毫无疑问，它不是在进行垃圾回收——因为所有的垃圾回收内存“簿记（bookkeeping）”都是在用户空间进行的。</p>
<h2><b>内存池</b></h2>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108002.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图二</b></p>
<p>“永久代（PermGen）”是一个存储区域，用于保存那些需要在程序生存期内一直存活的东西，如类的元数据。不过，随着应用程序服务器的出现，它们有自己的类加载器，并且需要重新加载类的元数据，永久代作为一个优化决策开始显得糟糕，所幸，它在Java 8中消失了。</p>
<p>Java 8将会使用一个名为“元空间（Metaspace）”的新概念。元空间与永久代并不完全相同。它在堆的外面，由操作系统管理。这意味着，它不会在Java堆中，而是在本地内存里。目前，这还不是一个非常好的消息，因为没有多少工具能够让用户轻松地查看本地内存。所以，永久代消失是件好事，但工具赶上这个变化还需要一些时间。</p>
<h2><b>Java堆布局</b></h2>
<p>现在，我们来看下Java堆。注意堆空间之间的虚拟空间。它们提供了一点浮动量，以允许对内存池进行一定量的尺寸调整，又不用为任何对象移动付出代价。</p>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108003.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图三</b></p>
<p><b>“弱代假设（Weak Generational Hypothesis）”</b></p>
<p>就现状而言，究竟为什么要将堆分成所有这些内存池？</p>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108004.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图四</b></p>
<p>有的运行时事实无法通过静态分析推导出来。上面的插图说明有两组对象：一组存活时间短，一组存活时间长——所以，做额外的簿记以便利用这一事实是有意义的。在Java平台中，有许多类似的作为优化写入平台的事实。</p>
<h2><b>演示</b></h2>
<p>Ben Evans进行了一系列的动画<a href="https://github.com/kittylyst/jfx-mem">演示</a>。第一个演示是个Flash，说明了对象在Eden区和一个新生代Survivor空间之间移动，并最终进入老年代的过程。</p>
<p><b>图五</b>是用JavaFX再现了同样的过程。</p>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108005.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图五</b></p>
<h2><b>运行时开关</b></h2>
<p><b>‘强制性’参数</b></p>
<ul> 
 <li>-verbose：gc——为用户输出一些GC信息</li> 
 <li>-Xloggc:&lt;文件路径&gt;——指定日志输出路径，要确保磁盘有空间</li> 
 <li>-XX：+PringGCDetails——为辅助工具提供“最低限度信息（Minimum information）” <p>——用这个参数代替-verbose：gc</p> </li> 
 <li>--XX：PrintTenuringDistribution——“过早提升（Premature promotion）”信息</li> 
</ul>
<h2><b>基本堆大小参数</b></h2>
<ul> 
 <li><b>-Xms&lt;size&gt; </b>—— 设置预留给堆的最小内存值</li> 
 <li><b>-Xmx&lt;size&gt;</b> —— 设置预留给堆的最大内存值</li> 
 <li><b>-XX:MaxPermSize=&lt;size&gt;</b>——设置永久代的最大内存值 <p>——有利于Spring应用程序和应用服务器</p> </li> 
</ul>
<p>以前，我们被教导要把-Xms和-Xmx的值设的一样大。不过这已经变了。因此，现在可以为-Xms设置一个合理范围内较小的值，或者根本就不设置，因为堆的适应能力现在已经非常好了。</p>
<h2><b>其它参数</b></h2>
<ul> 
 <li>-XX:NewRatio=N</li> 
 <li>-XX:NewSize=N</li> 
 <li>-XX:MaxNewSize=N</li> 
 <li>-XX:MaxHeapFreeRatio</li> 
 <li>-XX:MinHeapFreeRatio</li> 
 <li>-XX:SurvivorRatio=N</li> 
 <li>-XX:MaxTenuringThreshold=N</li> 
</ul>
<p><img width="600" src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108006.png" alt="" _href="img://null" _p="true" /></p>
<p><b>图六</b></p>
<h2><b>为什么要有日志文件</b></h2>
<p>日志文件的好处是能够用于取证分析，可以使用户免于为了再现问题而不得不再执行一次代码（如果是一个罕见的生产环境错误，那么重现并不容易）。</p>
<p>另外，它们包含的信息比针对内存的JMX MXBeans所能提供的信息更多，且不说轮询JMX本身会引入一系列GC问题。</p>
<h2><b>工具</b></h2>
<ul> 
 <li><b>HP JMeter</b><b>（用Google查询一下）</b> <p>——免费，非常可靠，但不再提供支持/功能增强</p> </li> 
 <li><b><a href="http://www.tagtraum.com/gcviewer.html">GCViewer</a></b> <p>——免费，开源，但界面有点丑</p> </li> 
 <li><b><a href="http://code.google.com/a/eclipselabs.org/p/garbagecat/">GarbageCat</a></b> <p>——名字最好听</p> </li> 
 <li><b><a href="http://www.ibm.com/developerworks/java/jdk/tools/gcmv/">IBM GCMV</a></b> <p>——支持J9</p> </li> 
 <li><b><a href="http://www.jclarity.com/products/censum">jClarity Censum</a></b> <p>——界面最美观，而且最有用——不过，这是我们的偏见！</p> </li> 
</ul>
<h2><b>小结</b></h2>
<ul> 
 <li><b>需要了解一些GC基础理论</b></li> 
 <li><b>要让新生代的大部分对象在年轻时死亡</b></li> 
 <li><b>打开GC日志！</b>——原始日志文件难以阅读——使用工具</li> 
 <li><b>使用工具来帮助自己调优</b>——测量，而不是猜测</li> 
</ul>
<p>查看完整演讲视频，请点击<a href="http://www.infoq.com/presentations/Visualizing-Java-GC">这里</a>。</p>
<h2><b>关于作者</b></h2>
<p><img src="http://infoqstatic.com/resource/articles/Visualizing-Java-Garbage-Collection/zh/resources/0108007.jpg" style="float: left; margin-right: 10px" alt="" _href="img://null" _p="true" /><b>Ben Evans</b>是一家Java/JVM性能分析创业公司jClarity的CEO。在业余时间，他是伦敦Java社区的一名负责人，也是Java社区过程执行委员会成员之一。他先前的项目包括：对Google IPO、金融交易系统做性能测试，为若干90年代最大的电影开发获奖网站等等。</p>
<div style="clear:both">
 &nbsp;
</div>
<p><b>查看英文原文：</b><b><a href="http://www.infoq.com/articles/Visualizing-Java-Garbage-Collection">Visualizing Java Garbage Collection</a></b></p><br><br><br><br><br><br></body></html>