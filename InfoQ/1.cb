<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Testes na Typemock: lidando com problemas do mundo real</h3><p>Uma coisa que aprendi nos &uacute;ltimos anos &eacute; que testes unit&aacute;rios s&atilde;o vistos como &quot;problema resolvido&quot;. Com tanta disponibilidade de informa&ccedil;&otilde;es, livros e ferramentas, a percep&ccedil;&atilde;o &eacute; que basta baixar algo como o NUnit e pronto. Mas n&atilde;o &eacute; bem assim. Antes mesmo de decidir escrever testes unit&aacute;rios, devemos aproveitar a experi&ecirc;ncia real de outras pessoas: hist&oacute;rias boas, hist&oacute;rias ruins, de horror, de sucesso.</p><p>Gostaria de levar o leitor por uma breve viagem pelo mundo dos testes unit&aacute;rios. Nossa equipe na Typemock tem explorado por anos essa &aacute;rea, e essas experi&ecirc;ncias definitivamente afetaram nosso processo de desenvolvimento de produtos. Nosso produto principal, o <a href="http://www.typemock.com/isolator-product-page">Isolator</a>, come&ccedil;ou como framework para cria&ccedil;&atilde;o de <a href="http://pt.wikipedia.org/wiki/Mock_Object">mocks</a>. No entanto, &agrave; medida que descobr&iacute;amos mais a respeito dos problemas pr&aacute;ticos enfrentados com testes unit&aacute;rios, mais desenvolv&iacute;amos novas funcionalidades para alivi&aacute;-los. Por&eacute;m, posso garantir que ainda h&aacute; muito por se fazer e para se descobrir em testes unit&aacute;rios.</p><p>Nossa vis&atilde;o na Typemock &eacute;: facilitar o desenvolvimento de testes unit&aacute;rios para todos. Simples. F&aacute;cil de alcan&ccedil;ar? Bem... O desenvolvimento de testes unit&aacute;rios n&atilde;o &eacute; f&aacute;cil. Os benef&iacute;cios s&atilde;o enormes, por&eacute;m &eacute; muito trabalhoso obt&ecirc;-los.</p><p>A maioria dos desenvolvedores j&aacute; tem uma base de c&oacute;digo em que est&aacute; trabalhando. Alguns t&ecirc;m a sorte de trabalhar em projetos novos, por&eacute;m a maioria lida com c&oacute;digo legado. Quando decidimos escrever testes, &eacute; para o c&oacute;digo legado que os escrevemos. O problema &eacute; que isso n&atilde;o &eacute; t&atilde;o f&aacute;cil.</p><p>Quando a Typemock come&ccedil;ou, n&atilde;o era poss&iacute;vel escrever testes para c&oacute;digo legado sem ter que alterar o c&oacute;digo para adequ&aacute;-lo aos testes. Esse era o principal objetivo do Isolator: prover a capacidade de escrever testes unit&aacute;rios sem ter que alterar o c&oacute;digo.</p><h3>APIs em evolu&ccedil;&atilde;o</h3><p>Uma coisa que aprendemos ao longo tempo &eacute; observar atentamente a maneira como nossa API &eacute; utilizada. Por exemplo: nosso primeiro conjunto de APIs era baseado em strings, de forma que para simular um DateTime.now era necess&aacute;rio fazer algo assim:</p><pre>
Mock mockDateTime = MockManager.MockAll&lt;datetime&gt;(); mockDateTime.ExpectGetAlways(&quot;Now&quot;, new DateTime(2000, 1, 1));
</pre><p>Apesar de n&atilde;o ser perfeito, funciona. Mas sabemos que coisas como essas s&atilde;o f&aacute;ceis de quebrar durante uma refatora&ccedil;&atilde;o; por isso passamos para o modelo de grava&ccedil;&atilde;o-reprodu&ccedil;&atilde;o, que &eacute; amig&aacute;vel a refatora&ccedil;&otilde;es, apesar de parecer um tanto estranho:</p><pre>
using (RecordExpectations recorder = RecorderManager.StartRecording())
{
   DateTime.Now = new DateTime(2000, 1, 1);
}
</pre><p>Isso funciona e j&aacute; tinha sido visto como maneira revolucion&aacute;ria de escrever testes, mas o estilo grava&ccedil;&atilde;o-reprodu&ccedil;&atilde;o estava saindo de moda. Essa vers&atilde;o tinha alguns problemas t&eacute;cnicos dos quais quer&iacute;amos nos livrar. Assim, quando as express&otilde;es lambda surgiram, nossas APIs tomaram outro rumo, tanto em rela&ccedil;&atilde;o &agrave; legibilidade quanto &agrave; capacidade de se aplicar refatora&ccedil;&otilde;es.</p><pre>
Isolate.WhenCalled(() =&gt; DateTime.Now).WillReturn(new DateTime(2000, 1, 1));
</pre><p>Com o conjunto atual de APIs, decidimos fazer outra simplifica&ccedil;&atilde;o. Abandonamos o termo &quot;mock&quot; e o substitu&iacute;mos por &quot;fake&quot; para as inst&acirc;ncias. &quot;Mock&quot; e &quot;stub&quot; s&atilde;o termos com m&uacute;ltiplos significados, que t&ecirc;m sido mal utilizados e confundidos. Ao inv&eacute;s de tentar ensinar as nuances desses conceitos para os iniciantes, decidimos contornar o problema em definitivo.</p><h3>Bons vizinhos</h3><p>O Isolator, como um complemento do Visual Studio, n&atilde;o era o suficiente - precis&aacute;vamos integr&aacute;-lo a outras ferramentas e outros fornecedores. Ferramentas de cobertura de c&oacute;digo, profilers de desempenho, mecanismos de build, e mais. O Isolator precisava conviver bem com outras solu&ccedil;&otilde;es para que se pudesse executar testes facilmente, utilizando diversas ferramentas com configura&ccedil;&otilde;es variadas.</p><p>A respeito da execu&ccedil;&atilde;o de testes, como execut&aacute;-los fora do Visual Studio? Quando se come&ccedil;a a implantar ferramentas de integra&ccedil;&atilde;o cont&iacute;nua numa equipe, logo se aprende sobre muitas ferramentas diferentes no universo Microsoft, inclusive a respeito do poderoso <a href="http://en.wikipedia.org/wiki/Team_Foundation_Server">TFS</a> (Team Foundation System). A tecnologia de <em>profiling</em> do Isolator exige muito trabalho de integra&ccedil;&atilde;o para permitir a execu&ccedil;&atilde;o dos testes dentro de processos de integra&ccedil;&atilde;o cont&iacute;nua. Equipes diferentes usam conjuntos diferentes de ferramentas e diferentes servidores de Integra&ccedil;&atilde;o Cont&iacute;nua, e precis&aacute;vamos criar uma solu&ccedil;&atilde;o que pudesse se adequar facilmente &agrave; maneira que as pessoas trabalham.</p><h3>APIs robustas</h3><p>Pergunte a qualquer pessoa que j&aacute; at&eacute; mesmo cogitou escrever testes unit&aacute;rios, e voc&ecirc; ouvir&aacute; o seguinte: sei que meu c&oacute;digo vai mudar, mas n&atilde;o quero ter que consertar meus testes o tempo inteiro. H&aacute; algo que possa ser feito a respeito?</p><p>Em frameworks de <em>mock</em>, a habilidade de se alterar comportamentos vem do conhecimento do que ocorre dentro de um objeto. Mas essa &quot;vis&atilde;o de raio-X&quot; tem o seu calcanhar de Aquiles - altera&ccedil;&otilde;es no c&oacute;digo interno afetam os testes.</p><p>Testes unit&aacute;rios t&ecirc;m tamb&eacute;m rela&ccedil;&atilde;o com manuten&ccedil;&atilde;o de c&oacute;digo. Durante o desenvolvimento das nossas APIs, sempre levamos isso em considera&ccedil;&atilde;o. Considere, por exemplo, este construtor de um objeto (de um projeto open source chamado <a href="http://erpstore.codeplex.com/">ERPStore</a>):</p><pre>
public AnonymousCheckoutController(
        ISalesService salesService
        , ICartService cartService
        , IAccountService accountService
        , IEmailerService emailerService
        , IDocumentService documentService
        , ICacheService cacheService
        , IAddressService addressService
        , CryptoService cryptoService
        , IIncentiveService IncentiveService)</pre><p>O construtor utiliza muitas interfaces como entradas. Em meus testes, posso simular essas depend&ecirc;ncias desta maneira:</p><pre>
var fakeSalesService = Isolate.Fake.Instance&lt;SalesController&gt;();
var fakeCartService = Isolate.Fake.Instance&lt;ICartService&gt;();
var fakeAccountService = Isolate.Fake.Instance&lt;IAccountService&gt;();
var fakeEmailerService = Isolate.Fake.Instance&lt;IEmailerService&gt;();
var fakeDocumentService= Isolate.Fake.Instance&lt;IDocumentService&gt;();
var fakeCacheService = Isolate.Fake.Instance&lt;ICacheService&gt;();
var fakeAddressService = Isolate.Fake.Instance&lt;IAddressService&gt;();
var fakeCryptoService = Isolate.Fake.Instance&lt;CryptoService&gt;();
var fakeIncentiveService = Isolate.Fake.Instance&lt;IncentiveService&gt;();

var controller = new AnonymousCheckoutController(
      fakeSalesService,
      fakeCartService,
      fakeAccountService,
      fakeEmailerService,
      fakeDocumentService,
      fakeCacheService,
      fakeAddressService,
      fakeCryptoService,
      fakeIncentiveService);
</pre><p>O que aconteceria se precis&aacute;ssemos que o construtor aceitasse outro tipo? Ou se remov&ecirc;ssemos um argumento? Inevitavelmente ter&iacute;amos que alterar os testes.</p><p>Ent&atilde;o criamos uma API que desacopla a assinatura do construtor da maneira que ele &eacute; utilizado nos testes:</p><pre>
var controller = Isolate.Fake.Dependencies
 <anonymouscheckoutcontroller>
  (); 
 </anonymouscheckoutcontroller></pre><p>Isso &eacute; tudo. A API Fake.Dependencies cria um objeto real do tipo <em>AnonymousCheckoutController</em>, e passa implementa&ccedil;&otilde;es &quot;falsas&quot; das depend&ecirc;ncias, mas sem mencionar seus tipos. Se o construtor mudar, os testes continuar&atilde;o funcionado. Conseguimos reduzir o acoplamento entre o teste e o c&oacute;digo e ainda aumentamos a legibilidade.</p><h3>Testes melhores</h3><p>Quem tem experi&ecirc;ncia com desenvolvimento de testes unit&aacute;rios sabe que essa &eacute; uma habilidade que se desenvolve com o tempo. Todos podem aprender a escrever testes melhores, mas normalmente aprendemos da maneira mais dif&iacute;cil. Pensamos em tornar mais f&aacute;cil essa experi&ecirc;ncia; como podemos ajudar as pessoas a evitar os mesmos erros que cometemos?</p><p>Era o momento de adicionar uma nova funcionalidade ao Isolator. A capacidade de examinar os testes e indicar erros comuns (por exemplo, um teste sem <em>asserts</em>) dentro do Visual Studio. O Isolator oferece uma oportunidade de melhorar o c&oacute;digo por meio de sugest&otilde;es.</p><p><img width="798" height="329" _p="true" _href="img://4image00.jpg" alt="" src="/resource/articles/Typemock/pt/resources/4image00.jpg;jsessionid=9574FADAE394821AD0B6844947A8BE2F" /></p><h3>Melhorando o ciclo de feedback</h3><p>Por muito tempo, o Isolator n&atilde;o teve um executor de testes pr&oacute;prio. Essa era nossa maneira de dizer ao usu&aacute;rio que ele poderia escolher a melhor ferramenta, e que ir&iacute;amos nos adaptar &agrave; escolha dele. Ao enfrentar novos desafios, come&ccedil;amos a pensar a respeito do processo de desenvolvimento cont&iacute;nuo.</p><p>Pessoas experientes, depois de escreverem conjuntos de testes grandes, come&ccedil;aram a nos solicitar mais velocidade. Ao longo do tempo, fizemos o Isolator trabalhar mais r&aacute;pido, mas ainda assim ach&aacute;vamos que n&atilde;o era o suficiente. Conjuntos de testes levam um tempo para executar, mas nem sempre &eacute; preciso executar todo o conjunto de testes. Na verdade, em uma sess&atilde;o de desenvolvimento, apenas os testes relacionados ao c&oacute;digo alterado deveriam ser executados. Todos os demais poderiam ser executados em outro momento, como, por exemplo, em um servidor ou antes de um <em>check in</em>.</p><p>Mas o problema n&atilde;o acabava a&iacute;. Desenvolvedores de testes experientes olham o que escreveram h&aacute; tr&ecirc;s anos e n&atilde;o acreditam que criaram testes t&atilde;o ruins. Testes de baixa qualidade n&atilde;o s&atilde;o apenas facilmente quebrados; &agrave;s vezes, nem s&atilde;o verdadeiros testes unit&aacute;rios, mas sim testes de integra&ccedil;&atilde;o disfar&ccedil;ados. Por isso n&atilde;o podem ser executados rapidamente. Um grande conjunto de testes n&atilde;o executa lentamente apenas por conta do seu tamanho - mas tamb&eacute;m por incluir testes lentos por natureza.</p><p>O empurr&atilde;o final que motivou o desenvolvimento de um executor de testes especializado veio de uma &aacute;rea completamente diferente: a corre&ccedil;&atilde;o de defeitos. Quando os testes falham, procura-se determinar quais mudan&ccedil;as recentes podem ter causado a falha. Tenta-se resolver o quebra-cabe&ccedil;a mentalmente: Qual foi o &uacute;ltimo lugar que fiz altera&ccedil;&otilde;es? O que mudei? Por que esse teste est&aacute; falhando, enquanto outros cen&aacute;rios continuam funcionando? E normalmente, s&oacute; depois de muito tempo de depura&ccedil;&atilde;o, consegue-se corrigir o problema.</p><p>Como em muitos outros lugares, est&aacute;vamos buscando uma solu&ccedil;&atilde;o mais eficiente para melhorar toda a experi&ecirc;ncia de desenvolvimento e de testes. O problema n&atilde;o se limitava a encontrar maneiras de escrever testes mais rapidamente, ou execut&aacute;-los com mais velocidade. Envolvia todo o processo iterativo de cria&ccedil;&atilde;o de testes: escrever os testes, rodar os testes, corrigir os testes que falharam; repetir.</p><p>O executor de testes do Isolator procura resolver todo esse conjunto de problemas. Ele executa automaticamente apenas os testes relevantes: aqueles que executam o c&oacute;digo alterado. Para fornecer feedback o mais r&aacute;pido poss&iacute;vel, exclui automaticamente os testes de execu&ccedil;&atilde;o mais demorados e j&aacute; exibe no c&oacute;digo o que est&aacute; coberto e por quais testes. O Isolator tamb&eacute;m leva em considera&ccedil;&atilde;o os trechos nos quais ocorreram mudan&ccedil;as recentes, e pode indicar locais onde o defeito pode ter sido inclu&iacute;do. Isso encoraja o aumento da cobertura dos testes e fornece mais feedback relevante, facilitando a sustenta&ccedil;&atilde;o da melhoria cont&iacute;nua do c&oacute;digo.</p><h3>Conclus&otilde;es</h3><p>Essa &eacute; a hist&oacute;ria do Isolator at&eacute; agora. No in&iacute;cio quer&iacute;amos resolver um &uacute;nico problema, mas &agrave; medida que mais pessoas passaram a utilizar testes unit&aacute;rios, descobrimos que pod&iacute;amos ajudar mais ao examinar os desafios enfrentados. O desenvolvimento de testes unit&aacute;rios n&atilde;o &eacute; f&aacute;cil - e ainda h&aacute; muito por fazer.</p><div class="clearer-space"></div></body></html>