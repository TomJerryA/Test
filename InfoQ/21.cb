<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>9 fal√°cias sobre o desempenho do Java</h3><p>O desempenho do Java tem a reputa&ccedil;&atilde;o de ser complexa, parte dessa concep&ccedil;&atilde;o &eacute; devida &agrave; sofistica&ccedil;&atilde;o da plataforma que &eacute; dif&iacute;cil de explicar em muitos casos. Entretanto, historicamente sempre existiu uma tend&ecirc;ncia por t&eacute;cnicas de otimiza&ccedil;&atilde;o de performance em Java baseadas na sabedoria popular, em vez de estat&iacute;sticas aplicadas e fundamenta&ccedil;&atilde;o emp&iacute;rica. Neste artigo esperamos esclarecer alguns desses &quot;mitos t&eacute;cnicos&quot; mais not&oacute;rios.</p>
<p><strong>1. O Java &eacute; lento</strong></p>
<p>De todas as fal&aacute;cias mais desatualizadas sobre o desempenho do Java, essa &eacute; provavelmente a mais &oacute;bvia.</p>
<p>&Eacute; claro, por volta dos anos 90 e come&ccedil;o de 2000, o Java era lento &agrave;s vezes.</p>
<p>No entanto, nos &uacute;ltimos 10 anos houve muita melhoria na m&aacute;quina virtual e no compilador JIT. Hoje em dia, o desempenho geral do Java &eacute; absurdamente r&aacute;pido.</p>
<p>Em seis <a href="http://www.google.com/url?q=http%3A%2F%2Fwww.techempower.com%2Fblog%2F2013%2F04%2F05%2Fframeworks-round-2%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHx825je2cPSSYIu5p1-_TpvwwXYw">benchmarks</a> <a href="http://www.google.com/url?q=http%3A%2F%2Fwww.techempower.com%2Fblog%2F2013%2F04%2F05%2Fframeworks-round-2%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHx825je2cPSSYIu5p1-_TpvwwXYw">de desempenho Web</a> distintos, os frameworks Java ficaram com 22 das 24 primeiras posi&ccedil;&otilde;es.</p>
<div id="lowerFullwidthVCR"></div>
<p>O uso de profiling pela JVM otimiza apenas as por&ccedil;&otilde;es de c&oacute;digo altamente utilizadas trazendo bastante melhoria de desempenho. Atualmente, o c&oacute;digo Java compilado com JIT &eacute; t&atilde;o r&aacute;pido quanto C++ em um grande (e crescente) n&uacute;mero de casos.</p>
<p>Mesmo assim, a percep&ccedil;&atilde;o de que o Java &eacute; uma plataforma lenta ainda continua, muito provavelmente por causa de um hist&oacute;rico negativo de pessoas que tiveram experi&ecirc;ncias com as primeiras vers&otilde;es da plataforma.</p>
<p>Sugerimos que sejam objetivos e analisem os resultados de avalia&ccedil;&otilde;es de desempenho mais recentes antes de tirar conclus&otilde;es.</p>
<p><strong>2. Uma linha de c&oacute;digo Java n&atilde;o significa nada se analisada de forma isolada</strong></p>
<p>Considere a seguinte linha de c&oacute;digo:</p>
<p>MyObject obj = new MyObject();</p>
<p>Para um desenvolvedor Java, parece &oacute;bvio que essa linha de c&oacute;digo vai alocar um objeto e executar o construtor apropriado.</p>
<p>A partir disso podemos come&ccedil;ar a argumentar a respeito das fronteiras de desempenho. Sabemos que h&aacute; uma quantidade finita de trabalhos que devem acontecer, ent&atilde;o podemos tentar calcular o impacto no desempenho baseado nas suposi&ccedil;&otilde;es.</p>
<p>Essa &eacute; uma tend&ecirc;ncia cognitiva que pode nos enganar, a priori, qualquer trabalho ser&aacute; realizado at&eacute; o fim.</p>
<p>A realidade &eacute; que, tanto o compilador javac quanto o JIT, podem otimizar e remover c&oacute;digos inutilizados. No caso do compilador JIT, o c&oacute;digo pode ser otimizado de forma especulativa, baseando-se em dados de profiling. Nesses casos, a linha de c&oacute;digo n&atilde;o ir&aacute; ser executada e, dessa forma, n&atilde;o causar&aacute; impacto no desempenho.</p>
<p>Al&eacute;m disso, em algumas JVMs (como o JRockit) o compilador JIT pode decompor as opera&ccedil;&otilde;es de objetos para que as aloca&ccedil;&otilde;es sejam evitadas, mesmo se o trecho de c&oacute;digo n&atilde;o for completamente inutilizado.</p>
<p>Moral da hist&oacute;ria: &eacute; importante considerar o contexto quando fizermos an&aacute;lises sobre o desempenho do Java, e que otimiza&ccedil;&otilde;es prematuras podem produzir resultados contra intuitivos. Para melhores resultados, n&atilde;o tente otimizar prematuramente. Em vez disso, sempre construa seu c&oacute;digo e use t&eacute;cnicas de <a href="http://en.wikipedia.org/wiki/Performance_tuning">tuning</a> para localizar e corrigir seus <a href="http://en.wikipedia.org/wiki/Hot_spot_(computer_science)">hot spots</a> de desempenho.</p>
<p><strong>3. Um micro benchmark significa o que voc&ecirc; acha</strong></p>
<p>Como vimos anteriormente, tirar conclus&otilde;es sobre uma pequena parte do c&oacute;digo &eacute; menos preciso que analisar o desempenho geral do aplicativo.</p>
<p><a href="http://pt.wikipedia.org/wiki/Richard_Feynman">Richard Feynman</a> disse certa vez que: &quot;O primeiro princ&iacute;pio &eacute; que voc&ecirc; n&atilde;o deve enganar a si mesmo - e voc&ecirc; &eacute; a pessoa mais f&aacute;cil de ser enganada&quot;. Em nenhum lugar isso &eacute; mais verdade que escrevendo micro benchmarks Java.</p>
<p>Escrever bons micro benchmarks &eacute; uma tarefa profundamente dif&iacute;cil. A plataforma Java &eacute; sofisticada e complexa, e muitos micro benchmarks conseguem apenas medir efeitos tempor&aacute;rios ou outros aspectos n&atilde;o intencionais da plataforma.</p>
<p>Por exemplo, um micro benchmark escrito de forma ing&ecirc;nua ir&aacute; frequentemente acabar medindo o tempo do subsistema ou, talvez, do garbage collector, em vez do efeito que ele estava tentando capturar.</p>
<p>Somente desenvolvedores e equipes que t&ecirc;m real necessidade devem escrever micro benchmarks. Esses benchmarks devem ser publicados em sua totalidade (incluindo o c&oacute;digo-fonte), e devem ser reproduz&iacute;veis e sujeitos a uma an&aacute;lise profunda e revis&atilde;o pelos seus colegas.</p>
<p>As v&aacute;rias otimiza&ccedil;&otilde;es da plataforma Java influenciam nas estat&iacute;sticas de execu&ccedil;&otilde;es individuais. Um &uacute;nico benchmark precisa ser executado v&aacute;rias vezes e os resultados devem ser agregados para se obter uma resposta realmente confi&aacute;vel.</p>
<p>Caso queira escrever micro benchmarks, ent&atilde;o um bom lugar para come&ccedil;ar &eacute; lendo o artigo &quot;<a href="http://buytaert.net/files/oopsla07-georges.pdf">Statistically Rigorous Java Performance Evaluation</a>&quot; (Avalia&ccedil;&atilde;o Estatisticamente Rigorosa de Performance do Java) escrito por Georges, Buytaert e Eeckhout. Sem o tratamento apropriado das estat&iacute;sticas, &eacute; muto f&aacute;cil ser enganado.</p>
<p>Existem boas ferramentas e comunidades em torno delas (por exemplo, Caliper do Google) - se for necess&aacute;rio escrever um micro benchmarks, ent&atilde;o n&atilde;o o fa&ccedil;a por conta pr&oacute;pria - utilize tamb&eacute;m o ponto de vista e da experi&ecirc;ncia de seus colegas.</p>
<p><strong>4. A lentid&atilde;o dos algoritmos &eacute; a causa mais comum de problemas de desempenho</strong></p>
<p>Um erro muito comum entre os desenvolvedores (e entre os humanos em geral) &eacute; assumir que as partes que eles controlam em um sistema s&atilde;o as mais importantes.</p>
<p>Em se tratando de Java, isso se manifesta por desenvolvedores que acreditam que a qualidade algor&iacute;tmica &eacute; a causa dominante de problemas de desempenho. Como os desenvolvedores pensam somente sobre c&oacute;digo, eles t&ecirc;m uma tend&ecirc;ncia natural a pensar em seus pr&oacute;prios algoritmos.</p>
<p>Na pr&aacute;tica, quando lidamos com um conjunto de problemas de performance em situa&ccedil;&otilde;es reais, o design de algoritmo &eacute; a causa de apenas 10% dos casos.</p>
<p>Em contra partida, o garbage collection, o acesso a banco de dados e configura&ccedil;&otilde;es incorretas s&atilde;o causas muito mais prov&aacute;veis da lentid&atilde;o em aplica&ccedil;&otilde;es.</p>
<p>A maioria das aplica&ccedil;&otilde;es lidam com quantidades relativamente pequenas de dados. Ent&atilde;o, mesmo as maiores inefici&ecirc;ncias algor&iacute;tmicas normalmente n&atilde;o levam a problemas cr&iacute;ticos de performance. Estamos considerando que a qualidade desses algoritmos est&atilde;o abaixo do ideal. Mesmo assim, a quantidade de inefici&ecirc;ncia que esses algoritmos acrescentam &eacute; pequena em rela&ccedil;&atilde;o a outros problemas de performance muito maiores em demais partes da aplica&ccedil;&atilde;o.</p>
<p>Sendo assim, nosso melhor conselho &eacute; usar dados emp&iacute;ricos de produ&ccedil;&atilde;o para descobrir as causas reais de problemas de desempenho. Mensure, n&atilde;o fa&ccedil;a suposi&ccedil;&otilde;es!</p>
<p><strong>5. Cache resolve qualquer coisa</strong></p>
<p>&quot;Qualquer problema na Ci&ecirc;ncia da Computa&ccedil;&atilde;o pode ser resolvido adicionando mais uma camada de indire&ccedil;&atilde;o&quot;.</p>
<p>Esse ditado de programador foi atribu&iacute;do a <a href="http://pt.wikipedia.org/wiki/David_Wheeler">David Wheeler</a>, &eacute; surpreendentemente comum, especialmente entre os desenvolvedores Web.</p>
<p>Normalmente essa fal&aacute;cia surge devido &agrave; paralisia de an&aacute;lise, quando confrontada com uma arquitetura existente e mal entendida.</p>
<p>Em vez de lidar com um sistema intimidador, o desenvolvedor frequentemente escolher&aacute; por se esconder dele, colocando um intermedi&aacute;rio na frente e torcendo pelo melhor acontecer. &Eacute; claro que essa abordagem apenas complica a arquitetura geral e torna a situa&ccedil;&atilde;o ainda pior para o pr&oacute;ximo desenvolvedor que tentar entender o estado atual de produ&ccedil;&atilde;o.</p>
<p>Grandes e abrangentes arquiteturas s&atilde;o escritas de linha em linha e um subsistema por vez. No entanto, em muitos casos, arquiteturas mais simples e refatoradas s&atilde;o mais perform&aacute;ticas - e elas s&atilde;o quase sempre mais simples de entender.</p>
<p>Quando estiver avaliando se uma camada de <a href="http://pt.wikipedia.org/wiki/Cache">cache</a> &eacute; realmente necess&aacute;ria, planeje coletar estat&iacute;sticas b&aacute;sicas de uso (taxa de perda, hit rate, etc) para provar que essa camada est&aacute;, de fato, agregando valor.</p>
<p><strong>6. Todas as aplica&ccedil;&otilde;es precisam se preocupar com o Stop-The-World do garbage collector</strong></p>
<p>Um fato que certo dentro da plataforma Java &eacute; que todas as threads da aplica&ccedil;&atilde;o devem parar periodicamente para permitir que o garbage collectior execute. Isso &eacute; por vezes colocado como um ponto fraco grave, mesmo sem qualquer evid&ecirc;ncia real.</p>
<p>Estudos emp&iacute;ricos mostraram que os seres humanos normalmente n&atilde;o conseguem perceber mudan&ccedil;as em dados num&eacute;ricos (por exemplo, altera&ccedil;&otilde;es de pre&ccedil;o) que ocorrem em uma frequ&ecirc;ncia superior a uma ocorr&ecirc;ncia a cada 200 milissegundos.</p>
<p>Consequentemente, para aplica&ccedil;&otilde;es que tem um humano como seu principal usu&aacute;rio, uma regra b&aacute;sica &eacute; que a pausa causada pelo <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Stop-the-world_vs._incremental_vs._concurrent">Stop-The-World</a> (STW) dure no m&aacute;ximo 200 milissegundos sem causar nenhuma preocupa&ccedil;&atilde;o. Algumas aplica&ccedil;&otilde;es (streaming de v&iacute;deo, por exemplo) precisam de interrup&ccedil;&otilde;es menores do que essa, mas muitas outras n&atilde;o.</p>
<p>Existe uma minoria de aplica&ccedil;&otilde;es que uma pausa de 200ms &eacute; inaceit&aacute;vel. A menos que sua aplica&ccedil;&atilde;o esteja nessa minoria, &eacute; muito improv&aacute;vel que seus usu&aacute;rios ir&atilde;o perceber qualquer impacto causado pelo garbage collector.</p>
<p>Tamb&eacute;m vale a pena mencionar que em qualquer sistema que exista mais threads de aplica&ccedil;&atilde;o que n&uacute;cleos f&iacute;sicos de processamento, o agendador do sistema operacional ter&aacute; que intervir para dividir o tempo de acesso &agrave;s CPUs. O &quot;Stop-The-World&quot; parece assustador, mas na pr&aacute;tica cada aplica&ccedil;&atilde;o (JVM ou n&atilde;o) tem que lidar com a disputa por recursos computacionais escassos.</p>
<p>Sem a realiza&ccedil;&atilde;o de medi&ccedil;&otilde;es, n&atilde;o fica f&aacute;cil perceber se a abordagem da JVM causa algum impacto significativo na performance da aplica&ccedil;&atilde;o.</p>
<p>Em resumo, ative os logs do garbage collector para determinar se os per&iacute;odos de pausa est&atilde;o realmente afetando a aplica&ccedil;&atilde;o. Analise os logs (&agrave; m&atilde;o ou com alguma ferramenta/script) para identificar e determinar os per&iacute;odos de pausa. Ent&atilde;o decida se eles realmente representam um problema para seu dom&iacute;nio de aplica&ccedil;&atilde;o. Mais ainda: pergunte a si mesmo se algum usu&aacute;rio j&aacute; reclamou sobre isso.</p>
<p><strong>7</strong><strong>. Pool &quot;caseiro&quot; de objetos &eacute; apropriado para um amplo conjunto de aplica&ccedil;&otilde;es</strong></p>
<p>Uma resposta comum &agrave; sensa&ccedil;&atilde;o de que as pausas do &quot;Stop-The-World&quot; s&atilde;o de alguma forma ruins &eacute; inventar as pr&oacute;prias t&eacute;cnicas de gerenciamento de mem&oacute;ria dentro da <a href="http://en.wikipedia.org/wiki/Java_virtual_machine#Heap">heap</a> Java. Muitas vezes isso se resume a uma implementa&ccedil;&atilde;o de pool de objetos</p>
<p>Essa t&eacute;cnica &eacute; quase sempre equivocada. Suas ra&iacute;zes est&atilde;o ligadas a um passado distante, quando a aloca&ccedil;&atilde;o de objetos era uma tarefa cara e mutabilidade n&atilde;o era considerada importante. O mundo &eacute; bastante diferente hoje.</p>
<p>Hardwares modernos s&atilde;o incrivelmente eficientes na aloca&ccedil;&atilde;o de mem&oacute;ria. O tamanho de banda de acesso &agrave; mem&oacute;ria &eacute; de pelo menos 2 a 3GB em desktops mais novos ou em servidores. Esse &eacute; um n&uacute;mero bastante grande; exceto em casos espec&iacute;ficos, n&atilde;o &eacute; f&aacute;cil fazer aplica&ccedil;&otilde;es reais que consumam toda essa banda.</p>
<p>Os pools de objetos geralmente s&atilde;o dif&iacute;ceis de implementar corretamente (especialmente quando h&aacute; m&uacute;ltiplas threads trabalhando) e possuem v&aacute;rios quest&otilde;es negativas que os tornam uma m&aacute; escolha para uso geral:</p>
<ul class="c18 lst-kix_xt1cxtwriy0y-0 start"> 
 <li>Todos os desenvolvedores que colocam a m&atilde;o no c&oacute;digo devem estar ciente da exist&ecirc;ncia do pool e controlar isso corretamente;</li> 
 <li>A fronteira entre &quot;c&oacute;digo ciente&quot; e &quot;c&oacute;digo n&atilde;o-ciente&quot; deve ser conhecida e documentada;</li> 
 <li>Toda essa complexidade adicional deve ser mantida atualizada e regularmente revisada;</li> 
 <li>Se alguma dessas coisas falhar, o risco de corrup&ccedil;&atilde;o silenciosa (semelhante ao reuso de ponteiro em C) &eacute; reintroduzido.</li> 
</ul>
<p>Em resumo, o pool de objetos apenas deve ser usado quando as pausas do garbage collector forem inaceit&aacute;veis, e tentativas inteligentes de otimiza&ccedil;&atilde;o e refatora&ccedil;&atilde;o tenham sido incapazes de reduzir as pausas para um n&iacute;vel aceit&aacute;vel.</p>
<p><strong>8. O coletor CMS (Concurrent-Mark-Sweep) sempre &eacute; a melhor escolha para garbage collection</strong></p>
<p>Por padr&atilde;o, o JDK da Oracle usa um coletor stop-the-world paralelo para coletar os objetos na &aacute;rea <a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">old generation</a>.</p>
<p>Uma escolha alternativa &eacute; o coletor Concurrent-Mark-Sweep (CMS). Ele permite que as threads da aplica&ccedil;&atilde;o continuem executando durante a maior parte do ciclo de garbage collection. Mas ele vem com um pre&ccedil;o e traz algumas ressalvas.</p>
<p>Ao permitir que as threads da aplica&ccedil;&atilde;o executem ao mesmo tempo que as threads do garbage collection, invariavelmente isso causa a muta&ccedil;&atilde;o do grafo de objetos e afeta o ciclo de vida dos objetos. Depois disso tudo precisa ser limpo e, por esse motivo, o CMS tem duas fases (geralmente muito curtas) de stop-the-world.</p>
<p>Isso tem v&aacute;rias consequ&ecirc;ncias:</p>
<ol class="c18 lst-kix_zbr484b72jvq-0 start" start="1"> 
 <li>Todas as threads de aplica&ccedil;&atilde;o t&ecirc;m que ser trazidas para pontos seguros e paradas duas vezes por ciclo completo do garbage collection;</li> 
 <li>Embora o garbage collector esteja executando simultaneamente, o rendimento do aplicativo &eacute; reduzido (geralmente em 50%);</li> 
 <li>O tempo total (e ciclos de CPU) que a JVM gasta para realizar o garbage collection via CMS &eacute; consideravelmente maior que a coleta paralela.</li> 
</ol>
<p>Dependendo das circunst&acirc;ncias da aplica&ccedil;&atilde;o, vale a pena pagar esse pre&ccedil;o ou n&atilde;o. Mas n&atilde;o existe nada que seja de gra&ccedil;a. O coletor CMS &eacute; um pe&ccedil;a de engenharia not&aacute;vel, mas tamb&eacute;m n&atilde;o &eacute; a solu&ccedil;&atilde;o de todos os problemas.</p>
<p>Ent&atilde;o, antes de concluir que o CMS &eacute; sua estrat&eacute;gia correta de garbage collection, determine se as pausas &quot;stop-the-world&quot; do coletor Parallel Old s&atilde;o inaceit&aacute;veis e n&atilde;o podem ser otimizadas. Por fim, tenha certeza de que todas as m&eacute;tricas s&atilde;o obtidas a partir de um sistema equivalente ao de produ&ccedil;&atilde;o.</p>
<p><strong>9. Aumentar o tamanho do heap resolve seus problemas de mem&oacute;ria</strong></p>
<p>Quando uma aplica&ccedil;&atilde;o est&aacute; com problemas e o garbage collector &eacute; o suspeito, muitos ir&atilde;o dizer para aumentar o tamanho do heap. Sob algumas circunst&acirc;ncias, isso pode produzir resultados a curto prazo e dar tempo para uma corre&ccedil;&atilde;o mais apropriada. No entanto, sem um completo entendimento das causas do problema de desempenho, essa estrat&eacute;gia pode na verdade tornar o problema ainda pior.</p>
<p>Considere uma aplica&ccedil;&atilde;o mal constru&iacute;da que cria muitos objetos de dom&iacute;nio com um tempo de vida m&eacute;dio de dois a tr&ecirc;s segundos. Se a taxa de aloca&ccedil;&atilde;o &eacute; alta o suficiente, o garbage collection pode ocorrer t&atilde;o rapidamente que os objetos s&atilde;o promovidos para a &aacute;rea <a href="http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html">tenured (ou old) generation</a>. Uma vez nessa &aacute;rea, os objetos de dom&iacute;nio morrem quase que imediatamente, mas eles n&atilde;o s&atilde;o coletados at&eacute; o pr&oacute;ximo garbage collection completo.</p>
<p>Se aument&aacute;ssemos o tamanho do heap para essa aplica&ccedil;&atilde;o, o que estar&iacute;amos na verdade fazendo &eacute; adicionando mais espa&ccedil;o para objetos de dom&iacute;nio com um tempo de vida relativamente curto se propagar e morrer. Isso pode tornar o tamanho das pausas do stop-the-world ainda pior e sem nenhum benef&iacute;cio para a aplica&ccedil;&atilde;o.</p>
<p>Entender o funcionamento da aloca&ccedil;&atilde;o de objetos e o seu tempo de vida antes de mudar o tamanho do hep ou ajustar outros par&acirc;metros &eacute; essencial. Fazer essas coisas sem nenhuma avalia&ccedil;&atilde;o pode tornar o problema ainda pior. A informa&ccedil;&atilde;o sobre a distribui&ccedil;&atilde;o de objetos na &aacute;rea tenured pelo garbage collector &eacute; muito importante.</p>
<h2>Conclus&atilde;o</h2>
<p>Em se tratando de otimiza&ccedil;&atilde;o de performance em Java, a intui&ccedil;&atilde;o &eacute; muitas vezes enganosa. Necessitamos de dados emp&iacute;ricos e ferramentas para nos ajudar a visualizar e compreender o comportamento da plataforma.</p>
<p>O garbage collections &eacute;, talvez, o melhor exemplo disso. O subsistema do garbage collection tem um incr&iacute;vel potencial para otimiza&ccedil;&atilde;o e para gerar dados que guiam essas otimiza&ccedil;&otilde;es. Em contra partida, os dados produzidos pelas aplica&ccedil;&otilde;es de produ&ccedil;&atilde;o s&atilde;o muito dif&iacute;ceis de fazerem sentido sem recorrer a ferramentas</p>
<p>O padr&atilde;o para a execu&ccedil;&atilde;o de qualquer processo Java (em desenvolvimento ou produ&ccedil;&atilde;o) deve ser sempre com pelo menos essas flags:</p>
<p>-verbose:gc (imprime os logs do GC)</p>
<p>-Xloggc: (para um log mais completo do GC)</p>
<p>-XX:+PrintGCDetails (para uma sa&iacute;da mais detalhada)</p>
<p>-XX:+PrintTenuringDistribution (imprime os limites de tenuring assumidos pela JVM)</p>
<p>e ent&atilde;o usar uma ferramenta para analizar os logs - tanto scripts escritos &agrave; m&atilde;o quanto gera&ccedil;&atilde;o de gr&aacute;ficos, ou uma ferramenta visual como o GCViewer (open-source) ou Censum jClarity.</p>
<p>Sobre o autor:</p>
<p><strong><img vspace="3" hspace="3" align="left" _p="true" _href="img://Ben-Evans.jpg" alt="" src="http://www.infoq.com/resource/articles/9_Fallacies_Java_Performance/pt/resources/Ben-Evans.jpg" />Ben Evans</strong> &eacute; o CEO da jClarity, uma startup que desenvolve ferramentas de desempenho para ajudar equipes de desenvolvimento e opera&ccedil;&atilde;o. Ele &eacute; um dos organizadores do LJC (London JUG) e membro do Comit&ecirc; Executivo do JCP, no qual ajuda a definir padr&otilde;es para o ecossistema Java. Ele tamb&eacute;m &eacute; um Java Champion; JavaOne Rockstar; co-autor do livro &quot;The Well-Grounded Java Developer&quot; e palestra regularmente sobre a plataforma Java, performance, concorr&ecirc;ncia e t&oacute;picos relacionados.</p>
<p>&nbsp;</p><br><br><br><br><br><br></body></html>