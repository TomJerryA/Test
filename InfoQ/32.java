<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Asynchronous Gotchas in C#</h3><p>Sometimes the best way to understand pitfalls in one language is to see how another language prevents them. Tomas Petricek, author of Real-World Functional Programming, discusses six common mistakes found in asynchronous C# code and demonstrates how F# makes them less likely to occur.</p> 
<p>While we encourage you read his entire article, titled <a href="http://tomasp.net/blog/csharp-async-gotchas.aspx">Async in C# and F#: Asynchronous gotchas in C#</a>, here is a brief synopsis of Tomas covers.</p> 
<p><strong>Async does not run asynchronously</strong>: Only code that appears after the first await statement is run asynchronously.</p> 
<p><strong>Ignoring results</strong>: Forgetting to await on the task returned by a function can result in out-of-order execution.</p> 
<p><strong>Async void methods</strong>: Asynchronous functions that return “async void” instead of “async Task” cannot be awaited, effectively causing the same problem as ignoring results.</p> 
<p><strong>Async void lambda functions</strong>: This occurs when a function accepts an Action delegate but not a Func&lt;…, Task&gt; delegate. Again, the async function is not going to be awaited on.</p> 
<p><strong>Nesting of tasks</strong>: In the statement “await Task.Factory.StartNew(async () =&gt; { await Task.Delay(1000); });” the first and second await statements are completely unrelated. This means the first await will complete before second await, and the associated 1000 ms delay, are honored.</p> 
<p><strong>Not running asynchronously</strong>: By using Task.Wait(), the entire call stack can be forced into a synchronous mode.</p> 
<p>For those of you unfamiliar with F#, you may be surprised to learn that async workflows in F# are not based on the Task and Task&lt;T&gt; types. Instead, F# uses its own type known as Async&lt;T&gt;.</p> 
<p id="lastElm"></p><br><br><br><br><br><br></body></html>