<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Weathr, a Comprehensive Demonstration of C++ 14, DirectX, and XAML</h3><p>Most technology demonstrations tend to be fairly light weight, showing only a couple key concepts in a fairly trivial application. Weathr is different in that it is a fully functional 3D weather map complete with live service integration and semantic zoom.</p>
<p>The core of <a href="http://weathr.codeplex.com/">Weathr</a> is an ISO C++ using modern coding conventions. Among other things that means no use of the keywords new and delete. Instead nearly everything is handled through the combination of shared, unique, and weak smart pointers.</p>
<p>The user interface is built on a combination of DirectX, for 3D components, and XAML. The later requires the use of C++/CX, the language extension Microsoft created specifically for WinRT based applications.</p>
<p>Another technology being showcased is PPL or <a href="http://msdn.microsoft.com/en-us/library/dd492427.aspx#task_class">Parallel Patterns Library</a>. This allows for the use of asynchronous methods that are chained together using lambda expressions. PPL is used mainly to interact with Bing Maps and World Weather Online via the <a href="http://msdn.microsoft.com/en-us/library/jj969455.aspx">C++ REST SDK</a>. Memory management for asynchronous can be tricky so Thomas Petchel writes,</p>
<blockquote> 
 <p>Another pattern I’ve discovered occurs when you have a chain of asynchronous tasks and one task creates an object or resource, and another, subsequent, task uses that resource. Although you can often simply create the resource in one task and pass it to its subsequent task, this is not always possible. The issues here are that of lifetime and indirection – whether the object has a C++ or C++/CX type, because we’re working asynchronously, the calling function that sets up the background work will soon exit, and thus any objects allocated on the stack will fall out of scope. To keep objects shared among tasks alive, you must capture smart pointers (typically, a shared_ptr for C++ and C++/CX objects) in all lambdas (or functors) that reference them. By using shared_ptr, you create a level of indirection that enables the object to be allocated (e.g. written to) in one task and used (e.g. read) by a subsequent task.</p> 
</blockquote>
<p>Ensuring that the async callbacks are being run on the correct thread is another issue. Thomas has this tip for verifying that is occurring,</p>
<blockquote> 
 <p>In Debug builds, record the thread ID of the ASTA thread at startup. In each task continuation, assert that we’re either running on the main (ASTA) thread or a background thread.</p> 
 <p>In task continuations, specify explicitly whether to run on the current context (e.g. the context that established the task chain, which might be the ASTA thread or MTA thread) or on a background (MTA) context.</p> 
</blockquote>
<p>Other techniques and technologies explored in this sample application include HTTP request throttling, semantic zoom, <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.input.gesturerecognizer.aspx">gesture recognition</a>, and Windows 8 live tiles.</p>
<p><a href="http://weathr.codeplex.com/">Weathr</a> is available on CodePlex under the Apache 2 license.</p><br><br><br><br><br><br></body></html>