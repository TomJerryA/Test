<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>使用TPL DataFlow在C#中轻松创建Actor</h3><p>对于某些设计问题，Actor可以让一切变得不同。<a href="http://en.wikipedia.org/wiki/Actor_model">Actor</a>是一种可以响应和发送消息的独立实体。某种程度上，它就像是在另一个进程中运行属于它自己的小程序。但对于没有原生支持Actor的语言来说，构建Actor可能会非常困难。</p>
<p>出现的最主要的问题是线程管理。我们通常并不想拦截消息发送者的线程，因为那会给人一种方法调用的语义。且为每个Actor分配一个单独的线程并不会使程序比以前扩展多少，而在上下文切换时，线程就成了一个真正的问题。</p>
<p>Johan Olsson在TPL DataFlow的基础上构建了自己的Actor库，为C#解决了这一困境。TPL DataFlow旨在通过异步方法将操作连接在一起。在Block之间传递的消息可能会被缓存、分组、分离、转换，或根据应用程序的语义和性能需要进行其他操作。</p>
<p>该框架的核心是一个封装了ActionBlock的抽象类Actor。ActionBlock在内部处理所有的线程问题，开发者不需要关心线程或任务。之所以是线程安全的，是因为ActionBlock默认会被序列化。如果同时发送两条消息，ActionBlock会缓存第二条消息，直到第一条消息处理完毕。这个行为可以通过<a href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.dataflow.executiondataflowblockoptions(v=vs.110).aspx">ExecutionDataflowBlockOptions</a>进行修改。</p>
<p>你可以在Johan Olssion的“<a href="http://www.jayway.com/2013/11/15/an-actor-model-implementation-in-c-using-tpl-dataflow/">使用TPL DataFlow在C#中实现Actor模型</a>”的文章中了解他的工作，并查看示例代码。</p>
<p><b>查看英文原文：</b><a href="http://www.infoq.com/news/2013/11/DataFlow-Actor">Actors Made Easy with C# and TPL DataFlow</a></p><br><br><br><br><br><br></body></html>