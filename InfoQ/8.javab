<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Contrasting Backbone and Angular</h3><p>Contrasting ideas and tools is a great way to understand them better.</p>
<p>In this article I will go down the list of the things we have to deal with day to day when building web applications, and show how Backbone and Angular can help with each of them.</p>
<h2>What We are Trying to Solve</h2>
<p>Most of the things we do as web developers fall into one of the following categories:</p>
<ul> 
 <li> <p>Implementing business logic</p> </li> 
 <li> <p>Constructing the DOM</p> </li> 
 <li> <p>Implementing view logic (declarative and imperative)</p> 
  <div id="lowerFullwidthVCR"></div> </li> 
 <li> <p>Syncing up the model and view</p> </li> 
 <li> <p>Managing complex UI interactions</p> </li> 
 <li> <p>Managing state and routing</p> </li> 
 <li> <p>Creating and wiring up components</p> </li> 
</ul>
<p>Not surprisingly most client-side frameworks address these in one way or another.</p>
<h2>Backbone</h2>
<p>Let's start by looking at what Backbone gives us to solve these problems.</p>
<table width="70%" cellspacing="0" cellpadding="0" border="1" align="center"> 
 <tbody> 
  <tr> 
   <td width="250" valign="top"> <p><small>Business Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>Backbone Models and Collections</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Constructing DOM</small></p> </td> 
   <td width="250" valign="top"> <p><small>Handlebars</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Declarative View Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>Backbone Views</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Imperative View Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>Backbone Views</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Sync up Views and Models</small></p> </td> 
   <td width="250" valign="top"> <p><small>StickIt</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Managing UI Interactions</small></p> </td> 
   <td width="250" valign="top"> <p><small>JS Objects or Marionette Controllers</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Managing State and Routing</small></p> </td> 
   <td width="250" valign="top"> <p><small>Backbone.Router</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Creating and Wiring Up Components</small></p> </td> 
   <td width="250" valign="top"> <p><small>Manually</small></p> </td> 
  </tr> 
 </tbody> 
</table>
<p>For visual people:</p>
<p><img _p="true" _href="img://Imagine1.png" alt="" src="http://www.infoq.com/resource/articles/backbone-vs-angular/en/resources/Imagine1.png" /></p>
<h3>When I Say Backbone...</h3>
<p>Comparing vanilla Backbone with Angular would not be fair. So by Backbone I actually mean Backbone + Marionette + add-ons.</p>
<h3>Business Logic</h3>
<p>A large chunk of the business logic of the application goes into Backbone models and collections. Often these objects correspond to resources on the backend. On top of that, they are used for backing up views.</p>
<p>Having to extend Backbone.Model and Backbone.Collection adds quite a bit of complexity.</p>
<p>First, it separates all domain objects into POJOs and Backbone models. POJOs are used when rendering templates and talking to the server. Backbone models are used when observable properties are needed (e.g., setting up data bindings).</p>
<p>Second, it promotes mutability. Since Backbone does not support observing functions, every computed property has to be reset when any of the source properties changes. This adds a lot of accidental complexity, which results in the code that is hard to understand and test. On top of that, all the dependencies have to be explicitly specified in the form of on(&quot;change:sourceProperty, this.recalculateComputedProperty).</p>
<h3>Constructing the DOM</h3>
<p>Backbone uses template engines to construct the DOM. In theory, you can plug in any engine you want. In practice, though, Mustache and Handlebars are the ones that usually get used for large applications. As a result, templates in Backbone are often logic less and string-based, but they do not have to be.</p>
<p><span style="font-size: 12px;">View Logic</span></p>
<p>The idea of dividing the view logic into imperative and declarative is an old one (goes back to the original MVC pattern). Event handling configuration and data bindings are declarative. Event handling itself, on the other hand, is imperative. Backbone does not draw a strict line between the two. Both go into Backbone.View.</p>
<h3>Syncing Up the Model and View</h3>
<p>Due to the minimalist nature of Backbone, there is no built-in support for data bindings. That is not an issue for small projects, where the view can be made responsible for syncing up the model and the DOM. It, however, can get easily out of control when the application grows.</p>
<p>There are several add-ons available (like Backbone.StickIt) that help unload this burden, so you can focus on complex interactions rather than the trivial model-view synchronization. Most of these add-ons are configured using plain JavaScript, which enables building abstractions on top of them matching the needs of your application.</p>
<p>The downside of using data bindings in Backbone is that they depend on observable properties, whereas template engines use POJOs. Having these two ways of working with the DOM often results in code duplication.</p>
<h3>Managing Complex UI Interactions</h3>
<p>All UI interactions can be split into simple (managed using the <a href="http://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>) and complex (where the <a href="http://martinfowler.com/eaaDev/FlowSynchronization.html">Flow Synchronization</a>) is required).</p>
<p>As mentioned above, simple interactions get handled by Backbone.View using data bindings and event handlers. Since Backbone does not have any prescribed solutions for orchestrating complex UI interactions, you are free to choose the one that fits your application the best. Some use Backbone.View, but I recommend against doing that. Backbone.View already does too much. <a href="http://victorsavkin.com/post/49767352960/supervising-presenters">Supervising Presenter</a> is the pattern I tend to use for managing complex interactions.</p>
<h3>Managing State and Routing</h3>
<p>Backbone comes with a very simple implementation of the router. It provides no support for managing view and the application state. Everything has to be done manually. That is why in practice other libraries (e.g., router.js) are often get used instead of the built-in router.</p>
<h3>Creating and Wiring up Components</h3>
<p>In Backbone you get the freedom to create and wire up components in the way that fits your application best. The downside is the amount of boilerplate you have to write, in addition to the discipline required to keep the code well organized.</p>
<h2>Angular</h2>
<p>Now, let's contrast it with how Angular approaches the same problems.</p>
<p> </p>
<table width="70%" cellspacing="0" cellpadding="0" border="1"> 
 <tbody> 
  <tr> 
   <td width="250" valign="top"> <p><small>Business Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>JS objects</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Constructing DOM</small></p> </td> 
   <td width="250" valign="top"> <p><small>Directives</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Declarative View Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>Directives</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Imperative View Logic</small></p> </td> 
   <td width="250" valign="top"> <p><small>Controllers</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Sync up Views and Models</small></p> </td> 
   <td width="250" valign="top"> <p><small>Built-in mechanism</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Managing UI Interactions</small></p> </td> 
   <td width="250" valign="top"> <p><small>Controllers</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Managing State and Routing</small></p> </td> 
   <td width="250" valign="top"> <p><small>AngularUI Router</small></p> </td> 
  </tr> 
  <tr> 
   <td width="250" valign="top"> <p><small>Creating and Wiring Up Components</small></p> </td> 
   <td width="250" valign="top"> <p><small>Dependency Injection</small></p> </td> 
  </tr> 
 </tbody> 
</table>
<p></p>
<p>For visual people:</p>
<p><img _p="true" _href="img://1Imagine2.png" alt="" src="http://www.infoq.com/resource/articles/backbone-vs-angular/en/resources/1Imagine2.png" /></p>
<h3>Business Logic</h3>
<p>Since Angular does not use observable properties, it does not restrict you when it comes to implementing the model. There is no class to extend and no interface to comply to. You are free to use whatever you want (including existing Backbone models). In practice, most developers use plain old JavaScript objects, which yields the following benefits:</p>
<ul> 
 <li>All domain objects are framework-agnostic, which makes reusing them across applications easier.</li> 
 <li>They are close to the data that is being sent over the wire, which simplifies the client-server communication.</li> 
 <li>They are used to render views, so there is no need to implement toJSON.</li> 
 <li>Computed properties are modeled as functions.</li> 
</ul>
<h3>The Template and View</h3>
<p>The template in Angular is a piece of the DOM before it gets compiled. During the compilation Angular transforms that DOM subtree and attaches some JavaScript to it. The result of this compilation is another DOM subtree, which is the view. In other words, you do not create the view yourself. Angular does it by compiling the template.</p>
<h3>Constructing the DOM</h3>
<p>Backbone clearly separates the construction of the DOM from the view logic. The first one is done using a template engine; the second one is done via data bindings and imperative DOM updates. Angular, on the other hand, does not separate the two. It uses the same mechanism, directives, to construct the DOM and define declarative view behavior.</p>
<h3>View Logic</h3>
<p>Angular, however, draws a line between declarative and imperative view logic. The former is done by the view, and the latter by the controller.</p>
<p>This separation may seem arbitrary, but it is actually quite important.</p>
<p>First of all, it clearly identifies what has to be unit tested. The declarative logic encoded in the template (such as using ng-repeat) does not need tests. Writing tests for the controller, on the other hand, is usually a good idea.</p>
<p>Second, all dependencies go in one direction: from the view to the controller. Thus, the controller is unaware of the view or the DOM. It enables code reuse and simplifies unit testing. Contrast it with Backbone.View that often manipulates DOM nodes and rerenders large parts of it using template engines.</p>
<h3>Syncing Up the Model and View</h3>
<p>Angular has a built-in support for data bindings, which, in contrast to most client-side frameworks, does not rely on observable properties and, instead, uses dirty checking.</p>
<p><img _p="true" _href="img://1Imagine3.png" alt="" src="http://www.infoq.com/resource/articles/backbone-vs-angular/en/resources/1Imagine3.png" /></p>
<p>The Angular dirty checking approach has some nice properties:</p>
<ul> 
 <li>The model is oblivious of the fact that it is being observed.</li> 
 <li>There is no need to specify dependencies between observable properties.</li> 
 <li>Functions are observable as well.</li> 
</ul>
<p>But it also has some drawbacks:</p>
<ul> 
 <li>When integrating third-party components or libraries, you have to make sure that Angular sees the changes those make to your models.</li> 
 <li>In some situations it can have a negative effect on performance.</li> 
</ul>
<h3>Managing Complex UI Interactions</h3>
<p>As already mentioned, the controller is responsible for implementing the imperative logic of UI elements. On top of that, it can be used as a <a href="http://victorsavkin.com/post/49767352960/supervising-presenters">Supervising Presenter</a> to coordinate complex UI interactions.</p>
<p><img _p="true" _href="img://Imagine4.png" alt="" src="http://www.infoq.com/resource/articles/backbone-vs-angular/en/resources/Imagine4.png" /></p>
<h3>Managing State and Routing</h3>
<p>Similar to Backbone, the built-in router in Angular is very basic and not sufficient for building real applications. Thankfully, there is the AngularUI Router project. It manages the application state, views, and supports nesting. In other words, it does everything you would expect from the router. But you are not limited to it. As with Backbone, other routing libraries (e.g., router.js) can be used as well.</p>
<h3>Creating and Wiring up Components</h3>
<p>Angular has an IoC container, which, like dependency injection in general, forces you to write modular code. It improves reuse, testability, and helps get rid of a lot of boilerplate. The downside is increased complexity and reduced control over how components get created.</p>
<h2>Summing Up</h2>
<p>That was a short overview of how Backbone and Angular address the main problems we deal with everyday when building web applications. The two frameworks have very different solutions to some of these problems. Backbone gives you more options when it comes to rendering templates, setting up data bindings, or wiring up components. Angular, on the other hand, has prescribed solutions for these problems, but is less opinionated when it comes to how you build your models or controllers.</p>
<h2>About the Author</h2>
<p><strong><img vspace="3" align="left" hspace="3" _p="true" _href="img://victor_savkin_picture.jpg" alt="" src="http://www.infoq.com/resource/articles/backbone-vs-angular/en/resources/victor_savkin_picture.jpg" /></strong></p>
<p><strong>Victor Savkin</strong> is a software engineer at <a href="http://nulogy.com/">Nulogy</a>. He is interested in functional programming, the web platform, and Domain Driven Design. He works on large applications written in JavaScript. Being a language nerd he spends a lot of his time playing with Smalltalk, JS, Dart, Scala, Haskell, Clojure, and Ioke. He blogs about building large applications in Ruby and JS at <a href="http://victorsavkin.com/">victorsavkin.com</a>. You can follow Victor on Twitter <a href="http://twitter.com/victorsavkin">@victorsavkin</a>.</p><br><br><br><br><br><br></body></html>