<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Discover and Diagnose Java Concurrency Problems Using Contemplate's ThreadSafe</h3><p>Exploiting the benefits of multicore hardware has proven to be difficult and risky. Writing Java software that <i>correctly</i> and <i>safely</i> makes use of concurrency requires careful thought to take into account the effects of running in a concurrent environment. Software that incorrectly accounts for concurrency can contain intermittent defects that elude even the most rigorous testing regimes.</p>
<p>Static analysis offers a way to detect and fix concurrency defects before programs are ever executed. It accomplishes this by analysing the source code or compiled bytecode of the program to discover latent bugs hidden within code, long before it is executed.</p>
<p>Contemplate's <a href="http://www.contemplateltd.com/threadsafe">ThreadSafe Solo</a> is a commercial static analysis plugin for Eclipse, designed specifically to discover and help diagnose difficult concurrency bugs lurking within Java programs. By being focussed on concurrency bugs, ThreadSafe can find bugs that other static analysis tools, both commercial and freely available, often miss or are not designed to look for. As far as we have been able to determine, none of the defects in the examples below are caught by any other Java static analysis tool.</p>
<p>In this article I'll introduce ThreadSafe by describing a selection of concurrency bugs, in example and real-world OSS code, and show how ThreadSafe's advanced static analysis and tight Eclipse integration can be used to discover and diagnose these bugs, long before they have a chance to reach production. To try out ThreadSafe on your own code, you can download a free trial copy from the <a href="http://www.contemplateltd.com/">Contemplate website</a></p>
<p>Most of the concurrency bugs that I use as examples in this article are instances of when developers have not correctly synchronized accesses to shared data. This kind of bug is simultaneously the most common form of concurrency bug in Java code, and one of the most difficult to detect during code review or testing. ThreadSafe can detect many instances of cases when synchronization has been used incorrectly, and, as I show below, also provide the developer with crucial contextual information to help diagnose the problem.</p>
<h2>Correct Synchronization Becoming Incorrect Over Time</h2>
<p>When designing a class whose instances are intended to be invoked concurrently by multiple threads, developers must put careful thought into how concurrent accesses to the same instance ought to be correctly handled. Even when a good design has been found, it is not easy to ensure that a carefully designed synchronization protocol is respected by future additions to the code. ThreadSafe can help to point out cases when existing synchronization designs are violated by newly written code.</p>
<div id="lowerFullwidthVCR"></div>
<p>For basic synchronization tasks, Java provides several different facilities, including the synchronized keyword and the more flexible java.util.concurrent.locks package.</p>
<p>As a simple example using Java's in-built synchronization facilities to provide safe concurrent access to a shared resource, consider the following code snippet, implementing a toy &quot;Bank account&quot; class.</p>
<pre>
public class BankAccount {<br />
   protected final Object lock = new Object();<br />
   private int balance;<br />
   protected int readBalance() {<br />       return balance;<br />   }<br />
   protected void adjustBalance(int adjustment) {<br />       balance = balance + adjustment;<br />   }<br />
   // ... methods that synchronize on &quot;lock&quot; while calling<br />   // readBalance() or adjustBalance(..)<br />
}</pre>
<p>The developer of this class has decided to provide access to the balance field via two internal API methods readBalance() and adjustBalance(). These methods have been given protected visibility so that they may be accessed from sub-classes of BankAccount. Since any particular publicly exposed operation on BankAccount instances may involve a complex sequence of calls to these methods, which ought to be executed as a single atomic step, the internal API methods do not perform any synchronization themselves. Instead, the caller of these methods is expected to synchronize on the object stored in the lock field to ensure mutual exclusion and atomicity of updates to the balance field.</p>
<p>As long as programs are kept small, and the design of a program can be kept in a single developer's head, there is a relatively small risk of concurrency-related problems. However, in any real-world project, the original carefully designed program will be extended to accomodate new functionality, often by engineers new to the project.</p>
<p>Now imagine that some time after the original code was written, another developer writes a sub-class of BankAccount to add some new optional functionality. Unfortunately, the new developer is not necessarily aware of the synchronization design put in place by the previous developer, and does not realise that the methods readBalance() and adjustBalance(..) must not be called without first synchronizing on the object stored in the field lock.</p>
<p>The code that the new engineer writes for a sub-class of BankAccount looks like the following:</p>
<pre>
public class BonusBankAccount extends BankAccount {

    private final int bonus;

    public BonusBankAccount(int initialBalance, int bonus) {
        super(initialBalance);

        if (bonus &lt; 0)
            throw new IllegalArgumentException(&quot;bonus must be &gt;= 0&quot;);

        this.bonus = bonus;<br />    }<br />
    public void applyBonus() {<br />        adjustBalance(bonus);<br />    }<br />}</pre>
<p>The problem lies in the implementation of the applyBonus() method. In order to correctly adhere to the synchronization policy of the BankAccount class, applyBonus() ought to have synchronized on lock while calling adjustBalance(). Unfortunately, no synchronization is performed and so the author of BonusBankAccount has introduced a serious concurrency defect.</p>
<p>As serious as this defect is, detecting it in testing or even production can be very difficult. This defect will manifest as inconsistent account balances, as updates to the balance field performed by threads are not made visible to other threads due to the lack of synchronization. The program will not crash, but will silently produce incorrect results, in an untraceable way. A particular run of an experiment with four threads that concurrently applied bonuses and credits to the same account lost 11 out of 40,000 transactions when run on quad-core hardware.</p>
<p>ThreadSafe can be used to identify concurrency defects like the example introduced into the BonusBankAccount class. Running ThreadSafe's Eclipse plugin on the two classes above produces the following output:</p>
<p><b><small>(Click on the image to enlarge it)</small></b></p>
<p><a href="/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig1b.png" _href="resource://Fig1b.png"><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig1b-small.png" alt="" _href="img://Fig1b-small.png" _p="true" /></a></p>
<p><b><small>Screenshot of the ThreadSafe view in Eclipse</small></b></p>
<p>This screenshot shows that ThreadSafe has discovered that the field balance has been inconsistently synchronised.</p>
<p>To get more context information, we can ask ThreadSafe to show us the accesses to the balance field, and also to show us the locks that were held for each access:</p>
<p><b><small>(Click on the image to enlarge it)</small></b></p>
<p><a href="/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig2b.png" _href="resource://Fig2b.png"><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig2b-small.png" alt="" _href="img://Fig2b-small.png" _p="true" /></a></p>
<p><b><small>Screenshot of ThreadSafe's Accesses View</small></b></p>
<p>From this view, we can easily see that the accesses to the balance field in the adjustBalance() method are inconsistently synchronized. Using Eclipse's call hierarchy view (here accessible by right clicking on the adjustBalance() line in the view), we can see where the offending code path comes from.</p>
<p><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig3b.png" alt="" _href="img://Fig3b.png" _p="true" /></p>
<p><b><small>Screenshot of Eclipse's call hierarchy showing the BonusBankAccount call to adjustBalance</small></b></p>
<h2>Incorrect Synchronization While Accessing Collections</h2>
<p>The BankAccount class above demonstrates a very simple case of incorrect synchronization when accessing fields. Of course, most Java objects are composed of other objects, often in the form of collections of objects. Java provides a rich assortment of collection classes, each with its own requirements on whether or not synchronization is required for concurrent access to the collection.</p>
<p>Inconsistent synchronization on collections can be particularly harmful to program behaviour. While incorrectly synchronizing accesses to a field may &quot;only&quot; result in missed updates or stale information, incorrectly synchronizing accesses to collections that have not been designed for concurrent use can lead to violations of the collections' internal invariants. Violation of a collection's internal invariants may not immediately cause visible effects, but may cause odd behaviour, including infinite loops or corrupted data, at a later point in the program's execution.</p>
<p>An example of inconsistent use of synchronization when accessing a shared collection is present in <a href="http://jmeter.apache.org/">Apache JMeter</a>, the popular open source tool for testing application performance under load. Running ThreadSafe on version 2.10 of Apache JMeter produces the following warning:</p>
<p><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig4b.png" alt="" _href="img://Fig4b.png" _p="true" /></p>
<p><b><small>Screenshot of the inconsistent synchronisation warning on the collection stored in the field RespTimeGraphVisualizer.internalList : List&lt;RespTimeGraphDataBean&gt;</small></b></p>
<p>As before, we can ask ThreadSafe for more information on this report by showing us the accesses to this field along with the locks that are held:</p>
<p><b><small>(Click on the image to enlarge it)</small></b></p>
<p><a href="/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig5b.png" _href="resource://Fig5b.png"><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig5b-small.png" alt="" _href="img://Fig5b-small.png" _p="true" /></a></p>
<p><b><small>Screenshot of ThreadSafe's Accesses View investigating internalList</small></b></p>
<p>Now we can see that there are three methods that access the collection stored in the field internalList. One of these methods is actionPerformed, which will be invoked by the Swing Gui framework on the UI thread.</p>
<p>Another method that accesses the collection stored in internalList is add(). Again, by investigating the possible callers of this method, we can see that it is indeed called from the run() method of a thread that is not the main UI Thread of the application, indicating that synchronization ought to have been used.</p>
<p><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig6b.png" alt="" _href="img://Fig6b.png" _p="true" /></p>
<p><b><small>Screenshot of Eclipse's call hierarchy showing the run() method</small></b></p>
<h2>Missing Synchronization while using the Android Framework</h2>
<p>The concurrent environment in which an application may run is almost never under the complete control of the application developer. Frameworks invoke various parts of applications in response to user, network, or other external events, and often have implicit requirements about which methods may be invoked on which threads.</p>
<p>An example of the incorrect use of frameworks is visible in recent Git versions of the <a href="http://code.google.com/p/k9mail/">K9Mail</a> email client for Android (we provide a link to the precise version tested at the end of this article). Running ThreadSafe on K9Mail brings up the following warning, indicating that the field mDraftId appears to be accessed from an Android background thread, and another thread, with <i>no</i> synchronization.</p>
<p><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig7b.png" alt="" _href="img://Fig7b.png" _p="true" /></p>
<p><b><small>ThreadSafe's report on unsynchronized accesses from an asynchronous callback method</small></b></p>
<p>Using ThreadSafe's accesses view, we can see that the field mDraftId has been accessed from a doInBackground method.</p>
<p><b><small>(Click on the image to enlarge it)</small></b></p>
<p><a href="/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig8b.png" _href="resource://Fig8b.png"><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig8b-small.png" alt="" _href="img://Fig8b-small.png" _p="true" /></a></p>
<p><b><small>ThreadSafe's Accesses View showing information about individual accesses to mDraftId</small></b></p>
<p>The doInBackground method is part of the Android framework's AsyncTask facilities for running time-consuming tasks in the background separately from the main UI thread. Correct use of AsyncTask.doInBackground(..) can ensure that Android applications remain responsive to user input, but care must be taken to ensure that interaction between the background thread and the main UI thread is correctly synchronized.</p>
<p>Investigating further, using Eclipse's call hierarchy feature, we discover that the onDiscard() method, which also accesses the mDraftId field, is called by the onBackPressed() method. This method is in turn always invoked by the Android framework on the main UI thread, <i>not</i> the background thread for running AsyncTasks, indicating the presence of a potential concurrency defect.</p>
<h2>Incorrect use of Synchronised Data Structures</h2>
<p>For relatively simple scenarios, Java's built-in synchronized collections facility can provide the right level of thread safety without too much effort.</p>
<p>Synchronized collections wrap existing collections, providing the same interface as the underlying collection, but synchronizing all accesses on the synchronized collection instance. Synchronized collections are created by using calls to special static methods similar to the following:</p>
<pre>
private List&lt;X&gt; threadSafeList =
         Collections.synchronizedList(new LinkedList&lt;X&gt;());</pre>
<p>Synchronized collections are relatively easy to use compared to some other thread-safe data structures, but there are still subtleties involved in their use. A common mistake with synchronized collections is to iterate over them without first synchronizing on the collection itself. Since exclusive access to the collection has not been enforced, it is possible for the collection to be modified by other threads while iteration over its elements takes place. This may result in ConcurrentModificationExceptions being thrown intermittently at runtime, or non-deterministic behaviour, depending on the exact scheduling of threads. The requirement to synchronize is clearly documented in the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#synchronizedList%28java.util.List%29">JDK API documentation</a>:&nbsp;</p>
<blockquote>
 It is imperative that the user manually synchronize on the returned list when iterating over it: 
 <pre>
List list = Collections.synchronizedList(new ArrayList());
   ...<br />synchronized (list) {<br />    Iterator i = list.iterator(); // Must be in synchronized block
    while (i.hasNext())<br />        foo(i.next());<br />}</pre> Failure to follow this advice may result in non-deterministic behavior.
</blockquote>
<p>Nevertheless, it is easy to forget to synchronize when iterating over a synchronized collection, especially because they have exactly the same interface as normal, unsynchronized, collections.</p>
<p>An example of this kind of mistake can be found in version 2.10 of <a href="http://jmeter.apache.org/">Apache JMeter</a>. ThreadSafe reports the following instance of &quot;Unsafe iteration over a synchronized collection&quot;:</p>
<p><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/Fig9b.png" alt="" _href="img://Fig9b.png" _p="true" /></p>
<p><b><small>Screenshot of ThreadSafe's unsafe iteration report</small></b></p>
<p>The line reported by ThreadSafe contains the following code:</p>
<pre>
Iterator&lt;Map.Entry&lt;String, JMeterProperty&gt;&gt; iter = propMap.entrySet().iterator();</pre>
<p>Here, the iteration is over a <i>view</i> on the synchronized collection, created by the call to entrySet(). Since views on collections are &quot;live&quot;, this code has the same potential for non-deterministic behaviour and ConcurrentModificationExceptions as discussed above.</p>
<h2>Conclusions</h2>
<p>I have presented a small selection of concurrency defects commonly found in real-world Java programs, and shown how Contemplate's ThreadSafe can be used to discover and diagnose them.</p>
<p>In general, static analysis tools offer a promising way to mitigate against the risk of defects lurking within existing, and new, Java code. Static analysis complements traditional software quality techniques such as testing and code review by providing a quick and repeatable way of scanning code for well-known but subtle and serious bugs. Concurrency bugs in particular are extremely difficult to reliably find by testing, due to their dependence on the non-deterministic scheduling of concurrent threads.</p>
<p>ThreadSafe is capable of discovering a range of other concurrency defects, including atomicity errors arising from incorrect use of the concurrent collections framework, and potential deadlocks from the misuse of blocking methods. The <a href="http://www.contemplateltd.com/threadsafe/maintaining-safe-concurrent-code-with-threadsafe">ThreadSafe technical briefing</a> and <a href="http://www.youtube.com/watch?v=e5vgO684luE&amp;list=PLKSPjCqehrag5v9362ylOk5AioCXhvMNb">demonstration video</a> provide further examples of the subtle but potentially catastrophic defects that ThreadSafe can detect.</p>
<h2>Resources</h2>
<ul> 
 <li><a href="http://www.contemplateltd.com/">The Contemplate Website</a> - including further information about ThreadSafe, information on how to request a trial version, and how to buy it.</li> 
 <li><a href="http://jmeter.apache.org/download_jmeter.cgi">Downloads for Apache JMeter 2.10</a> - place to download the source code used for the demonstration above.</li> 
 <li><a href="https://github.com/k9mail/k-9">The k9mail Git repository</a> - place to download the source code of K9Mail. The version used for this article has commit SHA1 id: <a href="https://github.com/k9mail/k-9/tree/b500047e426baa0807570c2f2836d0cf9ba6cc19">b500047e426baa0807570c2f2836d0cf9ba6cc19</a></li> 
</ul>
<h2>About the Author</h2>
<p><strong><img src="http://www.infoq.com/resource/articles/Java-Concurrency-Static-Analysis-with-ThreadSafe/en/resources/bob-100x100.jpg" vspace="3" hspace="3" align="left" alt="" _href="img://bob-100x100.jpg" _p="true" />Robert Atkey</strong> is a Senior Software Engineer at Contemplate Ltd., where he architects, develops and maintains the core analysis framework. He graduated from Edinburgh University in 2006 with a PhD in Computer Science, and has since worked on practical and theoretical aspects of software, in both academia and industry.</p><br><br><br><br><br><br></body></html>