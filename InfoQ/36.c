<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>JavaScript: Visualize o fluxo de c√≥digo com o TraceGL</h3><p>A Rik Arends lan&ccedil;ou o <a href="https://trace.gl">TraceGL</a>, uma nova ferramenta para depurar aplica&ccedil;&otilde;es JavaScript usando depura&ccedil;&atilde;o por trilhas. A fim de tornar mais f&aacute;cil depurar e entender navegadores complexos e aplica&ccedil;&otilde;es baseadas em <a href="http://nodejs.org">Node.js</a>, a ferramenta captura, visualiza e permite que o usu&aacute;rio navegue na trilha de execu&ccedil;&atilde;o enquanto a aplica&ccedil;&atilde;o est&aacute; sendo executada.</p>
<p><img src="http://www.infoq.com/resource/news/2013/11/tracegl/pt/resources/shot2.png" alt="" _href="img://shot2.png" _p="true" /></p>
<p>O TraceGL consiste em duas partes: um servidor baseado no node.js e um cliente baseado no <a href="http://www.khronos.org/webgl/">WebGL</a> que executa no navegador. O navegador de quatro pain&eacute;is mostra um mini mapa da trilha no topo superior esquerdo, uma parte ampliada da trilha no canto superior direito, o stack-trace no canto inferior esquerdo e o c&oacute;digo no canto inferior direito. Quando visualizado o c&oacute;digo nas vari&aacute;veis, a Interface do Usu&aacute;rio (UI) mostra os valores que a vari&aacute;vel tem no momento. Al&eacute;m disso, os caminhos de execu&ccedil;&atilde;o de c&oacute;digo para fluxo de controle s&atilde;o visualizados.</p>
<p>Para saber mais sobre este projeto, o InfoQ.com conversou com seu criador, Rik Arends.</p>
<p><strong>Porque precisamos do TraceGL, os depuradores integrados aos navegadores n&atilde;o s&atilde;o bons o suficiente?</strong></p>
<blockquote> 
 <p>Depuradores de navegadores foram definitivamente ficando melhor, mas eles operam no modo 'breakpoint/step'. Primeiro, voc&ecirc; tem que saber aonde colocar os breakpoints, e se passar sobre a fun&ccedil;&atilde;o errada tem que come&ccedil;ar tudo novamente. Com a trilha, toda execu&ccedil;&atilde;o &eacute; gravada. Isso significa que ao inv&eacute;s de passar sobre o c&oacute;digo &eacute; poss&iacute;vel ver toda l&oacute;gica de uma s&oacute; vez, todas vari&aacute;veis e argumentos de fun&ccedil;&atilde;o s&atilde;o vis&iacute;veis, podendo usar a busca e visualiza&ccedil;&otilde;es agregadas de dados. Al&eacute;m disso, como isso &eacute; uma grava&ccedil;&atilde;o, n&atilde;o &eacute; necess&aacute;rio interromper o programa. Especialmente com c&oacute;digos baseados em eventos, o comportamento &eacute; diferente se colocar um breakpoint em algum lugar, com o rastreamento o comportamento do c&oacute;digo &eacute; mais natural. E agora a grava&ccedil;&atilde;o pode ser compartilhada, que habilita novas maneiras de ajudar a depura&ccedil;&atilde;o em processos de garantia de qualidade.</p> 
 <p>O TraceGL tem definitivamente me ensinado muito sobre meu pr&oacute;prio c&oacute;digo e bibliotecas como jQuery apenas vagando ao redor do c&oacute;digo.</p> 
</blockquote>
<p><strong>Existe algum tipo de aplica&ccedil;&atilde;o que o TraceGL &eacute; especialmente &uacute;til?</strong></p>
<blockquote> 
 <p>Quanto maior a quantidade de c&oacute;digo, mais agrad&aacute;vel &eacute; ter um rastreador, especialmente se o c&oacute;digo n&atilde;o for todo seu. Use-o em qualquer aplicativo HTML5 razoavelmente complexo e aprenda muitas coisas novas sobre o c&oacute;digo. Ver o que voc&ecirc; faz quando voc&ecirc; move ao redor da interface do usu&aacute;rio &eacute; muito lindo. Entretanto eu tenho que dizer que o TraceGL &eacute; tamb&eacute;m muito &uacute;til para o Node.js. Como ele &eacute; inteiramente direcionado a evento, depurar com breakpoint n&atilde;o &eacute; uma caracter&iacute;stica natural, mas o rastreamento &eacute;. A disponibilidade de uma pilha de fechamento permite-lhe entrar e sair em callbacks clicando na fun&ccedil;&atilde;o, que &eacute; muito &uacute;til. Isso &eacute; como abrir uma janela no servidor e ter condi&ccedil;&otilde;es de ver o que est&aacute; acontecendo.</p> 
</blockquote>
<p><strong>Como o TraceGL trabalha, ele se integra com a VM Javascript?</strong></p>
<blockquote> 
 <p>O TraceGL opera tanto como um proxy quanto fileserver e trabalha por instrumenta&ccedil;&atilde;o no seu Javascript, muito da mesma maneira que o CoffeScript &eacute; compilado para o Javascript. Estou usando o incr&iacute;vel <a href="http://marijnhaverbeke.nl/acorn/">Acorn JS</a> parser do Marijn Haverbeke, e ent&atilde;o modifico o c&oacute;digo sem destru&iacute;-lo. Quando executando este c&oacute;digo modificado, ele grava todo o fluxo do c&oacute;digo sobre uma conex&atilde;o websocket, atrav&eacute;s do n&oacute; processado para a interface de visualiza&ccedil;&atilde;o do usu&aacute;rio. Isso significa que o traceGL n&atilde;o precisa de uma conex&atilde;o para depurar a VM Javascript. Isso pode facilmente rastrear seu c&oacute;digo em um telefone m&oacute;vel, como um backend Node.js.</p> 
</blockquote>
<p><strong>Qual &eacute; a tecnologia usada para implementar a interface do usu&aacute;rio no traceGL?</strong></p>
<blockquote> 
 <p>Como o TraceGL pode obter enormes quantidades de dados cont&iacute;nuos, era necess&aacute;rio mostrar e rolar grandes quantidades de texto. Como um experimento escrevi toda a interface do usu&aacute;rio em webGL, e renderizar todo o texto para est&aacute;ticos como buffer de v&eacute;rtices (<a href="http://en.wikipedia.org/wiki/Vertex_Buffer_Object">Vertex Buffers</a>). Isso significa que quando rola a tela e amplia o zoom existe um pequeno processamento sendo feito no JavaScript como uma simples chamada para renderizar grandes peda&ccedil;os de texto. Implementei um kit b&aacute;sico de manipula&ccedil;&atilde;o da &quot;regi&atilde;o suja&quot; da interface do usu&aacute;rio e escrevi um compilador GLSL para fazer todo o estilo da UI. Ent&atilde;o, com isso n&atilde;o &eacute; mais necess&aacute;rio utilizar CSS para aplicar os estilos, mas &eacute; necess&aacute;rio escrever pequenos fragmentos de sombreamento. Toda a interatividade funciona via raypicking e databinding com o DOM do JavaScript para vari&aacute;veis sombras. Se seguir esse caminho ser&aacute; necess&aacute;rio implementar a manipula&ccedil;&atilde;o das telas de retina, mas isso funciona muito bem. Sou originalmente um programador gr&aacute;fico C++, ser capaz de fazer uma UI do navegador r&aacute;pido sem HTML foi muito animador.</p> 
</blockquote>
<p><strong>O TraceGL funciona com linguagens que compilam para Javascript como o CoffeScript?</strong></p>
<blockquote> 
 <p>O TraceGL pode instrumentar e mostrar a sa&iacute;da de um compilador CoffeScript, mas ainda n&atilde;o tenho suporte para source-maps para ordenadamente mape&aacute;-lo de volta para o c&oacute;digo CoffeeScript original.</p> 
</blockquote>
<p>No entanto o TraceGL n&atilde;o &eacute; um editor ou IDE, mas permite uma &quot;programa&ccedil;&atilde;o ao vivo&quot; similar ao IDE LightTable. Considerando que o LightTable faz isso exibindo resultados de fun&ccedil;&otilde;es individuais em Closure e permite que a edi&ccedil;&atilde;o afete os resultados, com o TraceGL &eacute; poss&iacute;vel continuar usando seu pr&oacute;prio editor e usar a interface do usu&aacute;rio do TraceGL para visualizar tamb&eacute;m o fluxo do c&oacute;digo ao vivo, ou ap&oacute;s a execu&ccedil;&atilde;o.</p>
<p><a href="https://trace.gl/">O TraceGL est&aacute; dispon&iacute;vel</a> por $14,99 d&oacute;lares. Sendo distribu&iacute;do como um simples arquivo JavaScript e executa em qualquer plataforma que consiga executar o Node.js e navegadores que suportam WebGL (principalmente as vers&otilde;es recentes do Chrome e Firefox).</p><br><br><br><br><br><br></body></html>