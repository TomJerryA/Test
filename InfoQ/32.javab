<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Visualizing Java Garbage Collection</h3><p>Garbage Collection, like Backgammon takes minutes to learn and a lifetime to master.</p>
<p>In his talk <a href="http://www.infoq.com/presentations/Visualizing-Java-GC">Visualizing Garbage Collection</a> Master trainer/consultant Ben Evans discusses GC from the ground up.</p>
<p>A brief summary of his talk follows.</p>
<h2>Basics</h2>
<p>When it comes to freeing up memory that is no longer used, GC has largely replaced earlier techniques, such as manual memory management and reference counting.</p>
<p>This is a good thing, as memory management is boring, pedantic bookkeeping that computers excel at whereas people do not. Language runtimes are better at this than humans are.</p>
<p>Modern GC is highly efficient, far more so than manual allocation typical in earlier languages. People from other language backgrounds often focus on GC pauses without fully understanding the context that automatic memory management operates in.</p>
<div id="lowerFullwidthVCR"></div>
<p>Mark &amp; Sweep is the fundamental algorithm used for GC by Java (and other runtimes).</p>
<p>In the Mark &amp; Sweep algorithm you have references pointing from the frames of each stack's thread, which point into program heap. So we start in the stack, follow pointers to all possible references, and then follow those references, recursively.</p>
<p>When you’re done, you have all live objects, and everything else is garbage.</p>
<p>Note that one point people often miss is that the runtime itself also has a list of pointers to every object called the “allocation list” that is maintained by the garbage collector and helps the garbage collector to clean up. So the runtime can always find an object that it created but has not yet collected.</p>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/Fig.png" alt="" _href="img://Fig.png" _p="true" /></p>
<p><b><small>Figure 1</small></b></p>
<p>The stack depicted in the illustration above is just the stack associated with a single application thread; there is a similar stack for each and every application thread, with its own set of pointers into the heap.</p>
<p>If the garbage collector were to attempt to get a snapshot of what’s living while the application was running, then it would be chasing a moving target, and could easily miss some badly timed objects allocations, and could not get an accurate snapshot. Therefore it is necessary to “Stop the World”; i.e. stop the application threads long enough to capture the live object snapshot.</p>
<p>There are two golden rules that the garbage collector must abide by:</p>
<ol> 
 <li>The garbage collector must collect <i>all</i> of the garbage.</li> 
 <li>The garbage collector must never collect any live object.</li> 
</ol>
<p>But these rules are not created equal; if rule 2 would be violated, you would end up with corrupted data.</p>
<p>On the other hand, if rule 1 were violated, and instead we had a system that did not collect all of the garbage all of the time, but rather only collected it eventually, then that could be tolerated, and in fact could be the basis of a garbage collector.</p>
<h2>HotSpot</h2>
<p>Now let’s talk about HotSpot, which is actually a conglomeration of C and C++ as well as a lot of platform-specific assembler.</p>
<p>When people think of an interpreter, they think of a big while-loop with a large switch statement. But the HotSpot interpreter is much more sophisticated than that (for performance reasons). When you start looking at the JDK source code, you realize just how much assembler code is in Hotspot.</p>
<h2>Object Creation&nbsp;</h2>
<p>In Java we allocate a large contiguous amount of space up front, which is what we know as “the heap”. This memory is then managed, purely in user space, by HotSpot.</p>
<p>If you see a Java process that is using a huge amount of system (or kernel) time, then you can rest assured it is not doing garbage collection - because all of our GC memory bookkeeping is done in user space.</p>
<h2>Memory Pools</h2>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/FigA.png" alt="" _href="img://FigA.png" _p="true" /></p>
<p><b><small>Figure 2</small></b></p>
<p>PermGen is the storage area for things like class metadata, that need to remain alive for the life of the program. However with the advent of application servers that have their own classloaders and need to reload class metadata, PermGen starts looking like a bad optimization decision, which fortunately is going away in Java 8.</p>
<p>A new concept will be used called “Metaspace” which is not exactly the same thing as PermGen. Metaspace is outside the heap, and is managed by the operating system. That means it will be going not into the Java heap, but rather into native memory. Currently this is not such good news because there aren’t many tools that allow you to look easily into native memory. So it is good that PermGen is going away but it is going to take some time until the tooling can catch up.</p>
<h2>Java Heap Layout</h2>
<p>Now let’s take a look at the Java heap. Notice the Virtual spaces between the heap spaces. These provide a little wiggle to allow some amount of resizing of the pools without suffering the expense of moving everything.</p>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/2Fig1.png" alt="" _href="img://2Fig1.png" _p="true" /></p>
<p><b><small>Figure 3</small></b></p>
<h2>Weak Generational Hypothesis</h2>
<p>Now, why do we actually separate the heap into all of these memory pools?</p>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/1Fig2.png" alt="" _href="img://1Fig2.png" _p="true" /></p>
<p><b><small>Figure 4</small></b></p>
<p>There are runtime facts that cannot be deduced by static analysis. The graph above illustrates that there are two groups of objects; those that die young and those that live for a long time – so it makes sense to do extra bookkeeping to take advantage of that fact. The Java platform is littered with similar facts that have been codified into the platform as optimizations.</p>
<h2>Demos</h2>
<p><span style="font-size: 12px;">A series of animated</span>&nbsp;<a href="https://github.com/kittylyst/jfx-mem">demos</a>&nbsp;<span style="font-size: 12px;">were performed</span><span style="font-size: 12px;">. The first demo in Flash illustrates the movement between Eden and one of the young gen survivor spaces, and finally into tenured.</span></p>
<p><strong>Figure 5</strong> presents a JavaFX rendition of the same.</p>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/2Fig3.png" alt="" _href="img://2Fig3.png" _p="true" /></p>
<p><b><small>Figure 5</small></b></p>
<h2>Runtime Switches</h2>
<h3>'Mandatory' Flags</h3>
<ul> 
 <li>-verbose:gc – Get me some GC output</li> 
 <li>-Xloggc:&lt;pathtofile&gt; – Path to the log output, make sure you've got disk space</li> 
 <li>-XX:+PrintGCDetails – Minimum information for tools to help</li> 
</ul>
<p>– Replace -verbose:gc with this</p>
<ul> 
 <li>-XX:+PrintTenuringDistribution – Premature promotion information</li> 
</ul>
<h3>Basic Heap Sizing Flags</h3>
<ul> 
 <li><b>-Xms&lt;size&gt; </b>– Set the minimum size reserved for the heap</li> 
 <li><b>-Xmx&lt;size&gt; </b>– Set the maximum size reserved for the heap</li> 
 <li><b>-XX:MaxPermSize=&lt;size&gt;</b> – Set the maximum size of your perm gen – Good for Spring apps and App servers</li> 
</ul>
<p>In the old days, we were taught to set –Xms to be the same value as –Xmx. However this has changed. So now you can set –Xms to something reasonably small, or just not set it at all, because the heap adaptiveness is now very good.</p>
<h3>Other Flags</h3>
<ul> 
 <li>-XX:NewRatio=N</li> 
 <li>-XX:NewSize=N</li> 
 <li>-XX:MaxNewSize=N</li> 
 <li>-XX:MaxHeapFreeRatio</li> 
 <li>-XX:MinHeapFreeRatio</li> 
 <li>-XX:SurvivorRatio=N</li> 
 <li>-XX:MaxTenuringThreshold=N</li> 
</ul>
<p><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/1Fig4.png" alt="" _href="img://1Fig4.png" _p="true" /></p>
<p><b><small>Figure 6</small></b></p>
<h2>Why Log Files&nbsp;</h2>
<p>Log files have the advantage of being able to be used in forensic analysis, which can save you from having to run the code a second time to reproduce the issue (not easy if it's a rare production bug).</p>
<p><span style="font-size: 12px;">They also have more information than the JMX MXBeans for memory, not to mention that polling JMX can introduce its own set of GC problems.</span></p>
<h2>Tooling</h2>
<ul> 
 <li><b>HP JMeter (Google it)</b></li> 
</ul>
<p>– Free, reasonably solid, but no longer supported / enhanced</p>
<ul> 
 <li><b><a href="http://www.tagtraum.com/gcviewer.html">GCViewer</a></b></li> 
</ul>
<p>– Free, OSS, but a bit ugly</p>
<ul> 
 <li><b><a href="http://code.google.com/a/eclipselabs.org/p/garbagecat/">GarbageCat</a>&nbsp;</b></li> 
</ul>
<p>– Best name</p>
<ul> 
 <li><b><a href="http://www.ibm.com/developerworks/java/jdk/tools/gcmv/">IBM GCMV</a>&nbsp;</b></li> 
</ul>
<p>– J9 support</p>
<ul> 
 <li><b><a href="http://www.jclarity.com/products/censum">jClarity Censum</a></b></li> 
</ul>
<p>– The prettiest and most useful – But we're biased!</p>
<h2>In Summary</h2>
<ul> 
 <li><b>You need to understand some basic GC theory</b></li> 
 <li><b>You want most objects to die young in young gen</b></li> 
 <li><b>Turn on GC logging! </b>– Reading raw log files is hard – Use a tool</li> 
 <li><b>Use tools to help you tweak </b>– Measure, don't guess</li> 
</ul>
<p><a href="http://www.infoq.com/presentations/Visualizing-Java-GC">Here</a> you can access the full presentation.</p>
<h2>About the Author</h2>
<p><strong><img src="http://www.infoq.com/resource/articles/Visualizing-Java-Garbage-Collection/en/resources/Ben-Evans.jpg" vspace="3" hspace="3" align="left" alt="" _href="img://Ben-Evans.jpg" _p="true" />Ben Evans</strong> is the CEO of jClarity, a Java/JVM performance analysis startup. In his spare time he is one of the leaders of the London Java Community and holds a seat on the Java Community Process Executive Committee. His previous projects include performance testing the Google IPO, financial trading systems, writing award-winning websites for some of the biggest films of the 90s, and others.</p><br><br><br><br><br><br></body></html>