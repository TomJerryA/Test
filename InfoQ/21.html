<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Go的四年与成长</h3><p>2013年11月10日，开源项目Go庆祝了它的<a href="http://blog.golang.org/4years">四周年纪念日</a>（Go第一版发布于2012年三月；这里说的四周年，是从<a href="http://golang.org/doc/faq#What_is_the_status_of_the_project">最初项目创建之日</a>开始计算的）。Go由Robert Griesemer、Rob Pike和Ken Tompson在Google创建，随后Ian Taylor和Russ Cox也在开源之前加入了项目。以下是来自其<a href="http://golang.org/doc/faq#creating_a_new_language">FAQ</a>的一段摘录：</p>
<blockquote> 
 <p>Go的诞生，源自对现有系统编程的语言和环境的挫败感。编程已经变得太过艰难，而其中部分原因应当归咎于语言的选择。开发者必须在高效编译、高效执行与易于开发之间做出抉择；然而，在主流编程语言中，并不存在一门语言能够同时实现三方面因素。侧重易用性胜过安全和效率的程序员们，会转而使用动态类型语言，例如Python和JavaScript，而不是C++，而且他们在一定程度上或许也丢开了Java。</p> 
 <p>Go尝试着将动态类型解释语言在编程方面的易用性，与静态类型编译语言的效率和安全性进行结合。它的目标还包括成为支持网络和多核计算的现代语言。最后，它还需要成为一门“快速的语言”：最多花费几秒钟，就能够在单台电脑上构建起大型可执行程序。要满足这些目标，必须解决大量语言问题：兼顾表达性和轻量级类型的系统；支持并发和垃圾回收；拥有严格的依赖规范；以及其他需要解决的问题。这些问题无法通过类库和工具来完美解决，只有一门全新的语言才有可能搞定这一切。</p> 
</blockquote>
<p>Go当前最新版本是2013年5月发布的1.1版；1.2版预计将在本月下旬问世，另外在一份<a href="http://golang.org/doc/go1compat">兼容性文档</a>中提到了未来的程序与Go 1之间的兼容性，暗示了Go所采用的兼容性的前瞻性方法，正是其他编译式语言所缺乏的。</p>
<p>从发布到现在，已经有许多公司开始使用Go，例如轻量容器中的应用打包工具<a href="http://docker.io/">Docker</a>、自动创建机器映像的<a href="http://packer.io/">Packer</a>、提供分布式信息发送平台的<a href="http://bitly.github.io/nsq/">Bitly's NSQ</a>、提供基础设施自动化的<a href="https://juju.ubuntu.com/">Canonical's JuJu</a>，以及<a href="http://golang.org/wiki/Projects">其他许多公司</a>。甚至自由软件基金会也在谈论<a href="http://gcc.gnu.org/ml/gcc/2013-11/msg00153.html">用Go取代Java</a>作为默认语言。Docker团队也在<a href="http://www.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go">一场演讲</a>中，阐述了为何他们会选择使用Go。</p>
<p>而对DevOps人群来说，其主要价值在于，Go程序永远静态地链接到单一可执行程序中——该程序可被部署在目标平台上。因此，系统并不需要预先安装任何额外二进制文件，也无需操心同时运行不同版本的程序会产生冲突。这个特性能够与像Linux和Java这样的打包系统相媲美——它们拥有覆盖多个位置的类库，并要求特定的安装位置，或是一个用来预先构建路径的解析器。（下行风险是，在所有程序的静态二进制文件中，通用类库不断重复出现；但同时硬盘空间的价格并不昂贵。相反，对于运行许多进程的系统来说，服务器上的内存压力或许是更现实的问题——不重复载入某个类的映像，而是只载入一次的话，将有效减少内存压力。幸而，Devops工具一般并不会长时间运行。）</p>
<p>对高可用性和多线程程序来说，主要好处是Go的<a href="http://golang.org/doc/faq#goroutines">goroutines</a>——它采用与Erlang或Occam相似的方式，允许执行多线程来服务收到的请求。这三者都是基于Hoare的通讯顺序进程（<a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a>），简称CSP。CSP并不处理内存和进程访问，相反，每个CSP都拥有一个消息/任务的传入队列，并且能够依次将这些消息/任务发送给其他CSP。CSP支持阻塞和异步操作；每个（阻塞的）CSP都拥有一个返回值，一般被作为返回消息发送给始发的CSP。</p>
<p>Cloud Foundry最近把它的命令行工具<a href="http://blog.cloudfoundry.com/2013/11/09/announcing-cloud-foundry-cf-v6/">从Ruby换成了Go</a>，以实现无需任何特定前置条件极可使用命令的目的。实际上，现在它是一个用来与后端服务沟通的轻量级工具；而且现在不再由客户端来执行复杂的验证程序，而是由它与后端沟通来完成繁重工作。这意味着该工具现在不再需要频繁升级，同时体积也得以缩小。</p>
<p>随着<a href="http://golang.org/doc/go1.2">Go 1.2</a>即将在下周到来，该语言也做出了改变：增加了对三索引切片（slice）的支持。此前，表达式a[1:10]将把数组中的1到10个元素进行切片；而现在a[1:2:10]将以间隔方式切出元素。一项细小的澄清是，对于使用nil的地方，如果取消引用会引起恐慌。其他变化请参考<a href="http://golang.org/doc/go1.2">发行注记</a>。</p>
<p>一些针对的Go批评家指出，该语言使用了一种旧式的编程返回码风格，而不是得到更广泛采用的<a href="http://golang.org/doc/faq#exceptions">基于异常的风格</a>；另外与Erlang（函数式编程，没有可变状态）不同，goroutines能够传送字典（map）。由于默认情况下字典是非同步的，因此这有可能会<a href="http://golang.org/doc/faq#atomic_maps">导致内存冲突</a>。不过，目前很明确的是，Go非常适合针对特定细分领域的用例；而且无论从哪方面与Java和Erlang这样的语言进行对比，Go都可以被看作轻量级语言；同时，与纯C相比，Go或许是个更安全的选择。</p>
<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/news/2013/11/go-four-years">Go Fourth and Grow</a></p><br><br><br><br><br><br></body></html>