<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Prismatic向Schema 0.2中添加了数据类型强制转换</h3><p><a href="http://getprismatic.com/">Prismatic</a>向其<a href="http://clojure.org/">Clojure</a>数据描述库即<a href="https://github.com/prismatic/schema">Schema</a>的<a href="http://blog.getprismatic.com/blog/2014/1/4/schema-020-back-with-clojurescript-data-coercion">0.2版本</a>中添加了<a href="http://en.wikipedia.org/wiki/Type_conversion">数据类型强制转换</a>。强制转换的添加意味着该库不会只是简单地拒绝类型错误的数据，而是可以将它配置为修改实例以符合模式。</p>
<p>在Clojure中，习惯用<a href="http://clojure.org/data_structures#Data%20Structures-Keywords">关键词</a>作为Map的键，也就是说，当收到<a href="http://www.json.org/">JSON</a>对象时，通常有若干样板代码来执行转换。以前，这种转换需要在试图验证请求之前执行。现在，如果模式使用关键字定义键，<a href="https://github.com/prismatic/schema">Schema</a>会为开发人员处理上述过程。当然，开发人员可以编写他们自己的满足特定需求的强制转换器。伴随这项新功能，Prismatic声称这项变化使数据验证的时间减少到五分之一。</p>
<p>Schema是<a href="http://blog.getprismatic.com/blog/2013/9/4/schema-for-clojurescript-data-shape-declaration-and-validation">去年九月份发布</a>的，其目标是“获得Clojure类型系统的诸多好处，而麻烦更少。” Clojure的<a href="https://github.com/clojure/core.typed">core.typed</a>库也是该语言的一个类型系统，Schema发布的时候，似乎与它形成了竞争。那时，core.typed的作者<a href="https://twitter.com/ambrosebs">Ambrose Bonnaire-Sergeant</a><a href="https://news.ycombinator.com/item?id=6339607">反驳</a>了这个观点，指出它们实际上是互补的，并在之后<a href="http://www.infoq.com/cn/news/2013/10/core-typed">接受InfoQ关于core.typed</a>的采访时重申了这一点。</p>
<p><a href="http://getprismatic.com/profile/w01fe">Jason Wolfe</a>是该库的主要作者。InfoQ获得了就Schema的未来与他进行交谈的机会。</p>
<p><b>InfoQ</b>：当Schema最初发布的时候，有人认为core.typed和Schema的组合将非常强大。从那以后，您想过发展这一想法吗？</p>
<blockquote> 
 <p>几年前，从我看到我的第一个Qi项目开始，我就一直因为Clojure的进阶类型而兴奋，而且我认为，Ambrose在促成这点方面做得非常棒。我们已经谈过，有若干方式可以使Schema与core.typed完美地结合，其中最有趣的可能是将Schema作为core.type-checked代码与未经检查的代码之间的桥梁。</p> 
 <p>那就是说，我很遗憾，我们还没有时间对core.typed做更深入地探究，所以，我现在没有更多的内容可谈了。</p> 
</blockquote>
<p><b>InfoQ</b>：通过扩展实现测试数据生成听上去充满挑战，您会集成<a href="https://github.com/reiddraper/simple-check">simple-check</a>，利用<a href="https://github.com/clojure/test.generative">test.generative</a>，还是说Schema需要一种不同的方式？</p>
<blockquote> 
 <p>我们还在考虑该问题。关于simple-check，我读过许多非常棒的东西，我认为这应该可行，但我们还在设法理解其实现，并弄清楚如何将额外的限制加入生成过程。此外，还可能是一个简单的生成器，用于伪随机地充实部分基准，这是我们最终在测试中经常用的东西。</p> 
</blockquote>
<p><b>InfoQ</b>：关于从Schema定义中提取值，您有什么进一步的想法吗？</p>
<blockquote> 
 <p>强制转换和转换极其强大，我想我们还在寻找所有因为它们而变得可行的应用。我的同事Dave Golland将在Clojure West大会上就新库“fnhouse”发表演说，该库将graph和schema结合在一起，简化了Web API构建。“coax”也会随之发布，该库会自动生成Objective C和ClojureScript模型类，以及从fnhouse API生成客户端API库。</p> 
 <p>之后，我们还有许多疯狂的想法，但我们还没有准备好谈论它们。</p> 
</blockquote>
<p><a href="https://github.com/prismatic/plumbing">Graph</a>是个Prismatics Clojure库，<a href="http://blog.getprismatic.com/blog/2013/2/1/graph-abstractions-for-structured-computation">在2013年发布</a>，用于以声明式样式表达结构化计算。</p>
<p><b>查看英文原文：</b><b><a href="http://www.infoq.com/news/2014/02/prismatic-schema-coercion">Prismatic Adds Data Type Coercion to Schema 0.2</a></b></p><br><br><br><br><br><br></body></html>