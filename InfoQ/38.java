<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>More on Immutable Collections in .NET</h3><p>Since we last reported on <a href="http://www.infoq.com/news/2013/01/Immutable-BCL;jsessionid=25384E92750396761FD42D9B9FFC4A17">Immutable Collections</a> in January, the API has evolved and a lot more has been revealed about the inner workings. First a rundown of what’s changed in the most recent release:</p> 
<p><b>Constructors</b></p> 
<p>Though the immutable collections still do not offer constructors, the use of an Empty object is no longer necessary. Previously you would see code like this:</p> 
<pre>
var list = ImmutableList&lt;int&gt;.Empty.Add(1, 2, 3);</pre> 
<p>With the new release we get a static factory method called Create. This allows generic type inference to be used, shortening the expression to:</p> 
<pre>
var list = ImmutableList.Create(1, 2, 3);</pre> 
<p><b>Compatibility </b></p> 
<p>A hotly debated topic is the implementation of the IList&lt;T&gt; interface. Proponents of the interface say that it is necessary for interoperability with libraries that predate the introduction of IReadOnlyList&lt;T&gt;. Critics complain that the same legacy libraries don’t necessarily check to see if IList.IsReadOnly is false before attempting to modify values.</p> 
<p>In the end the BCL team bowed down to legacy concerns and implemented IList&lt;T&gt;. While everyone agrees that it would have been better if IList.IsReadOnly never existed, at this point there is too much momentum behind it.</p> 
<p>For a complete list of immutable classes and the interfaces they expose see this <a href="http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-00-30-50/4503.Immutable_5F00_Table.png">compatibility chart</a>.</p> 
<p><b>Equality Semantics</b></p> 
<p>Like other collection types, the immutable collections will only support reference equality. The <a href="http://blogs.msdn.com/b/bclteam/archive/2013/03/06/update-to-immutable-collections.aspx">BCL Team writes</a>,</p> 
<blockquote> 
 <p>Value equality on collections can be fairly expensive to compute and comparing for equality on nested collections, such as ImmutableDictionary&lt;string, ImmutableList&lt;string&gt;&gt; is more difficult to define. Finally, providing this functionality leads to more issues when different comparers are involved, as customers have pointed out.</p> 
</blockquote> 
<p>Previously the collections did override Object.Equals but not op_equals.</p> 
<p>Some have asked about supporting <a href="http://msdn.microsoft.com/en-us/library/system.collections.istructuralequatable.aspx">IStructuralEquatable</a>. The BCL team has declined to support that interface because it is “hard to generalize”. For example, in some scenarios it may be appropriate to skip over items in the collection (e.g. whitespace nodes in a parser), which wouldn’t be possible with a non-specific implementation.</p> 
<p>Unfortunately the design of the immutable classes requires them to be sealed, preventing the use of inheritance to add IStructuralEquatable after the fact.</p> 
<p><b>Platform Support</b></p> 
<p>The immutable collections library is designed for .NET 4.5 and later. It is designed to take advantage of the new read-only interfaces and the developers are not interested in maintaining a separate version for older libraries. It is also available for the Windows 8 and the “portable-net45+win8” profiles.</p> 
<p><b>Serialization</b></p> 
<p>The legacy serialization design using the Serializable attribute will not be supported by the immutable collections. At this time there is no word on whether or not other serialization designs such as DataContractSerializer will be supported.</p> 
<p><b>Internals</b></p> 
<p>Immutable collections (except stack and queue) are based on <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL trees</a>. This allows insertions in the beginning, middle, or end of the list without recopying the entire tree. In the <a href="http://en.wikipedia.org/wiki/Persistent_data_structure#Trees">trees section</a> of the Wikipedia article on persistent data structures you can see an example of such an insert.</p> 
<p>Immutable hash tables also use AVL trees. Instead of the bucket design of normal hash tables, which perform a modulus operation on the hash code, these actually sort the tree according to the raw hash code. This means retrieval requires a binary search with an average retrieval time of O(log n).</p> 
<p>Keep in mind that the Big-O notation is misleading when using multi-threaded operations. The alternative to the immutable collections are the concurrent collections, which require expensive internal locking to ensure thread safety.</p> 
<p>An interesting feature of the immutable collections is that their internal nodes are not immutable. In order to reduce the amount of garbage created while constructing a collection, each node begins in an editable state. This allows the constructor to make changes to the existing AVL tree as it adds nodes instead of discarding and recreating it. Once construction is complete and the immutable wrapper returned the nodes are marked as frozen, preventing further changes.</p> 
<p>Another surprising design decision is the object pool used by the enumerator. In .NET many of the enumerators are designed to be allocation free. If you get an enumerator from an IList&lt;T&gt; two allocations are needed. But with a List&lt;T&gt;, the enumerator is a struct and no allocations are necessary.</p> 
<p>Likewise, the immutable collections use structs for the enumerator. But because the internal structure is a tree, the enumerator needs a stack to include a stack of previously visited nodes so that it can back-track. In order to reduce allocations, a set of these stacks is stored in an object pool (actually a stack) protected by a single lock. In fact, this is the only lock in the entire immutable collection library. It is critical that dispose is called on the enumerator, or else the stack will not be returned to the object pool.</p> 
<p>For more information see the Channel 9 video titled <a href="http://blogs.msdn.com/b/bclteam/archive/2013/03/19/inner-workings-of-immutable-collections-on-channel-9.aspx">Inner Workings of Immutable Collections</a>.</p> 
<p><b>Usage Recommendations</b></p> 
<p>When creating an immutable collection, it is best to create the collection all at once using the Create function. This will allow it to pre-allocate the tree and directly populate the nodes. The second-best method is to use a builder, which doesn’t freeze nodes until you call ToImmutable.</p> 
<p>When enumerating items in an immutable collection, always prefer a foreach loop. Due to the internal tree structure, this will be much faster than a for loop. (Side note: Since .NET 2.0, even normal lists can be read faster with foreach than with for.)</p> 
<p>If a collection is never mutated after being created, then an immutable collection will have poorer performance than a normal collection protected by a read-only wrapper. Immutable collections are better when you want to efficiently create new collections that are slightly different than another collection.</p> 
<p id="lastElm"></p><br><br><br><br><br><br></body></html>