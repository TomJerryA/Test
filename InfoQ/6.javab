<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Refactoring Legacy Applications: A Case Study</h3><p>Legacy code is stinky. Every decent developer would like to refactor it, and in order to refactor it, one ideally should have a suite of unit test cases to prevent regressions. However, writing unit tests for legacy code is not easy; the legacy code is usually a big mess. To write effective unit tests against the legacy code, you probably need to refactor it first; and to refactor it, you need unit tests to ensure you are not breaking anything. So it is a chicken and egg situation. This article describes a methodology to safely refactor legacy code by sharing a real case I once worked on.</p><h2>Problem Statement</h2><p>In this article, I use a real case to illustrate the pragmatic practices in testing and refactoring legacy systems. This case was written in Java, but the practices should be applicable in other languages. I have changed the scenario to protect the innocent, and simplified it to make it more understandable. The practices introduced in this article were instrumental in refactoring the legacy system I recently worked on.<br /> <br /> This article is not about the basic skills of unit testing and refactoring. You can learn much more about those topics by reading books such as <a href="http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672">Refactoring: Improving the Design of Existing Code</a> by <a href="http://martinfowler.com/">Martin Fowler</a> and<a href="http://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351"> Refactoring to Patterns</a> by <a href="https://twitter.com/JoshuaKerievsky">Joshua Kerievsky</a>. Rather this article describes some of the complexity often encountered in real life and provides, I hope, useful practices to tackle those complexities.<br /> <br /> The example case study I will use is a fictional resource management system in which a resource refers to a person who can be assigned to some tasks. Let us say a resource can be assigned to a ticket—a HR ticket or an IT ticket. A resource can also be assigned to a request — a HR request or an IT request. The resource manager can log the time a resource is estimated to spend on the task. The resource can log how much time he or she actually works on the ticket or request.</p><p><br /> <img src="/resource/articles/refactoring-legacy-applications/en/resources/RefactoringLegacy01.png;jsessionid=D0B5ED7A01B584DA6C07A5571D492378" alt="" _href="img://RefactoringLegacy01.png" _p="true" /></p><p>The utilization of resources can be shown in a bar chart, which shows both the estimated and actual time spent.<br /> <br /> <img src="/resource/articles/refactoring-legacy-applications/en/resources/RefactoringLegacy02.png;jsessionid=D0B5ED7A01B584DA6C07A5571D492378" alt="" _href="img://RefactoringLegacy02.png" _p="true" /><br /> <br /> Not complicated? Well, in the real system, resources can be assigned many types of tasks. Still, technically it is not a complex design. However when I first read the code, I felt like I was reading a fossil, I could see how the code had evolved (or rather de-evolved). At first the system was only able to deal with requests, and then functionality was added to deal with tickets and other kinds of tasks. Then an engineer came along and wrote code to deal with requests: extracting data from the database, and assembling it to be shown in the bar chart. He didn’t even bother to organize the information into proper objects:</p><pre>
 class ResourceBreakdownService {
&nbsp;&nbsp;&nbsp; public Map search (Session context) throws SearchException{&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //omitted twenty or so lines of code to pull search criteria out of context and verify them, such as the below:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(resourceIds==null || resourceIds.size ()==0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new SearchException(“Resource list is not provided”);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(resourceId!=null || resourceIds.size()&gt;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      resourceObjs=resourceDAO.getResourceByIds(resourceIds);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //get workload for all requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map requestBreakDown=getResourceRequestsLoadBreakdown (resourceObjs,startDate,finishDate);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return requestBreakDown;
&nbsp;&nbsp;&nbsp;}
}</pre><p>I am sure you were immediately repulsed by the stink of this code, for example, you were probably immediately thinking <b>search</b> is not a meaningful name, it should use the Apache Commons library <b>CollectionUtil.isEmpty()</b> to test a collection and you were probably questioning the resulting <b>Map</b>?<br /> <br /> But wait, the stink continued to build up. A second engineer came along and followed suit and dealt with tickets in the same way, so in the code, you have:</p><pre>
// get workload for all tickets
Map ticketBreakdown =getResourceRequestsLoadBreakdown(resourceObjs,startDate,finishDate,ticketSeverity);
Map result=new HashMap();
for(Iterator i = resourceObjs.iterator(); i.hasNext();) {
&nbsp;&nbsp;&nbsp; Resource resource=(Resource)i.next();      &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; Map requestBreakdown2=(Map)requestBreakdown.get(resource);<br />&nbsp;&nbsp;&nbsp; List ticketBreakdown2=(List)ticketBreakdown.get(resource);<br />&nbsp;&nbsp;&nbsp; Map resourceWorkloadBreakdown=combineRequestAndTicket(requestBreakdown2, ticketBreakdown2);<br />&nbsp;&nbsp;&nbsp; result.put(resource,resourceWorkloadBreakdown)<br />}<br />return result;</pre><p>Forget about the naming, the balance of structure and other aesthetic concerns, the stinkiest thing about this code is the returning <b>M</b><b>ap</b> object. <b>Map</b> is a black hole, it sucks in everything and doesn’t give you many clues as to what is contained in it. Only by writing some debugging code to recursively print out the content of the map, was I able to find out its data structure.<br /> <br /> In this example, <b>{}</b> means a Map, <b>=&gt;</b> means key value mapping and <b>[]</b> means a collection:</p><pre>
 {resource with id 30000=&gt; [
&nbsp;&nbsp;&nbsp; SummaryOfActualWorkloadForRequestType,
&nbsp;&nbsp;&nbsp; SummaryOfEstimatedWorkloadForRequestType,
&nbsp;&nbsp;&nbsp; {30240=&gt;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ActualWorkloadForReqeustWithId_30240,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      EstimatedWorkloadForRequestWithId_30240],&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      30241=&gt;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ActualWorkloadForReqeustWithId_30241,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      EstimatedWorkloadForRequestWithId_30241]<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; SummaryOfActualWorkloadForTicketType,<br />&nbsp;&nbsp;&nbsp;&nbsp; SummaryOfEstimatedWorkloadForTicketType,<br />&nbsp;&nbsp;&nbsp;&nbsp; {20000=&gt;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ActualWorkloadForTicketWithId_2000,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      EstimatedWorkloadForTicketWithId_2000],<br />&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;      &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; ]<br />}</pre><p>With such a terrible data structure, the data marshaling and un-marshalling logic was virtually unreadable and extremely long and tedious.&nbsp;</p><h2>Integration test</h2><p>I hope by now I have convinced you that this code was truly complex. If I had started out by first unraveling the mess and understanding every bit of the code before refactoring, I might have gone crazy. To save my sanity, I decided that to understand the code logic, I would be better to use a top down approach. That is, instead of reading the code and deducing the logic, I decided it would be better to play with the system and debug it and understand the big picture. <br /> <br /> I use the same approach in writing tests. Conventional wisdom is to write small tests to verify every code path, and if every piece is well tested, when you put all the code paths together, there is a big chance that the whole will work as expected. But that didn’t apply here. <b> ResourceBreakdownService</b> was a <a href="http://c2.com/cgi/wiki?GodClass">God class</a>. If I had started out by first breaking it apart armed with only a big-picture understanding, I would have made a lot of mistakes – there could be many secrets hidden in every nook and corner of the legacy system.&nbsp; <br /> <br /> I wrote this simple test, which reflected my understanding of the big picture:</p><pre>
 public void testResourceBreakdown(){
&nbsp;&nbsp;&nbsp; Resource resource=createResource();
&nbsp;&nbsp;&nbsp; List requests=createRequests();
&nbsp;&nbsp;&nbsp; assignRequestToResource(resource, requests);
&nbsp;&nbsp;&nbsp; List tickets=createTickets();
&nbsp;&nbsp;&nbsp; assignTicketToResource(resource, tickets);
&nbsp;&nbsp;&nbsp; Map result=new ResourceBreakdownService().search(resource);
&nbsp;&nbsp;&nbsp; verifyResult(result,resource,requests,tickets);
}</pre><p>Notice the <b>verifyResult()</b> method, I first found out the structure of result by recursively printing out its content, and <b>verifyResult()</b> used this knowledge to verify it contained the right data:</p><pre>
private void verifyResult(Map result, Resource rsc, List&lt;Request&gt; requests, List&lt;Ticket&gt; tickets){&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; assertTrue(result.containsKey(rsc.getId()));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; // in this simple test case, actual workload is empty<br />&nbsp;&nbsp;&nbsp; UtilizationBean emptyActualLoad=createDummyWorkload();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; List resourceWorkLoad=result.get(rsc.getId());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; UtilizationBean scheduleWorkload=calculateWorkload(rsc,requests);<br />&nbsp;&nbsp;&nbsp; assertEquals(emptyActualLoad,resourceWorkLoad.get(0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; assertEquals(scheduleWorkload,resourceWorkLoad.get(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       <br />&nbsp;&nbsp;&nbsp; Map requestDetailWorkload = (Map)resourceWorkLoad.get(3);<br />&nbsp;&nbsp;&nbsp; for (Request request : requests) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assertTrue(requestDetailWorkload.containsKey(request.getId());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UtilizationBean scheduleWorkload0=calculateWorkload(rsc,request);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assertEquals(emptyActualLoad,requestDetailWorkload.get(request.getId()).get(0));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assertEquals(scheduleWorkload0,requestDetailWorkload.get(request.getId()).get(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; }
<br />&nbsp;&nbsp;&nbsp; // omit code to check tickets<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br />}</pre><h2>Walk Around Obstacles</h2><p>The above test case seemed easy but there were many complexities. For a start, <b>ResourceBreakdownService().search</b> is tightly weaved into the runtime, it needs to access the database, other services and who knows what else. And, like many legacy systems, this system didn’t have any unit test infrastructure built. To access the runtime services, the only option was to start up the whole system, which was very expensive and inconvenient. <br /> <br /> The class that started up the server side of the system was <b>ServerMain</b>.<b>ServerMain</b> was also like a fossil, from which you can tell how it was evolved. This system was written more than 10 years ago, at that time, there was no <a href="http://www.springsource.org/">Spring</a>, no <a href="http://www.hibernate.org/">Hibernate</a>, a little bit of <a href="http://www.jboss.org/">JBoss</a> and a little bit of <a href="http://tomcat.apache.org/">Tomcat</a>. The brave pioneers at that time had to do a lot of DIY's so they created a home-made cluster, a cache service and a connection pool amongst other things. Later they somehow plugged into JBoss and Tomcat (but unfortunately they left behind their DIY's, so the code was left with two sets of transaction managing mechanisms and three types of connection pools.&nbsp; <br /> <br /> I decided to copy <b>ServerMain</b> to <b>TestServerMain</b>. Invoking <b>TestServerMain.main()</b> failed with:</p><pre>
org.springframework.beans.factory.BeanInitializationException: Could not load properties; nested exception is<br />java.io.FileNotFoundException: class path resource [database.properties] cannot be opened because it does not exist<br />at<br />org.springframework.beans.factory.config.PropertyResourceConfigurer.postProcessBeanFactory(PropertyResourceConfigurer.java:78)</pre><p>OK, that was easily fixable! I grabbed a <b>database.properties</b> file and dropped it to the test class path, and ran it again. This time, this exception was thrown out:</p><pre>
java.io.FileNotFoundException: .\server.conf (The system cannot find the file specified)
&nbsp;&nbsp;&nbsp; at java.io.FileInputStream.open(Native Method)
&nbsp;&nbsp;&nbsp; at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
&nbsp;&nbsp;&nbsp; at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:66)
&nbsp;&nbsp;&nbsp; at java.io.FileReader.&lt;init&gt;(FileReader.java:41)
&nbsp;&nbsp;&nbsp; at com.foo.bar.config.ServerConfigAgent.parseFile(ServerConfigAgent.java:1593)
&nbsp;&nbsp;&nbsp; at com.foo.bar.config.ServerConfigAgent.parseConfigFile(ServerConfigAgent.java:1720)
&nbsp;&nbsp;&nbsp; at com.foo.bar.config.ServerConfigAgent.parseConfigFile(ServerConfigAgent.java:1712)
&nbsp;&nbsp;&nbsp; at com.foo.bar.config.ServerConfigAgent.readServerConf(ServerConfigAgent.java:1581)
&nbsp;&nbsp;&nbsp; at com.foo.bar.ServerConfigFactory.initServerConfig(ServerConfigFactory.java:38)
&nbsp;&nbsp;&nbsp; at com.foo.bar.util.HibernateUtil.setupDatabaseProperties(HibernateUtil.java:207)
&nbsp;&nbsp;&nbsp; at com.foo.bar.util.HibernateUtil.doStart(HibernateUtil.java:135)
&nbsp;&nbsp;&nbsp; at com.foo.bar.util.HibernateUtil.&lt;clinit&gt;(HibernateUtil.java:125)</pre><p>server.conf somewhere, but that approach made me uncomfortable. Just by writing this single test case, it immediately exposed a problem in the code. <b>HibernateUtil</b>, as its name suggests, should only care about database information which should have been supplied by <b>database.properties</b>. Why should it access <b>server.conf</b> which configures server-wide setups? Here is a clue that the code is smelly: if you feel like you are reading a detective novel and constantly asking “why”, the code is usually bad. I could have spent much time reading through <b>ServerConfigFactory</b>, <b>HibernateUtil</b> and <b>ServerConfigAgent</b> and trying to figure out how to point <b>HibernateUtil</b> to <b>database.properties</b>, but at this point, I was too anxious to get a running server. Besides, there was a way to walk around it. The weapon is <a href="http://eclipse.org/aspectj/">AspectJ</a>:</p><pre>
void around():
&nbsp;&nbsp;&nbsp; call(public static void com.foo.bar.ServerConfigFactory.initServerConfig()){<br />&nbsp;&nbsp;&nbsp; System.out.println(&quot;bypassing com.foo.bar.ServerConfigFactory.initServerConfig&quot;);
}</pre><p>For folks who do not understand AspectJ, in simple English the above means: when the runtime is at the point of calling <b>ServerConfigFactory.initServerConfig()</b>, print a message and return without going into the method itself. This may feel like hacking, but it very cost effective. Legacy systems are full of riddles and problems. At any given moment, one needs to pick his fight strategically. At that moment, the most rewarding thing for me to do, in terms of customer satisfaction, was to fix the defects in the resource management system and improve its performance. Straightening up things in other areas was not on my radar. However, I made a mental note that I would come back later and sort out the mess in <b>ServerMain</b>.<br /> <br /> Then at the point of <b>HibernateUtil</b> reading required information from <b>server.conf</b>, I pointed it to read it from <b>database.properties</b>:</p><pre>
String around():call(public String com.foo.bar.config.ServerConfig.getJDBCUrl()){
&nbsp;&nbsp;&nbsp; // code omitted, reading from database.properties<br />}<br /><br />&nbsp;&nbsp;&nbsp;String around():call(public String com.foo.bar.config.ServerConfig.getDBUser()){<br />&nbsp;&nbsp;&nbsp; // code omitted, reading from database.properties <br />}</pre><p>You probably can guess the rest now: walk around obstacles when it is more convenient or natural to do so. But if there are ready mockups, reuse them. For example, at one point, <b>TestServerMain.main()</b> failed with:</p><pre>
- Factory name: java:comp/env/hibernate/SessionFactory<br />- JNDI InitialContext properties:{}<br />- Could not bind factory to JNDI
javax.naming.NoInitialContextException: Need to specify class name in environment or system property, or as an applet<br />parameter, or in an application resource file: java.naming.factory.initial
&nbsp;&nbsp;&nbsp; at javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:645)
&nbsp;&nbsp;&nbsp; at javax.naming.InitialContext.getDefaultInitCtx(InitialContext.java:288)</pre><p>This was because the JBoss naming service was not started. I could have used the same hacking technique to walk around this, but <b>InitialContext</b> is a big Javax interface containing many methods, and I didn’t want to chase and hack every method – that would be very tedious. A quick search revealed Spring already has a mock class <b>SimpleNamingContext</b>, so I dropped it into the test:</p><pre>
SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();
builder.bind(“java:comp/env/hibernate/SessionFactory”,sessionFactory);
builder.activate();</pre><p>After a few rounds, I was able to make <b>TestServerMain.main()</b> run successfully. Comparing to <b>ServerMain</b>, it was much simpler, it mocked up a lot of JBoss services, and it didn’t entangle with cluster management.</p><h2>Build the Building Blocks</h2><p><b>TestServerMain</b> is connected to a real database. Legacy systems can hide surprising logic in stored procedures, or even worse in triggers. Following the same big-picture thinking, I decided it was not wise for me at that time to try to understand the mysteries inside the database and fake up a database, so I decided to have my test case access the real database.</p><p>The test case would need to run repeatedly to ensure every small change I made to the product code passes the test. At each run, the tests would create resources and requests in the database. Unlike conventional wisdom in unit tests, you sometimes do not want to clean up the battle field after each run by destroying the data created by test cases. So far, the testing and refactoring exercise has been a fact-finding exploration - you learn the legacy system by trying to test it. You might want to check the data generated by test cases in the database, or you might want to use the data in the runtime system, in order to confirm everything is working as expected. This means test cases have to create unique entities in the database to avoid stepping on other test cases. There should also be some utility classes to easily create such entities.</p><p>Here is such a simple builder block for building <b>resource</b>:</p><pre>
public static ResourceBuilder newResource (String userName) {<br />&nbsp;&nbsp;&nbsp; ResourceBuilder rb = new ResourceBuilder();<br />&nbsp;&nbsp;&nbsp; rb.userName = userName + UnitTestThreadContext.getUniqueSuffix();<br />&nbsp;&nbsp;&nbsp; return rb; }<br />
public ResourceBuilder assignRole(String roleName) { <br />&nbsp;&nbsp;&nbsp; this.roleName = roleName + UnitTestThreadContext.getUniqueSuffix();<br />&nbsp;&nbsp;&nbsp; return this; <br />}<br /> public Resource create() {<br />&nbsp;&nbsp;&nbsp; ResourceDAO resourceDAO = new ResourceDAO(UnitTestThreadContext.getSession());<br />&nbsp;&nbsp;&nbsp; Resource rs;<br /> &nbsp;&nbsp;&nbsp; if (StringUtils.isNotBlank(userName)) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs = resourceDAO.createResource(this.userName);<br /> &nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw new RuntimeException(&quot;must have a user name to create a resource&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; if (StringUtils.isNotBlank(roleName)) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Role role = RoleBuilder.newRole(roleName).create();<br /> &nbsp;&nbsp;&nbsp; rs.addRole(role);<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; return rs;<br /> }<br /> <br /> public static void delete(Resource rs, boolean cascadeToRole) {<br /> &nbsp;&nbsp;&nbsp; Session session = UnitTestThreadContext.getSession();<br /> &nbsp;&nbsp;&nbsp; ResourceDAO resourceDAO = new ResourceDAO(session);<br /> &nbsp;&nbsp;&nbsp; resourceDAO.delete(rs);<br /> <br /> &nbsp;&nbsp;&nbsp; if (cascadeToRole) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RoleDAO roleDAO = new RoleDAO(session);<br /> &nbsp;&nbsp;&nbsp; List roles = rs.getRoles();<br /> &nbsp;&nbsp;&nbsp; for (Object role : roles) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; roleDAO.delete((Role)role);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> }</pre><p><b>ResourceBuilder</b> is an implementation of the Builder and Factory design patterns; you can use it in a “train-wreck” style:</p><pre>
ResourceBuilder.newResource(“Tom”).assignRole(“Developer”).create();</pre><p>It also contains a battle-field cleaning-up method: <b>delete()</b>. In the early stage of this refactoring exercise, I didn’t invoke <b>delete()</b> very often, as I often started up the system and pulled in the test data and checked if the bar chart was correct.<br /> <br /> The class that was very useful here was <b>UnitTestThreadContext</b>. It stores a thread-specific Hibernate Session object, and provides unique strings to be appended to names of the entities you intend to create, thus ensuring uniqueness of the entities.</p><pre>
public class UnitTestThreadContext {<br /> &nbsp;&nbsp;&nbsp; private static ThreadLocal&lt;Session&gt; threadSession=new ThreadLocal&lt;Session&gt;();<br /> &nbsp;&nbsp;&nbsp; private static ThreadLocal&lt;String&gt; threadUniqueId=new ThreadLocal&lt;String&gt;();<br /> &nbsp;&nbsp;&nbsp; private final static SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd HH_mm_ss_S&quot;);<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; public static Session getSession(){&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Session session = threadSession.get();<br /> &nbsp;&nbsp;&nbsp; if (session==null) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw new RuntimeException(&quot;Hibernate Session not set!&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; return session;<br /> &nbsp;&nbsp;&nbsp; }<br /><br /> &nbsp;&nbsp;&nbsp; public static void setSession(Session session) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       threadSession.set(session);<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; public static String getUniqueSuffix() {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String uniqueId = threadUniqueId.get();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (uniqueId==null){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uniqueId = &quot;-&quot;+dateFormat.format(new Date());<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;threadUniqueId.set(uniqueId);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return uniqueId;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /><br /> &nbsp;&nbsp;&nbsp; …<br /> }</pre><h2>Wrap It Up</h2><p>Now I could start up a minimum running infrastructure and run my simple test case:</p><pre>
protected void setUp() throws Exception {<br /> &nbsp;&nbsp;&nbsp; TestServerMain.run(); //setup a minimum running infrastructure<br /> }<br /> &nbsp;&nbsp;&nbsp; <br /> public void testResourceBreakdown(){<br /> &nbsp;&nbsp;&nbsp; Resource resource=createResource(); //use ResourceBuilder to build unique resources<br /> &nbsp;&nbsp;&nbsp; List requests=createRequests(); //use RequestBuilder to build unique requests<br /> &nbsp;&nbsp;&nbsp; assignRequestToResource(resource, requests);<br /> &nbsp;&nbsp;&nbsp; List tickets=createTickets(); //use TicketBuilder to build unique tickets<br /> &nbsp;&nbsp;&nbsp; assignTicketToResource(resource, tickets);<br /> &nbsp;&nbsp;&nbsp; Map result=new ResourceBreakdownService().search(resource);<br /> &nbsp;&nbsp;&nbsp; verifyResult(result);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> }&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp; <br /> protected void tearDown() throws Exception {<br /> &nbsp;&nbsp;&nbsp; // use TicketBuilder.delete() to delete tickets<br /> &nbsp;&nbsp;&nbsp; // use RequestBuilder.delete() to delete requests<br /> &nbsp;&nbsp;&nbsp; // use ResourceBuilder.delete() to delete resources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><p>I continued to write more complex test cases and refactored the product code and test code along the way.</p><p>Armed with these test cases, I broke down the God class <b>ResourceBreakdownService</b> little by little. I won’t bore you with the details; there are a lot of books that will teach you how to do refactoring safely. For the sake of completeness, here is the resulting structure after refactoring</p><p class="image-wide"><img src="/resource/articles/refactoring-legacy-applications/en/resources/RefactoringLegacy03.png;jsessionid=D0B5ED7A01B584DA6C07A5571D492378" alt="" _href="img://RefactoringLegacy03.png" _p="true" /></p><p>Now that terrible <b>Map_Of_Array_Of_Map_Of…</b> data structure is now organized into <b>ResourceLoadBucket</b>, which uses the <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite design pattern</a>. It contains estimated effort and actual effort at a certain level, the next level efforts can be aggregated up with the <b>aggregate()</b> method. The resulting code was much cleaner and performed better. And it even exposed some defects that were hidden in the complexity of the original code. And of course, I evolved my test cases along the way.</p><p>Throughout this exercise, the key principle I adhered to was big-picture thinking. I picked my fight and stayed focused on it, walking around obstacles that were not important to the task at hand, and built up a minimal viable testing infrastructure, which my team continued to use to refactor other areas. Some ldquo;hacking” pieces still remain in the testing infrastructure, because it doesn’t make too much business sense to clean them up. I was not only able to refactor a very complex function area, but also gained a deeper knowledge about the legacy system. Treating a legacy application as if it was fragile china doesn’t bring you more safety, boldly charging into it and refactoring it is how legacy applications can survive into the future.</p><h2>About The Author&nbsp;</h2><p><img vspace="3" hspace="3" align="left" alt="" src="/resource/articles/refactoring-legacy-applications/en/resources/Chen-Ping.jpg;jsessionid=D0B5ED7A01B584DA6C07A5571D492378" _href="img://Chen-Ping.jpg" _p="true" /><strong>Chen Ping</strong> lives in Shanghai, China and graduated with a Masters Degree in Computer Science in 2005. Since then she has worked for Lucent and Morgan Stanley. Currently she is working for HP as a Development manager. Outside of work, she likes to study Chinese medicine.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="clearer-space"></div></body></html>