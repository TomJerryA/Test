<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Agile Software Architecture Sketches and NoUML</h3><p>If you're working in an agile software development team at the moment, take a look around at your environment. Whether it's physical or virtual, there's likely to be a story wall or Kanban board visualising the work yet to be started, in progress and done. Visualising your software development process is a fantastic way to introduce transparency because anybody can see, at a glance, a high-level snapshot of the current progress. As an industry, we've become pretty adept at visualising our software development process over the past few years although it seems we've forgotten how to visualise the actual software that we're building. I'm not just referring to post-project documentation, this also includes communication <i>during</i> the software development process. Agility is about moving fast and this requires good communication, but it's surprising that many teams struggle to effectively communicate the design of their software.</p><h2>Prescribed methods, process frameworks and formal notations</h2><p>If you look back a few years, structured processes and formal notations provided a reference point for both the software design process and how to communicate the resulting designs. Examples include the Rational Unified Process (RUP), Structured Systems Analysis And Design Method (SSADM), the Unified Modelling Language (UML) and so on. Although the software development industry has moved on in many ways, we seem to have forgotten some of the good things that these older approaches gave us. In today's world of agile delivery and lean startups, some software teams have lost the ability to communicate what it is they are building and it's no surprise that these teams often seem to lack technical leadership, direction and consistency. If you want to ensure that everybody is contributing to the same end-goal, you need to be able to effectively communicate the vision of what it is you're building. And if you want agility and the ability to move fast, you need to be able to communicate that vision efficiently too.</p><h2>Abandoning UML</h2><p>As an industry, we do have the Unified Modelling Language (UML), which is a formal standardised notation for communicating the design of software systems. I do use UML myself, but I only tend to use it sparingly for sketching out any important low-level design aspects of a software system. I don't find that UML works well for describing the high-level software architecture of a software system and while it's possible to debate this, it's often irrelevant because many teams have already thrown out UML or simply don't know it. Such teams typically favour informal boxes and lines style sketches instead but often these diagrams don't make much sense unless they are accompanied by a detailed narrative, which ultimately slows the team down. Next time somebody presents a software design to you focussed around one or more informal sketches, ask yourself whether they are presenting what's on the sketches or whether they are presenting what's still in their head.</p><p>(Click on the image to enlarge it)</p><p class="image-wide"><a _href="resource://1big.png" href="/resource/articles/agile-software-architecture-sketches-NoUML/en/resources/1big.png;jsessionid=D5CD5106370A71357C543A7BFB6967C9"><img vspace="3" hspace="3" align="absBottom" _p="true" _href="img://1small.png" alt="" src="http://www.infoq.com/resource/articles/agile-software-architecture-sketches-NoUML/en/resources/1small.png;jsessionid=D5CD5106370A71357C543A7BFB6967C9" /></a></p><p>Abandoning UML is all very well but, in the race for agility, many software development teams have lost the ability to communicate visually too. The example NoUML software architecture sketches (above) illustrate a number of typical approaches to communicating software architecture and they suffer from the following types of problems:</p><ul> 
 <li>Colour-coding is usually not explained or is often inconsistent.</li> 
 <li>The purpose of diagram elements (i.e. different styles of boxes and lines) is often not explained.</li> 
 <li>Key relationships between diagram elements are sometimes missing or ambiguous.</li> 
 <li>Generic terms such as &quot;business logic&quot; are often used.</li> 
 <li>Technology choices (or options) are usually omitted.</li> 
 <li>Levels of abstraction are often mixed.</li> 
 <li>Diagrams often try to show too much detail.</li> 
 <li>Diagrams often lack context or a logical starting point.</li> 
</ul><h2>Some simple abstractions</h2><p>Informal boxes and lines sketches can work very well, but there are many pitfalls associated with communicating software designs in this way. My approach is to use a small collection of simple diagrams that each show a different part of the same overall story. In order to do this though, you need to agree on a simple way to think about the software system that you're building. Assuming an object oriented programming language, the way that I like to think about a software system is as follows ... a software system is made up of a number of containers, which themselves are made up of a number of components, which in turn are implemented by one or more classes. It's a simple hierarchy of logical building blocks that can be used to model most of the software systems that I've encountered.</p><ul> 
 <li><b>Classes</b>: in an OO world, classes are the smallest building blocks of our software systems.</li> 
 <li><b>Components</b>: components (or services) are typically made up of a number of collaborating classes, all sitting behind a coarse-grained interface. Examples might include a &quot;risk calculator&quot;, &quot;audit component&quot;, &quot;security service&quot;, &quot;e-mail service&quot;, etc depending on what you are building.</li> 
 <li><b>Containers</b>: a container represents something in which components are executed or where data resides. This could be anything from a web or application server through to a rich client application, database or file system. Containers are typically the things that need to be running/available for the software system to work as a whole. The key thing about understanding a software system from a containers perspective is that any inter-container communication is likely to require a remote interface such as a web service call, remote method invocation, messaging, etc.</li> 
 <li><b>System</b>: a system is the highest level of abstraction and represents something that delivers value to, for example, end-users.</li> 
</ul><h2>Summarising the static structure of your software with NoUML</h2><p>By using this set of abstractions to think about a software system, we can now draw a number of simple boxes and lines sketches to summarise the static structure of that software system as follows (you can see <a target="_blank" href="http://www.flickr.com/photos/codingthearchitecture/sets/">some examples on Flickr</a>):</p><ol> 
 <li><b>Context diagram</b>: a very high-level diagram showing your system as a box in the centre, surrounded by other boxes representing the users and all of the other systems that the software system interfaces with. Detail isn't important here as this is your zoomed out view showing a big picture of the system landscape. The focus should be on people (actors, roles, personas, etc) and software systems rather than technologies, protocols and other low-level details. It's the sort of diagram that you could show to non-technical people.</li> 
 <li><b>Containers diagram</b>: a high-level diagram showing the various web servers, application servers, standalone applications, databases, file systems, etc that make up your software system, along with the relationships/interactions between them. This is the diagram that illustrates your high-level technology choices. Focus on showing the logical containers and leave other diagrams (e.g. infrastructure and deployment diagrams) to show the physical instances and deployment mappings.</li> 
 <li><b>Components diagrams</b>: a diagram (one per container) showing the major logical components/services and their relationships. Additional information such as known technology choices for component implementation (e.g. Spring, Hibernate, Windows Communication Foundation, F#, etc) can also be added to the diagram in order to ground the design in reality.</li> 
 <li><b>Class diagrams</b>: this is an optional level of detail and I will typically draw a small number of high-level UML class diagrams if I want to explain how a particular pattern or component will be (or has been) implemented. The factors that prompt me to draw class diagrams for parts of the software system include the complexity of the software plus the size and experience of the team. Any UML diagrams that I do draw tend to be sketches rather than comprehensive models.</li> 
</ol><p>(Click on the image to enlarge it)</p><p class="image-wide"><a _href="resource://2big.png" href="/resource/articles/agile-software-architecture-sketches-NoUML/en/resources/2big.png;jsessionid=D5CD5106370A71357C543A7BFB6967C9"><img vspace="3" hspace="3" align="absBottom" _p="true" _href="img://2small.png" alt="" src="http://www.infoq.com/resource/articles/agile-software-architecture-sketches-NoUML/en/resources/2small.png;jsessionid=D5CD5106370A71357C543A7BFB6967C9" /></a></p><p>A single diagram can quickly become cluttered and confused, but a collection of simple diagrams allows you to easily present the software from a number of different levels of abstraction. And this is an important point because it's not just software developers within the team that need information about the software. There are other stakeholders and consumers too; ranging from non-technical domain experts, testers and management through to technical staff in operations and support functions. For example, a diagram showing the containers is particularly useful for people like operations and support staff that want some technical information about your software system, but don't necessarily need to know anything about the inner workings.</p><h2>Organisational ideas, not a standard</h2><p>This simple sketching approach works for me and many of the software teams that I work with, but it's about about providing some organisational ideas and guidelines rather than creating a prescriptive standard. The goal here is to help teams communicate their software designs in an effective and efficient way rather than creating another comprehensive modelling notation. It's worth reiterating that informal boxes and lines sketches provide flexibility at the expense of diagram consistency because you're creating your own notation rather than using a standard like UML. My advice here is to be conscious of colour-coding, line style, shapes, etc and let a set of consistent notations evolve naturally within your team. Including a simple key/legend on each diagram to explain the notation will help too.</p><p>There seems to be a common misconception that &quot;architecture diagrams&quot; must only present a high-level conceptual view of the world, so it's not surprising that software developers often regard them as pointless. In the same way that software architecture should be about coding, coaching and collaboration rather than ivory towers, software architecture diagrams should be grounded in reality too. Including technology choices (or options) is a usually a step in the right direction and will help prevent diagrams looking like an ivory tower architecture where a bunch of conceptual components magically collaborate to form an end-to-end software system.</p><h2>&quot;Just enough&quot; up front design</h2><p>As a final point, Grady Booch has a great explanation of the difference between architecture and design where he says that architecture represents the &quot;significant decisions&quot;, where significance is measured by cost of change. The context, containers and components diagrams show what I consider to be the significant structural elements of a software system. Therefore, in addition to helping teams with effective and efficient communication, adopting this approach to diagramming can also help software teams that struggle with either doing too much or too little up front design. Starting with a blank sheet of paper, many software systems can be designed and illustrated down to high-level components in a number of hours or days rather than weeks or months. Illustrating the design of your software can be a quick and easy task that, when done well, can really help to introduce technical leadership and instil a sense of a shared technical vision that the whole team can buy into. Sketching should be a skill in every software developer's toolbox. It's a great way to visualise a solution and communicate it quickly plus it paves the way for collaborative design and collective code ownership.</p><h2>About the Author</h2><p><img vspace="3" hspace="3" align="left" _p="true" _href="img://simonbrown.jpg" alt="" src="http://www.infoq.com/resource/articles/agile-software-architecture-sketches-NoUML/en/resources/simonbrown.jpg;jsessionid=D5CD5106370A71357C543A7BFB6967C9" /><strong>Simon&nbsp;Brown</strong> lives in Jersey (Channel Islands) and works as an independent consultant, specialising in software architecture, technical leadership and the balance with agility. Simon regularly speaks at international software development conferences and provides consulting/training to software teams at organisations across Europe, ranging from small startups through to global blue chip companies. He is the founder of <a target="_blank" href="http://www.codingthearchitecture.com">Coding the Architecture</a> (a website about pragmatic, hands-on software architecture) and the author of <a target="_blank" href="http://leanpub.com/software-architecture-for-developers">Software Architecture for Developers</a> (an e-book that is being published incrementally through Leanpub). He still writes code too. Simon can be found on Twitter at <a target="_blank" href="http://twitter.com/simonbrown">@simonbrown</a>.</p><div class="clearer-space"></div><br><br><br><br><br><br></body></html>