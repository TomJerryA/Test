<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>使用函数式编程语言F#编写DDD与CQRS应用</h3><p>在近期的一次<a href="https://www.youtube.com/watch?v=MHvr71T_LZw">演讲</a>中，<a href="http://gorodinski.com/">Lev Gorodinski</a>提出了一种观点，他认为对于<a href="http://en.wikipedia.org/wiki/Domain-driven_design">领域驱动设计</a>（DDD）来说，如果使用<a href="http://en.wikipedia.org/wiki/F_Sharp_(programming_language)">F#</a>这种函数式编程语言来代替C#这种面向对象编程语言进行开发的话，能够带来两个额外的好处，这种方式不仅专注于行为，而且能够更多地使用声明方式来表现代码。讲座中使用的示例用到了包括<a href="https://github.com/eventstore/eventstore/wiki/Event-Sourcing-Basics#event-sourcing">事件溯源</a>（Event Sourcing）和<a href="http://martinfowler.com/bliki/CQRS.html">命令查询责任分离</a>（CQRS）方面的技术。</p>
<p>Lev在过去的一年中在F#上投入了大量的精力，而在近8个月以来则完全专注于F#。在讲座中，Lev所介绍的示例是基于<a href="http://goodenoughsoftware.net/about/">Greg Young</a>最早提出<a href="https://github.com/gregoryyoung/m-r">CQRS时所编写的例子</a>，这个修改后的示例展现了F#的实现方式与C#版本的不同，既体现出其优势也展现出难点所在。而如果转而使用传统的面向对象方式实现该示例的话会有一些问题，例如代码会显示非常冗长，并且领域实体会对事件溯源的实现方式产生依赖。</p>
<p>而使用F#的方式，使用更少的代码反而能改进实现。去掉了许多样板代码之后，使整个代码实现不会显得那么冗长，而且能够更加显式地处理任务。F#代码更能够体现方法的实质，而且也没有隐藏的副作用。对Lev来说，使用F#进行DDD开发的方式能够带来一些额外的好处，因为他能够专注于代码的行为，而不是将精力耗费在实现所必须的一些基础结构代码上，这同时也意味着抛弃了<a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">增删查改</a>（CRUD）这种思考方式。F#方式使得代码表现得更为声明式，与其说是编写代码实现方法，不如说是定义了方法的规格，而由F#代码实现了这个规格。</p>
<p>Lev也提到，这些额外的好处本质上是来源于DDD的天然优势，在<a href="http://www.informit.com/store/domain-driven-design-tackling-complexity-in-the-heart-9780321125217">Eric Evans</a>和<a href="http://www.informit.com/store/implementing-domain-driven-design-9780321834577">Vaughn Vernon</a>的两本关于DDD的书中分别都有列举。在Lev尝试F#实现的过程中，他所遇到的一大挑战是对这种新编范式的应用。在开始阶段，他总是忍不住用C#的风格去实现F#代码。直到一段时间之后才克服了这种问题，并真正转换到函数式编程的风格。并且F#本身既支持函数式编程也支持面向对象编程，这使Lev有时也难以决断到底应该使用哪种风格。</p>
<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/news/2014/03/ddd-cqrs-fsharp">DDD and CQRS Using the Functional Language F#</a></p><br><br><br><br><br><br></body></html>