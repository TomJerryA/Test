<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Java 外部功能接口</h3><p>JDK增强提案（JEP）191定义了<a href="http://openjdk.java.net/jeps/191">Java Foreign Function Interface</a>（FFI），它是可以将本地函数绑定到Java方法以及管理本地内存块的接口。该提案会使得向JDK中添加本地级别的新特性更容易，而且帮助提供了一个用于Java开发的标准FFI。当前，Java Native Interface（JNI）是编写Java本地代码的标准编程接口。JNI创建本地函数的方式并不简单，于是产生了像<a href="https://github.com/twall/jna">Java Native Access</a>（JNA）和<a href="https://github.com/jnr/jnr-ffi">Java Native Runtime</a>（JNR）这样的库。JNA和JNR都是基于JNI创建的，而JEP 191可能会基于JNR。</p>
<p>JEP 191在Java级别提供了类似于JNA或JNR的外部函数接口。开发人员可以通过它轻松地访问本地函数，以及在JVM级别管理本地内存。它还将支持未来针对标准Java FFI的JSR。Java FFI API可用于实现本地支持的功能，像NIO、高级文件系统元数据、进程管理。使用FFI API而不是JNI绑定本地代码和内存将成为开发人员更喜欢的方式。JEP 191并不包含对JNI的增强，不过这些可能会加入到JSR进程中。</p>
<p>目前，JNI是编写Java本地方法以及将Java虚拟机嵌入本地应用程序的标准编程接口。它管理着JVM和非托管的本地环境之间的边界，提供数据编组和对象生命周期管理协议。根据JEP 191，JNI在下列几个方面最令开发人员痛苦：</p>
<ul> 
 <li>需要开发人员编写C代码，这意味着他们需要具备一个完全不同于Java的世界的专业知识。</li> 
 <li>由于开发人员必须对JVM如何管理内存和代码多少有一些了解，所以典型的C和Java开发人员通常并不具备使用JNI所需的专业知识。</li> 
 <li>开发人员必须能够为他们想要支持的每个平台构建代码，或者为终端用户提供适当的工具，由他们来完成这项工作。</li> 
 <li>相比于相同的库绑定到本地应用程序，基于JNI的库性能通常较差。</li> 
 <li>JNI充当了一个不透明的安全边界。JDK并不知道库中的函数可能会调用什么，或者库中的代码是否会损害JVM的稳定或安全。</li> 
</ul>
<p>JNI的问题可以通过在JDK中内建FFI API来解决。Java FFI将更容易实现，而且不需要太多关于JVM内部原理和各种宿主平台的专业知识。FFI API将提供下列特性：</p>
<ul> 
 <li>一个描述本地库调用和本地内存结构的元数据系统。</li> 
 <li>发现和加载本地库的机制。</li> 
 <li>基于元数据将库/函数或内存结构绑定到Java端点的机制。</li> 
 <li>用于Java数据类型和本地数据类型之间编组和解组的代码。</li> 
</ul>
<p>JEP 191还可能增加本地调用的JIT优化、GC层可知的本地内存和选择取消已知不必要的JNI安全保护的机制。它还会包含基于JRuby ffi-gen库的工具，用于从本地库收集函数和内存的元数据。开发人员还可以设置安全策略，允许绑定到特定函数，而不是库级别的权限。</p>
<p>对Java FFI的需求已经产生了JNA和JNR库。JNA库应用更广泛。JNR库更全面，因为它实现了不同层次的抽象，提供了函数和内存元数据，对库和函数绑定进行了抽象。JNR已经在JRuby项目中大量使用，它可能会成为JEP 191的基础。</p>
<p><b>查看英文原文：</b><b><a href="http://www.infoq.com/news/2014/03/java-foreign-function-interface">Java Foreign Function Interface</a></b></p><br><br><br><br><br><br></body></html>