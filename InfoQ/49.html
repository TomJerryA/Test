<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Weathr：综合演示C++ 14、DirectX和XAML</h3><p>大多数技术演示都是相当轻量级的，只是用很小的应用演示一些关键概念。Weathr却并非如此，它是一个全功能的3D气象图，同时提供了在线服务集成和语义缩放（semantic zoom）。</p>
<p><a href="http://weathr.codeplex.com/">Weathr</a> 的核心是使用现代编码约定的ISO C++。这意味着不使用new和delete关键字。相反，几乎所有东西都是通过组合使用shared、unique和weak智能指针来处理的。</p>
<p>用户界面基于DirectX和XAML构建，其中前者用于3D组件。后者需要使用C++/CX，这是微软专门为基于WinRT的应用创建的语言扩展。</p>
<p>演示的另一项技术是PPL（<a href="http://msdn.microsoft.com/en-us/library/dd492427.aspx#task_class">Parallel Patterns Library</a>）。该库支持使用通过lambda表达式链接在一起的异步方法。PPL主要用于通过<a href="http://msdn.microsoft.com/en-us/library/jj969455.aspx">C++ REST SDK</a>和Bing Maps及World Weather Online交互。异步条件下的内存管理有点棘手，所以Thomas Petchel写道：</p>
<blockquote> 
 <p>当有一组链接到一起的异步任务，而且一个任务负责创建一个对象或资源，而随后的另一个任务使用该资源时，我发现的另一个模式就出现了。尽管通常可以简单地在一个任务中创建该资源，然后将其传递给随后的任务，但是这并不是总能行得通的。这是生命周期与间接性的问题——不管对象是C++还是C++/CX类型的，因为我们异步工作，负责准备背景工作的调用函数很快就会退出，因此任何分配在该函数的栈上的对象都会走出其作用域。为使对象在活动的任务间共享，必须获取所有lambda表达式或仿函数（functor）中引用这些对象的智能指针（通常是C++和C++/CX对象的shared_ptr）。通过使用shared_ptr，我们创建了一个间接层，支持对象在一个任务中分配（例如，写入一个任务中），然后在随后的任务中使用（例如读取）。</p> 
</blockquote>
<p>确保async回调在正确的线程上运行是另一个问题。对于验证线程，Thomas有如下提示：</p>
<blockquote> 
 <p>在调试构建版本中，在启动时记录ASTA线程的线程ID。在每个任务延续（task continuation）中，确认我们是在主线程（ASTA）还是后台线程上运行。</p> 
 <p>在任务延续中，显式地指定是要在当前上下文（例如，建立任务链的上下文，它可能是ASTA线程或MTA线程）上运行，还是要在后台（MTA）上下文上运行。</p> 
</blockquote>
<p>该示例应用中也探索了其他技巧与技术，包括HTTP请求节流、语义缩放、<a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.input.gesturerecognizer.aspx">手势识别</a>和Windows 8动态磁贴。</p>
<p><a href="http://weathr.codeplex.com/">Weathr</a>基于Apache 2许可发布，可以在CodePlex上获取。</p>
<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/news/2014/02/Weathr">Weathr, a Comprehensive Demonstration of C++ 14, DirectX, and XAML</a></p><br><br><br><br><br><br></body></html>