<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Java 8: Expressões lambda e coleções</h3><p>Faltando pouco para o lan&ccedil;amento do Java 8, vale a pena rever o post publicado por Brian Goetz, cobrindo as melhorias na API de cole&ccedil;&otilde;es do Java: &quot;<a href="http://cr.openjdk.java.net/~briangoetz/lambda/sotc3.html">O Estado do Lambda</a>&quot;. A introdu&ccedil;&atilde;o de express&otilde;es lambda &eacute; uma das funcionalidades mais esperadas do Java 8, e o suporte a elas na Collections API &eacute; fundamental para garantir ampla utiliza&ccedil;&atilde;o das bibliotecas. Para conhecer mais sobre o que vem sendo feito nessa &aacute;rea do Java, consulte <a href="http://www.infoq.com/br/news/2011/12/java8-lambda;jsessionid=8AE78ACEED482FB52AF3779C9DD03C48">nosso texto</a> sobre o post anterior de Goetz.</p> 
<p>Uma vez que n&atilde;o &eacute; pr&aacute;tico substituir toda a biblioteca Collections, &eacute; necess&aacute;rio estend&ecirc;-la com o suporte a lambdas. O plano &eacute; utilizar itera&ccedil;&atilde;o interna, ou seja, passando um lambda ao forEach() na cole&ccedil;&atilde;o, como alternativa &agrave; implementa&ccedil;&atilde;o externa utilizada atualmente, como por exemplo Iterator e Enumeration. Uma nova interface denominada Stream ser&aacute; adicionada para suportar uma sequ&ecirc;ncia de valores potencialmente sob demanda (lazy), juntamente com m&eacute;todos como stream() para converter uma cole&ccedil;&atilde;o em um stream ou fluxo (que pode tamb&eacute;m ser sob demanda).</p> 
<p>Os streams s&atilde;o diferentes das classes gerais da API Collections, pois n&atilde;o possuem armazenamento, podendo ser infinitos ou lidos sob demanda. S&atilde;o em ess&ecirc;ncia processados funcionalmente e podem ser gerados sob demanda. Por exemplo, um Stream pode ser criado para representar n&uacute;meros primos, com cada novo elemento produzindo o pr&oacute;ximo n&uacute;mero na sequ&ecirc;ncia.</p> 
<p>A interface Stream tamb&eacute;m vai trazer uma s&eacute;rie de m&eacute;todos funcionais, incluindo forEach(), filter(), fold(), anyMatch(), map(), e flatMap(). A interface pode ser constru&iacute;da de acordo com o tipo espec&iacute;fico de cole&ccedil;&atilde;o utilizada, ou pode ser implementada de maneira gen&eacute;rica, para possibilitar a utiliza&ccedil;&atilde;o de outras classes. Esse modo de opera&ccedil;&atilde;o sob demanda (lazy) significa que o stream pode ser consumido, filtrado e mapeado juntamente com uma opera&ccedil;&atilde;o como findFirst(). Pode ser feito um encadeamento e concluir assim que a primeira equival&ecirc;ncia for encontrada, em vez de se iterar por toda a cole&ccedil;&atilde;o. Veja um exemplo mencionado no <a href="http://cr.openjdk.java.net/~briangoetz/lambda/sotc3.html">artigo</a> &quot;Estado das Cole&ccedil;&otilde;es&quot;, tamb&eacute;m por Goetz:</p> 
<pre>
Optional&lt;Shape&gt; firstBlue =
 shapes.stream()
  .filter(s -&gt; s.getColor() == BLUE)
  .findFirst();
</pre> 
<p>O pacote java.util.function ter&aacute; um conjunto inicial de interfaces funcionais como Predicate, Function, UnaryOperator e BinaryOperator, com a ideia de que os desenvolvedores ser&atilde;o capazes de adicionar sua pr&oacute;pria interface funcional. O pacote funcional tamb&eacute;m introduz um novo tipo, Optional, que fornece um mecanismo para representar valores potencialmente nulos. Essa classe wrapper (&quot;inv&oacute;lucro&quot;) possui uma &uacute;nica inst&acirc;ncia de um tipo, ou representa o valor nulo de maneira segura.</p> 
<p>Nem todos est&atilde;o satisfeitos com essa estrutura, como mostra esta <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006324.html">longa discuss&atilde;o</a>. Outras linguagens, como Scala e Haskell, ofercem uma vis&atilde;o mais funcional de Optional, como um <a href="http://www.haskell.org/haskellwiki/Monad">monad</a>; mas, como Brian Goetz <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006365.html">diz</a> que h&aacute; muitos entendimentos diferentes do conceito de &quot;Optional&quot; que &quot;n&atilde;o &eacute; a inten&ccedil;&atilde;o de tornar o Java em algo como Scala ou Haskell&quot;. Embora algumas linguagens de tipagem forte ou de nicho v&atilde;o mais al&eacute;m em design funcional, a maioria dos milh&otilde;es de desenvolvedores Java n&atilde;o estar&aacute; familiarizada com programa&ccedil;&atilde;o funcional, e oferecer o maior benef&iacute;cio para o maior n&uacute;mero de desenvolvedores &eacute; um objetivo fundamental para a Oracle.</p> 
<p>A adi&ccedil;&atilde;o de streams e functions &agrave; linguagem Java tamb&eacute;m possibilita a paraleliza&ccedil;&atilde;o de opera&ccedil;&otilde;es. Dado um stream l&oacute;gico de dados, os resultados podem ser divididos em diferentes n&iacute;veis de parti&ccedil;&otilde;es e entregues para uma arquitetura de processamento paralelo, como o framework fork/join. A proposta atual introduz o Spliterator, que pode ser utilizado para particionar um bloco maior de dados em blocos menores, apropriados para serem processados em paralelo. Ao oferecer uma maneira gen&eacute;rica de particionar uma estrutura de dados em partes menores, o Spliterator possibilita um particionamento eficiente de dados, ao mesmo tempo permitindo que o framework fork/join opere em um conjunto de dados gen&eacute;ricos.</p> 
<p>Finalmente, parece que a paix&atilde;o pelo lambda est&aacute; crescendo e influenciando a EL (Expression Language) do Java EE. Anteriormente, havia constru&ccedil;&otilde;es como o LINQ (Language Integrated Query) para realizar processamento de dados, mas com a chegada do suporte a lambda foi <a href="http://java.net/projects/el-spec/lists/jsr341-experts/archive/2012-10/message/0">decidido</a> que a EL deve adotar parte da sintaxe lambda a fim de aumentar a compatibilidade com a linguagem Java.</p> 
<p id="lastElm"></p><br><br><br><br><br><br></body></html>