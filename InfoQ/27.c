<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Princ√≠pios SOLID de design para JavaScript</h3><p>Muitos desenvolvedores t&ecirc;m trabalhado com linguagens orientadas a objetos e muitos est&atilde;o trabalhando com JavaScript, mas pouqu&iacute;ssimos utilizam os princ&iacute;pios de orienta&ccedil;&atilde;o a objetos juntamente com o JavaScript, declarou <a href="http://lostechies.com/derickbailey/">Derick Bailey</a>, autor e desenvolvedor focado em JavaScript, em uma <a href="http://www.youtube.com/watch?v=TAVn7s-kO9o">apresenta&ccedil;&atilde;o</a> no <a href="http://codemash.org/">CodeMash</a>. Na programa&ccedil;&atilde;o orientada a objetos n&oacute;s falamos sobre fundamentos e princ&iacute;pios como base para nosso trabalho, mas quando mudamos de uma linguagem baseada em classes est&aacute;ticas para <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing">linguagens fracamente tipadas</a>, freq&uuml;entemente achamos dif&iacute;cil aplicar os mesmos princ&iacute;pios.</p>
<p>Derick acredita que existem v&aacute;rios bons princ&iacute;pios, pr&aacute;ticas e padr&otilde;es dispon&iacute;veis para ajudar os desenvolvedores a escreverem c&oacute;digos bons e est&aacute;veis em JavaScript, um exemplo disso s&atilde;o os princ&iacute;pios <a href="http://en.wikipedia.org/wiki/SOLID">SOLID</a>, identificados por <a href="http://en.wikipedia.org/wiki/Robert_c_martin">Robert C. Martin</a>, no come&ccedil;o dos anos 2000.</p>
<p>Ele descreve os princ&iacute;pios SOLID como cinco padr&otilde;es individuais que funcionam bem juntos e caminha pelos princ&iacute;pios utilizando exemplos de c&oacute;digos e procurando algumas particularidades em JavaScript que possam fazer a aplica&ccedil;&atilde;o desses princ&iacute;pios um pouco diferente, quando comparados a quando s&atilde;o utilizados em linguagens como Java e C#.</p>
<p>As defini&ccedil;&otilde;es de Derick para os cinco princ&iacute;pios s&atilde;o</p>
<ul class="c16 lst-kix_7cxsc0c3vn1o-0 start"> 
 <li><strong>Princ&iacute;pio da Responsabilidade &Uacute;nica.</strong> Tudo deve possuir apenas uma raz&atilde;o para mudar. Isso ajudar&aacute; os desenvolvedores a entender o contexto e a responsabilidade do que eles est&atilde;o construindo e quando existe uma necessidade de mudan&ccedil;a.</li> 
 <li><strong>Princ&iacute;pio Aberto-Fechado.</strong> A mudan&ccedil;a de comportamento deve ser poss&iacute;vel sem alterar c&oacute;digo existente. Por exemplo, utilizando pontos de exten&ccedil;&atilde;o, onde a classe base n&atilde;o &eacute; alterada, mas tem seu comportamento complementado atrav&eacute;s de abstra&ccedil;&otilde;es e/ou interfaces, criando c&oacute;digo que pode ser plugado ao j&aacute; existente.</li> 
 <li><strong>Princ&iacute;pio da Substitui&ccedil;&atilde;o de Liskov</strong>. Objetos derivados ou tipos devem ser subistitu&iacute;veis pelo seu tipo base. Para Derick, essa &eacute; a vers&atilde;o mais focada do princ&iacute;pio Aberto-Fechado.</li> 
 <li><strong>Princ&iacute;pio de Segrega&ccedil;&atilde;o de Interfaces.</strong> Um cliente n&atilde;o deve ser for&ccedil;ado a depender de interfaces que n&atilde;o usa. O problema &eacute; que n&atilde;o existem interfaces expl&iacute;citas no JavaScript, <a href="http://jscriptpatterns.blogspot.com.br/2013/01/javascript-interfaces.html">mas existem formas de contornar isso</a>.</li> 
 <li><strong>Princ&iacute;pio de Invers&atilde;o de Depend&ecirc;ncias</strong>. Consiste em dois conceitos, abstra&ccedil;&atilde;o, que define que n&oacute;s devemos depender de abstra&ccedil;&otilde;es, n&atilde;o de implementa&ccedil;&otilde;es concretas e propriedade, que define que a implementa&ccedil;&atilde;o de baixo n&iacute;vel deve depender de conceitos de alto n&iacute;vel.</li> 
</ul>
<p>Derick finaliza declarando que se voc&ecirc; possui grandes blocos monol&iacute;ticos de c&oacute;digo em seu sistema, os princ&iacute;pios SOLID ir&atilde;o ajud&aacute;-lo a quebrar esses blocos em pe&ccedil;as individuais, menores. Isso n&atilde;o ir&aacute; diminuir a complexidade, mas ir&aacute; ajud&aacute;-lo a criar abstra&ccedil;&otilde;es e agrupar detalhes em conceitos maiores, nos quais conseguimos pensar com maior facilidade.</p><br><br><br><br><br><br></body></html>