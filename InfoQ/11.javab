<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Apache Kafka: Next Generation Distributed Messaging System</h3><h2>&nbsp;</h2>
<h2>Introduction</h2>
<p><a href="http://kafka.apache.org/">Apache Kafka</a> is a distributed publish-subscribe messaging system. It was originally developed at LinkedIn Corporation and later on became a part of Apache project. Kafka is a fast, scalable, distributed in nature by its design, partitioned and replicated commit log service.</p>
<p>Apache Kafka differs from traditional messaging system in:</p>
<ul> 
 <li>It is designed as a distributed system which is very easy to scale out.</li> 
 <li>It offers high throughput for both publishing and subscribing.</li> 
 <li>It supports multi-subscribers and automatically balances the consumers during failure.</li> 
 <li>It persist messages on disk and thus can be used for batched consumption such as <a href="http://en.wikipedia.org/wiki/Extract,_transform,_load">ETL</a>, in addition to real time applications.</li> 
</ul>
<p>In this article, I will highlight the architecture points, features and characteristics of Apache Kafka that will help us to understand how Kafka is better than traditional message server.</p>
<p>I will compare the traditional message server <a href="https://www.rabbitmq.com/">RabbitMQ</a> and Apache <a href="http://activemq.apache.org/">ActiveMQ</a> characteristics with Kafka and discuss certain scenarios where Kafka is a better solution than traditional message server. In the last section, we will explore a working sample application to showcase Kafka usage as message server. Complete source code of the sample application is available on <a href="https://github.com/abhioncbr/Kafka-Message-Server">GitHub</a>. A detailed discussion around sample application is in the last section of this article.</p>
<h2>Architecture</h2>
<p>Firstly, I want to introduce the basic concepts of Kafka. Its architecture consists of the following components:</p>
<ul> 
 <li>A stream of <b>messages</b> of a particular type is defined as a <b>topic.</b> A <b>Message </b>is defined as a payload of bytes and a <b>Topic </b>is a category or feed name to which messages are published.</li> 
 <li>A <b>Producer </b>can be anyone who can publish messages to a Topic.</li> 
 <li>The published messages are then stored at a set of servers called <b>Brokers or Kafka Cluster</b>.</li> 
 <li>A <b>Consumer </b>can subscribe to one or more Topics and consume the published Messages by pulling data from the Brokers.</li> 
</ul>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/7Fig1.png" alt="" _href="img://7Fig1.png" _p="true" /></p>
<div id="lowerFullwidthVCR"></div>
<p><b><small>Figure 1: Kafka Producer, Consumer and Broker environment</small></b></p>
<p>Producer can choose their favorite serialization method to encode the message content. For efficiency, the producer can send a set of messages in a single publish request. Following code examples shows how to create a Producer to send messages.</p>
<p><strong>Sample producer code:</strong></p>
<pre>
producer = new Producer(…); <br />message = new Message(“test message str”.getBytes()); <br />set = new MessageSet(message); <br />producer.send(“topic1”, set); 
</pre>
<p>For subscribing topic, a consumer first creates one or more message streams for the topic. The messages published to that topic will be evenly distributed into these streams. Each message stream provides an iterator interface over the continual stream of messages being produced. The consumer then iterates over every message in the stream and processes the payload of the message. Unlike traditional iterators, the message stream iterator never terminates. If currently no message is there to consume, the iterator blocks until new messages are published to the topic. Kafka supports both the point-to-point delivery model in which multiple consumers jointly consume a single copy of message in a queue as well as the publish-subscribe model in which multiple consumers retrieve its own copy of the message. Following code examples shows a Consumer to consume messages.</p>
<p><strong>Sample consumer code:</strong></p>
<pre>
streams[] = Consumer.createMessageStreams(“topic1”, 1) <br />for (message : streams[0]) { <br />bytes = message.payload(); <br />// do something with the bytes <br />} </pre>
<p>The overall architecture of Kafka is shown in Figure 2. Since Kafka is distributed in nature, a Kafka cluster typically consists of multiple brokers. To balance load, a topic is divided into multiple partitions and each broker stores one or more of those partitions. Multiple producers and consumers can publish and retrieve messages at the same time.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/3Fig2.png" alt="" _href="img://3Fig2.png" _p="true" /></p>
<p><b><small>Figure 2: Kafka Architecture</small></b></p>
<h2>Kafka Storage</h2>
<p>Kafka has a very simple storage layout. Each partition of a topic corresponds to a logical log. Physically, a log is implemented as a set of segment files of equal sizes. Every time a producer publishes a message to a partition, the broker simply appends the message to the last segment file. Segment file is flushed to disk after configurable numbers of messages have been published or after a certain amount of time elapsed. Messages are exposed to consumer after it gets flushed.</p>
<p>Unlike traditional message system, a message stored in Kafka system doesn’t have explicit message ids.</p>
<p>Messages are exposed by the logical offset in the log. This avoids the overhead of maintaining auxiliary, seek-intensive random-access index structures that map the message ids to the actual message locations. Messages ids are incremental but not consecutive. To compute the id of next message adds a length of the current message to its logical offset.</p>
<p>Consumer always consumes messages from a particular partition sequentially and if the consumer acknowledges particular message offset, it implies that the consumer has consumed all prior messages. Consumer issues asynchronous pull request to the broker to have a buffer of bytes ready to consume. Each asynchronous pull request contains the offset of the message to consume. Kafka exploits the <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile API</a> to efficiently deliver bytes in a log segment file from a broker to a consumer.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/3Fig3.png" alt="" _href="img://3Fig3.png" _p="true" /></p>
<p><b><small>Figure 3: Kafka Storage Architecture</small></b></p>
<h2>Kafka Broker</h2>
<p>Unlike other message system, Kafka brokers are stateless. This means that the consumer has to maintain how much it has consumed. Consumer maintains it by itself and broker would not do anything. Such design is very tricky and innovative in itself.</p>
<ul> 
 <li>It is very tricky to delete message from the broker as broker doesn't know whether consumer consumed the message or not. Kafka innovatively solves this problem by using a simple time-based SLA for the retention policy. A message is automatically deleted if it has been retained in the broker longer than a certain period.</li> 
 <li>This innovative design has a big benefit, as consumer can deliberately rewind back to an old offset and re-consume data. This violates the common contract of a queue, but proves to be an essential feature for many consumers.</li> 
</ul>
<h2>Zookeeper and Kafka</h2>
<p>Consider a distributed system with multiple servers, each of which is responsible for holding data and performing operations on that data. Some potential examples are distributed search engine, distributed build system or known system like <a href="http://hadoop.apache.org/">Apache Hadoop</a>. One common problem with all these distributed systems is how would you determine which servers are alive and operating at any given point of time? Most importantly, how would you do these things reliably in the face of the difficulties of distributed computing such as network failures, bandwidth limitations, variable latency connections, security concerns, and anything else that can go wrong in a networked environment, perhaps even across multiple data centers? These types of questions are the focus of <a href="http://zookeeper.apache.org/">Apache ZooKeeper</a>, which is a fast, highly available, fault tolerant, distributed coordination service. Using ZooKeeper you can build reliable, distributed data structures for group membership, leader election, coordinated workflow, and configuration services, as well as generalized distributed data structures like locks, queues, barriers, and latches. Many well-known and successful projects already rely on ZooKeeper. Just a few of them include HBase, Hadoop 2.0, Solr Cloud, Neo4J, <a href="http://incubator.apache.org/blur/">Apache Blur</a> (incubating), and Accumulo.</p>
<p>ZooKeeper is a distributed, hierarchical file system that facilitates loose coupling between clients and provides an eventually consistent view of its znodes, which are like files and directories in a traditional file system. It provides basic operations such as creating, deleting, and checking existence of znodes. It provides an event-driven model in which clients can watch for changes to specific znodes, for example if a new child is added to an existing znode. ZooKeeper achieves high availability by running multiple ZooKeeper servers, called an <b>ensemble</b>, with each server holding an in-memory copy of the distributed file system to service client read requests.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/3Fig4.png" alt="" _href="img://3Fig4.png" _p="true" /></p>
<p><b><small>Figure 4: ZooKeeper Ensemble Architecture</small></b></p>
<p>Figure 4 above shows typical ZooKeeper ensemble in which one server acting as a leader while the rest are followers. On start of ensemble leader is elected first and all followers replicate their state with leader. All write requests are routed through leader and changes are broadcast to all followers. Change broadcast is termed as <b><i>atomic broadcast</i></b>.</p>
<p><b>Usage of Zookepper in Kafka: </b>As for coordination and facilitation of distributed system ZooKeeper is used, for the same reason Kafka is using it. ZooKeeper is used for managing, coordinating Kafka broker. Each Kafka broker is coordinating with other Kafka brokers using ZooKeeper. Producer and consumer are notified by ZooKeeper service about the presence of new broker in Kafka system or failure of the broker in Kafka system. As per the notification received by the Zookeeper regarding presence or failure of the broker producer and consumer takes decision and start coordinating its work with some other broker. Overall Kafka system architecture is shown below in Figure 5 below.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/3Fig5.png" alt="" _href="img://3Fig5.png" _p="true" /></p>
<p><b><small>Figure 5: Overall Kafka architecture as distributed system</small></b></p>
<h2>Apache Kafka v. other message servers</h2>
<p>We’ll look at two different projects using Apache Kafka to differentiate from other message servers. These projects are LinkedIn and mine project is as follows:</p>
<h2>LinkedIn Study</h2>
<p>LinkedIn team conducted an <a href="http://research.microsoft.com/en-us/um/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf">experimental study</a>, comparing the performance of Kafka with Apache ActiveMQ version 5,4 and RabbitMQ version 2.4. They used ActiveMQ’s default persistent message store <a href="http://activemq.apache.org/kahadb.html">kahadb</a>. LinkedIn ran their experiments on two Linux machines, each with 8 2GHz cores, 16GB of memory, 6 disks with RAID 10. Two machines are connected with a 1GB network link. One of the machines was used as the Broker and the other machine was used as the Producer or the Consumer.</p>
<h3>Producer Test</h3>
<p>LinkedIn configured the broker in all systems to asynchronously flush messages to its persistence store. For each system, they ran a single Producer to publish a total of 10 million messages, each of 200 bytes. Kafka producer send messages in batches of size 1 and 50. ActiveMQ and RabbitMQ don’t seem to have an easy way to batch messages and LinkedIn assumes that it used a batch size of 1. Result graph is shown in Figure 6 below:</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/1Fig6.png" alt="" _href="img://1Fig6.png" _p="true" /></p>
<p><b><small>Figure 6: Producer performance result of LinkedIn experiment</small></b></p>
<p><b>Few reasons why Kafka output is much better are as follows:</b></p>
<ul> 
 <li>Kafka producer doesn’t wait for acknowledgements from the broker and sends messages as faster as the broker can handle.</li> 
 <li>Kafka has a more efficient storage format. On average, each message had an overhead of 9 bytes in Kafka, versus 144 bytes in ActiveMQ. This is because of overhead of heavy message header, required by JMS and overhead of maintaining various indexing structures. LinkedIn observed that one of the busiest threads in ActiveMQ spent most of its time accessing a B-Tree to maintain message metadata and state.</li> 
</ul>
<h3>Consumer Test</h3>
<p>For consumer test LinkedIn used a single consumer to retrieve a total of 10 million messages. LinkedIn configured all systems so that each pull request should prefetch approximately the same amount data---up to 1,000 messages or about 200KB. For both ActiveMQ and RabbitMQ, LinkedIn set the consumer acknowledgement mode to be automatic. The results are presented in Figure 7.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/1Fig7.png" alt="" _href="img://1Fig7.png" _p="true" /></p>
<p><b><small>Figure 7: Consumer performance result of LinkedIn experiment</small></b></p>
<p><b>Few reasons why Kafka output is much better are as follows:</b></p>
<ul> 
 <li>Kafka has a more efficient storage format; fewer bytes were transferred from the broker to the consumer in Kafka.</li> 
 <li>The broker in both ActiveMQ and RabbitMQ containers had to maintain the delivery state of every message. LinkedIn team observed that one of the ActiveMQ threads was busy writing KahaDB pages to disks during this test. In contrast, there were no disk write activities on the Kafka broker. Finally, by using the sendfile API, Kafka reduces the transmission overhead</li> 
</ul>
<p>Currently I am working in a project which provides real-time service that quickly and accurately extracts OTC(over the counter) pricing content from messages. Project is very critical in nature as it deals with financial information of nearly 25 asset classes including Bonds, Loans and ABS(Asset Backed Securities). Project raw information sources cover major financial market areas of Europe, North America, Canada and Latin America. Below are some stats about the project which show how important it is to have an efficient distributed message server as part of the solution:</p>
<ul> 
 <li><b>1,300,000+ </b>messages daily</li> 
 <li><b>12,000,000+</b>OTC prices parsed daily</li> 
 <li><b>25+ </b>supported asset classes</li> 
 <li><b>70,000+</b> unique instruments parsed daily.</li> 
</ul>
<p>Messages contain PDF, Word documents, Excel files and certain other formats. OTC prices are also extracted from the attachments.</p>
<p>Because of the performance limitations of traditional message servers, as message queue becomes large while processing large attachment files, our project was facing serious problems and JMSqueue needed to be started two to three times in a day. Restarting a JMS Queue potentially loses the entire messages in the queue. Project needed a framework which can hold messages irrespective of the parser (consumer) behavior. Kafka features are well suited for the requirements in our project.</p>
<p>Features of the project in current setup:</p>
<ol> 
 <li>Fetchmail utility is used for remote-mail retrieval of messages which are further processed by the usage of Procmail utility filters like separate distribution of attachment based messages.</li> 
 <li>Each message is retrieved in a separate file which is processed (read &amp; delete) for insertion as a message in message server.</li> 
 <li>Message content is retrieved from message server queue for parsing and information extraction.</li> 
</ol>
<h2>Sample Application</h2>
<p>Sample application is modified version of the original application which I am using in my project. I have tried to make artifacts of sample application simple by removing the usage of logging and multi-threading features. Intent of sample application is to show how to use Kafka producer and consumer API. Application contains a <a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/Kafka-Message-Server-Example/src/main/java/com/kafka/message/server/example/core/KafkaMailProducer.java">sample producer</a> (simple producer code to demonstrate Kafka producer API usage and publish messages on a particular topic), <a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/Kafka-Message-Server-Example/src/main/java/com/kafka/message/server/example/core/KafkaMailConsumer.java">sample consumer</a> (simple consumer code to demonstrate Kafka consumer API usage) and <a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/Kafka-Message-Server-Example/src/main/java/com/kafka/message/server/example/other/launch/CreateFile.java">message content generation</a> (API to generate message content in a file at a particular file path)API. Below Figure shows the components and their relation with other components in the system.</p>
<p><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/Fig8-small.png" alt="" _href="img://Fig8-small.png" _p="true" /></p>
<p><b><small>Figure 8: Sample application architecture components</small></b></p>
<p>Sample application has a similar structure of the example application presented in Kafka source code. Source code of the application contains the <b><i>‘src’</i></b> java source folder and <b><i>‘config’</i></b> folder containing several configuration files and shell scripts for the execution of the sample application. For executing sample application, please follow the instructions mentioned in <a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/README.md">ReadMe.md</a> file or <a href="https://github.com/abhioncbr/Kafka-Message-Server/wiki/How-to-run-sample-application">Wiki page</a> on Github website.</p>
<p>Application code is <a href="http://maven.apache.org/">Apache Maven</a> enabled and is very easy to setup for customization. Several Kafka build scripts are also modified for re-building the sample application code if anyone wants to modify or customize the sample application code. Detailed description about how to customize the sample application is documented in project’s <a href="https://github.com/abhioncbr/Kafka-Message-Server/wiki/How-to-customize-sample-application">Wiki page</a> on GitHub.</p>
<p>Now let’s have a look on the core artifacts of the sample application.</p>
<p><a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/Kafka-Message-Server-Example/src/main/java/com/kafka/message/server/example/core/KafkaMailProducer.java">Kafka Producer code example</a></p>
<pre>
/** <br /> * Instantiates a new Kafka producer. <br /> * <br /> * @param topic the topic <br /> * @param directoryPath the directory path <br /> */ <br />public KafkaMailProducer(String topic, String directoryPath) { <br />       props.put(&quot;serializer.class&quot;, &quot;kafka.serializer.StringEncoder&quot;); <br />       props.put(&quot;metadata.broker.list&quot;, &quot;localhost:9092&quot;); <br />       producer = new kafka.javaapi.producer.Producer&lt;Integer, String&gt;(new ProducerConfig(props)); <br />       this.topic = topic; <br />       this.directoryPath = directoryPath; <br />} 
<br />public void run() { <br />      Path dir = Paths.get(directoryPath); <br />      try { <br />           new WatchDir(dir).start(); <br />           new ReadDir(dir).start(); <br />      } catch (IOException e) { <br />           e.printStackTrace(); <br />      } <br />} </pre>
<p>Above code snippet has basic Kafka producer API usage like setting up property of the producer i.e. on which topic messages are going to publish, which serializer class we can use and information regarding broker. Basic functionality of the class is to read the email message file from email directory and publish it as a message on Kafka broker. Directory is watched using java.nio.WatchService class and as soon as email message is dumped in to the directory it will be read up and published on Kafka broker as a message.</p>
<p><a href="https://github.com/abhioncbr/Kafka-Message-Server/blob/master/Kafka-Message-Server-Example/src/main/java/com/kafka/message/server/example/core/KafkaMailConsumer.java">Kafka Consumer code example</a></p>
<pre>
public KafkaMailConsumer(String topic) { <br />       consumer = 
Kafka.consumer.Consumer.createJavaConsumerConnector(createConsumerConfig()); <br />       this.topic = topic; <br />} 
<br />/** <br /> * Creates the consumer config. <br /> * <br /> * @return the consumer config <br /> */ <br />private static ConsumerConfig createConsumerConfig() { <br />      Properties props = new Properties(); <br />      props.put(&quot;zookeeper.connect&quot;, KafkaMailProperties.zkConnect); <br />      props.put(&quot;group.id&quot;, KafkaMailProperties.groupId); <br />      props.put(&quot;zookeeper.session.timeout.ms&quot;, &quot;400&quot;); <br />      props.put(&quot;zookeeper.sync.time.ms&quot;, &quot;200&quot;); <br />      props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;); <br />      return new ConsumerConfig(props); <br />} 
<br />public void run() { <br />      Map&lt;String, Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); <br />      topicCountMap.put(topic, new Integer(1)); <br />      Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCountMap); <br />      KafkaStream&lt;byte[], byte[]&gt; stream = consumerMap.get(topic).get(0); <br />      ConsumerIterator&lt;byte[], byte[]&gt; it = stream.iterator();<br />      while (it.hasNext()) <br />      System.out.println(new String(it.next().message())); <br />}</pre>
<p>Above code shows basic consumer API. As mentioned above consumer needs to set stream of messages for consumption. In run method this is what we are doing and then printing a consumed message on the console. In my project we are using to feed into the parser system to extract OTC prices.</p>
<p>We using Kafka as the message server currently in our QA system as Proof of Concept (POC) project and the overall performance looks better than JMS message server. One positive feature we are excited about is the re-consumption of messages which enables our parsing system to re-parse certain messages as per the business needs. Based on the positive response of Kafka we are now planning to use it as a log aggregator and analyze logs instead of using Nagios system.</p>
<h2>Conclusion</h2>
<p>Kafka is a novel system for processing of large chunks of data. Pull-based consumption model of Kafka allows a consumer to consume messages at its own speed. If some exception occurs while consuming the messages, the consumer has always a choice to re-consume the message.</p>
<h2>About the Author</h2>
<p><strong><img src="http://www.infoq.com/resource/articles/apache-kafka/en/resources/Abhishek.jpg" vspace="3" hspace="3" align="left" alt="" _href="img://Abhishek.jpg" _p="true" />Abhishek Sharma</strong> is Natural language processing (NLP), machine learning and parser programmer for financial domain products. He works in algorithm designing and parser development for various companies. Abhishek’s interest is in distributed systems, natural language processing and big data analytics using machine learning algorithms.</p><br><br><br><br><br><br></body></html>