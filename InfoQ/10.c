<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Async/Await - Efeitos sobre desempenho e outras armadilhas</h3><p>O artigo do MSDN intitulado &quot;<a href="http://msdn.microsoft.com/en-us/magazine/jj991977.aspx">Melhores Pr&aacute;ticas da Programa&ccedil;&atilde;o Ass&iacute;ncrona (Best Practices in Asynchronous Programming</a>)&quot; apresenta algumas considera&ccedil;&otilde;es interessantes:</p>
<ul> 
 <li>De prefer&ecirc;ncia as tarefas <i>async</i> sobre m&eacute;todos <i>async</i> sem valor de retorno (aqueles que retornam <i>void</i>). Isso n&atilde;o se aplica para tratamento de eventos. Keith Patton da <a href="http://www.markermetro.com/">Marker Metro</a> tamb&eacute;m <a href="http://www.markermetro.com/2013/01/technical/handling-unhandled-exceptions-with-asyncawait-on-windows-8-and-windows-phone-8/">explica isso em detalhes</a>;</li> 
 <li>Evite misturar c&oacute;digo s&iacute;ncrono com ass&iacute;ncrono porque pode causar um <a href="http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html">risco maior de deadlocks</a>, tratamento de erros mais complexos e bloqueio inesperado de threads de contexto;</li> 
 <li>Use o ConfigureAwait(false) para obter um desempenho melhor se o restante do c&oacute;digo n&atilde;o precisa de informa&ccedil;&otilde;es do contexto original, pois o c&oacute;digo restante continuar&aacute; na <i>threadpool</i> do contexto. Isso ajuda a evitar deadlocks nos casos em que &eacute; obrigado a misturar c&oacute;digo s&iacute;ncrono e ass&iacute;ncrono. Note que isso se aplica de <a href="http://stackoverflow.com/a/13494570/297964">maneira um pouco distinta</a> quando tratamos o c&oacute;digo no lado do servidor.</li> 
</ul>
<p><a href="https://www.simple-talk.com/author/chris-hurley/">Chris Hurley</a>, engenheiro de software da RedGate, explica <a href="https://www.simple-talk.com/dotnet/.net-framework/the-overhead-of-asyncawait-in-net-4.5/">o overhead de CPU de async-await</a> e demonstra por meio da analise da execu&ccedil;&atilde;o de um c&oacute;digo exemplo:</p>
<ul> 
 <li>A invoca&ccedil;&atilde;o de um m&eacute;todo que usa palavra chave &quot;async&quot; necessita da cria&ccedil;&atilde;o de uma m&aacute;quina de estados e a constru&ccedil;&atilde;o de uma tarefa que cont&eacute;m o trabalho que deve ser executado, dessa forma &eacute; obtido o contexto de execu&ccedil;&atilde;o e de sincroniza&ccedil;&atilde;o;</li> 
 <li>No exemplo analisado, 963 m&eacute;todos do framework foram executados para inicializar um m&eacute;todo async relativamente simples na primeira chamada;</li> 
 <li>O contexto &eacute; armazenado em cache para que as subsequentes chamadas consumam menos recursos;</li> 
 <li>Para os m&eacute;todos que podem executar assincronamente no per&iacute;odo muito curto de tempo, digamos 1 milisegundo, a ativa&ccedil;&atilde;o da chamada ass&iacute;ncrona bloqueia a thread por um per&iacute;odo maior do que o necess&aacute;rio para sua computa&ccedil;&atilde;o. No exemplo usado, precisou de mais de 45 ms antes que a thread chamada fosse desbloqueada. Mesmo quando o c&oacute;digo est&aacute; dentro de um la&ccedil;o de repeti&ccedil;&atilde;o, embora as subsequentes chamadas exigissem menos tempo de processamento, a chamada da thread realmente n&atilde;o fornece nenhuma melhoria no desempenho;</li> 
 <li>Em resumo, evite uso de async/await para m&eacute;todos muito curtos ou o uso de await em la&ccedil;os pequenos (coloque o la&ccedil;o inteiro em um m&eacute;todo ass&iacute;ncrono).</li> 
</ul>
<p>Em outra not&iacute;cia tamb&eacute;m apresentamos algumas <a href="http://www.infoq.com/news/2013/04/async-csharp-fsharp">outras pegadinhas comuns</a> que ocorrem ao utilizar o async/await.</p><br><br><br><br><br><br></body></html>