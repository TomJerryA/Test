<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Apache Crunch:MapReduceプログラミングを容易にするJavaライブラリ</h3><p><a target="_blank" href="http://www.infoq.com/articles/ApacheCrunch;jsessionid=EF479FBC92E4EB354CE159D36852D397"><em>原文(投稿日：2013/12/27)へのリンク</em></a></p><p><a target="_blank" href="http://incubator.apache.org/crunch/">Apache Crunch（インキュベーション）</a>は、Googleの<a target="_blank" href="http://dl.acm.org/citation.cfm?id=1806638">FlumeJava</a>ライブラリをベースにしたMapReduce パイプラインを作成するためのJavaライブラリである。MapReduceジョブを作成する他の高レベルなツール、例えば Apache Hive, Apache Pig, Cascadingのように、Crunchはデータの結合、アグリゲーションの実行、レコードのソートのような共通したタスクを実装するパターンのライブラリを提供する。これらの他のツールと違って、Crunchは全てのインプットデータが従わなければならない単一のデータ型を課すことはない。その代わりに、カスタマイズ可能な型システムを使って、時間列、HDF5ファイル、Apache HBaseテーブル、プロトコルバッファや<a target="_blank" href="http://avro.apache.org">Avro</a>レコードのようなシリアライズされたオブジェクトなどの複雑なデータを直接扱うことができる程、Crunchは柔軟である。</p><p>Crunchは開発者が MapReduceで考えることを止めさせようとしているわけではなく、もっと簡単に考えられるようにしているのである。そのパワー関わらず、MapReduceは多くの問題に対する間違ったレベルの抽象である。最も面白い計算は、複数の MapReduceジョブからできており、よくあるケースは、論理的に独立した操作（例えば、データフィルタリング、データ射影、データ変換）をパフォーマンスのために1つの物理的なMapReduceジョブに組み立てる必要がある。</p><p>本質的に、CrunchはMapReduce上の薄いベニアとなるように設計されている。その意図は、MapReduceのパワー（すなわち開発者のMapReduce APIへのアクセス）を損なわずに、目の前の問題を正しい抽象レベルで扱うのを容易にすることである。</p><p>Crunchは昔のCascading APIを想起されるが、それぞれのデータモデルは全く違う。1つの単純で常識的な要約は、問題をデータフローとして考える人々は Crunch と Pigを好み、SQLスタイルのジョインで考える人は Cascading と Hiveを好む。</p><h2>Crunchの概念</h2><p>Crunchの中核となる抽象層は<strong>PCollection
  <t></t></strong>で、分散した、イミュータブルなオブジェクト集合で、 PCollectionのサブインターフェースである<strong>PTable</strong>はキー－値ペアを扱う付加的なメソッドを持っている。これら2つの中核クラスは、4つのプリミティブなオペレーションをサポートする。</p><ol> 
 <li><strong>parallelDo</strong>: 既存の PCollectionにユーザー定義された関数を適用して、結果として新しいPCollectionを返す。</li> 
 <li><strong>groupByKey</strong>: キーによってPTable の要素をソートし、グループ化する（ MapReduceジョブのシャッフルフェーズに相当）</li> 
 <li><strong>combineValues</strong>: 連想演算を実行して、groupByKey操作で値を集める。</li> 
 <li><strong>union</strong>: 2つ以上のPCollectionを１つの仮想の PCollectionとして扱う</li> 
</ol><p>Crunchの高階演算（join, cogroup, set操作など）はこれらのプリミティブによって実装されている。Crunchジョブプラナーはパイプライン開発者によって定義された演算のグラフを取り込み、演算を一連の依存する MapReduceジョブ列に分解し、それからHadoopクラスタ上でそれらを実行する。Crunchはまた、ローカルデータでパイプラインをテスト、デバッグするのに使うことができる、インメモリーの実行エンジンをサポートしている。</p><p>Crunchはカスタムなデータ型を操作する、多くのユーザー定義関数によって問題を解決するように設計されている。Crunchのユーザー定義関数は軽量ながら、基礎をなすMapReduce APIへのアクセスを完全に提供しているので、アプリケーションはそれらにアクセスできる。Crunchを利用する開発者はまた、Crunchプリミティブを使って、クライアントに高度なETL、機会学習、複雑なMapReduce ジョブ列を伴う科学計算機能を提供するAPIを定義できる。</p><h2>Crunchを始めてみる</h2><p>最新バージョンのCrunchのソースかバイナリを<a target="_blank" href="http://incubator.apache.org/crunch/download.html">webサイトから</a>をダウンロードできる。あるいは、 Maven Centralに公開されている<a target="_blank" href="http://repo1.maven.org/maven2/org/apache/crunch/crunch/">dependencies</a>を使える。<br /> ソースコードにはいくつかのアプリケーションがついている。以下は、CrunchでのWordCount アプリケーションである。</p><pre>
import org.apache.crunch.DoFn;
import org.apache.crunch.Emitter;
import org.apache.crunch.PCollection;
import org.apache.crunch.PTable;
import org.apache.crunch.Pair;
import org.apache.crunch.Pipeline;
import org.apache.crunch.impl.mr.MRPipeline;
import org.apache.crunch.type.writable.Writables;

public class WordCount {
  public static void main(String[] args) throws Exception {
    // Create an object to coordinate pipeline creation and execution.
    Pipeline pipeline = new MRPipeline(WordCount.class);
    // Reference a given text file as a collection of Strings.
    PCollection
 <string></string> lines = pipeline.readTextFile(args[0]);      // Define a function that splits each line in a PCollection of Strings into a     // PCollection made up of the individual words in the file.     PCollection
 <string></string> words = lines.parallelDo(new DoFn</pre><p>この例の最後のコードブロックがCrunchのリテラルAPIのパワーを示している。Javaコード1行で、2つの依存した MapReduceジョブを設定、実行しており（１つは PCollectionの要素をカウントし、2つ目がそのカウントを使ってトップ20の要素を見つけ出している）、そして2つ目のMapReduceジョブの出力をクライアントに読み込む。この時Java IterableとしてPCollectionを実体化するCrunchの機能を使う。</p><h2>Crunchの最適化プラン</h2><p>Crunchのプティマイザーの目的は、できるだけ少ない MapReduceジョブを走らせることである。大抵の MapReduceジョブはIOに負荷がかかるので、なるべく少ない回数データに手を加えるようにしたほうが、効率的である。公平に言って、どのオプティマイザー (Hive, Pig, Cascading, Crunch)も本質的に同じように動く。しかし他のフレームワークと違って、Crunchはそのオプティマイザ プリミティブをクライアント公開しているので、再使用可能で、より高レベルなタスク操作をずっと簡単にできる。例えば、ETLパイプラインを作ったり、Random Forest Modelのアンサンブルを作成し、評価するようなタスクがある。</p><h2>結論</h2><p>Crunchは現在、Apacheでインキュベート期間であり、我々はライブラリの改善にコミュニティ (<a target="_blank" href="http://incubator.apache.org/projects/crunch.html">プロジェクト ページを参照</a>)からのコントリビューションを喜んで歓迎する。特に我々はもっと効率的な MapReduceコンパイル（コストベースの最適化を含む）、新しい MapReduceデザインパターン、 そしてもっとHCatalog, Solr, ElasticSearchのようなデータソースとターゲットをサポートするためのアイデアを求めている。またCrunchを <a target="_blank" href="http://incubator.apache.org/crunch/scrunch.html">Scala</a>や <a target="_blank" href="https://github.com/viacoban/crackle">Clojure</a>のような他のJVM言語に移植したり、同時に<a target="_blank" href="https://github.com/dlyubimov/crunchR">Rで MapReduceパイプライン</a>を作成するためにCrunchを使うツールを開発する幾つものプロジェクトがある。</p><h2>著者について</h2><p><strong><img alt="" align="left" src="/resource/articles/ApacheCrunch/ja/resources/Josh_Wills.jpg;jsessionid=EF479FBC92E4EB354CE159D36852D397" _href="img://Josh_Wills.jpg" _p="true" />Josh Wills</strong>氏は、 Data Scienceで Clouderaの Directorであり、顧客やエンジニアと協働で、広範囲の業界に渡るHadoopベースのソリューションを開発している。彼は、Duke大学から数学で学位を、Texas大学 ?Austinからオペレーションズリサーチで修士を取得している。</p><div class="clearer-space"></div></body></html>