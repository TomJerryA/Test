<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Javaガベージコレクションのエッセンス</h3><p><a target="_blank" href="http://www.infoq.com/articles/Java_Garbage_Collection_Distilled"><em>原文(投稿日：2013/06/17)へのリンク</em></a></p>
<p>Serial、Parallel、Concurrent、CMS、G1、Young Gen、New Gen、Old Gen、Perm Gen、Eden、Tenured、Survivor Space、Safepoint、そして、何百ものJVMスタートアップフラグ。Javaアプリケーションから、要求されたスループットと停止時間を実現しようとして、ガベージコレクタをチューニングしようとする時、これらをどう扱えばいいのか困りませんか? そんな時は心配しないでください。あなただけではありませんから。ガベージコレクタについて書かれたドキュメントは、航空機のマニュアルのようです。ノブとダイアルについて1つ1つ詳細に書かれていますが、飛び方のガイドはどこにもありません。この記事では、特定の仕事負荷に対してガベージコレクションのアルゴリズムを選んで、チューニングする場合のトレードオフを説明します。</p>
<p>ここでは、最も共通的に使われるOracle Hotspot JVMやOpenJDKコレクタに注目します。後半は、別の選択肢を示すために、商用のJVMについて議論します。</p>
<h2>トレードオフ</h2>
<p>賢い人たちは、「何もしなければ何も得られない」と言い続けています。何かを手に入れたときには、大抵、代わりに何かをあきらめなければなりません。ガベージコレクションに関しては、コレクタにターゲットを設定した3つの主な変数を使います。</p>
<ol> 
 <li>スループット: GCで消費する時間の比率により、アプリケーションによって実行される作業量。ターゲットスループット <strong>-XX:GCTimeRatio=99</strong> 99はデフォルトで、GC時間は1%です。</li> 
 <li>停止時間: ガベージコレクションによって発生した停止により影響を受けるイベントに対応して、システムで必要になる時間。GCの停止によるターゲット停止時間 <strong>-XX:MaxGCPauseMillis=&lt;n&gt;</strong></li> 
 <li>メモリ: 状態を格納するためにシステムが使うメモリの量。管理されているときにしばしばコピーされたり、移動されたりします。いずれかの時点でアプリケーションによって保持されるアクティブオブジェクトのセットは、ライブセットとして知られています。最大ヒープサイズ<strong>–Xmx&lt;n&gt;</strong>は、アプリケーションで利用可能なヒープサイズを設定するチューニングパラメタです。</li> 
</ol>
<p>注: 多くの場合、Hotspotはこれらのターゲットを達成できず、警告もなく静かに継続します。そのため、ターゲットからは大きく外れてしまいます。</p>
<p>停止時間は、イベント全体に配分されます。最長の停止時間を減らしたり、頻繁に起きないようにしたりするために、平均停止時間を増やすことは受け入れられるでしょう。「リアルタイム」という言葉は、最小停止時間の意味に解釈すべきではありません。むしろ、スループットに関わらず、決定的な停止時間を持つことを意味します。</p>
<div id="lowerFullwidthVCR"></div>
<p>あるアプリケーションの作業にとって、スループットは最も重要なターゲットです。1つ例を挙げると、長時間実行されるバッチ処理のジョブです。ガベージコレクションが実行されている間、バッチジョブが時々1、2秒止まっても、ジョブ全体がすぐに完了すれば問題ありません。</p>
<p>人間が直接対話するアプリケーションから金融取引システムまで、実質的な他のすべての作業では、システムが1、2秒か、数ミリ秒以上反応しない場合、大変なことになり得ます。金融取引では、しばしば一貫した停止時間と引き換えに、スループットを犠牲にするだけの価値はあります。物理的に利用可能なメモリ量によって制限されるアプリケーションを持ったり、footprintを維持しなければならなかったりすることもあります。そのような場合、停止時間とスループットの面の両方で、パフォーマンスをあきらめなければなりません。</p>
<p>以下のトレードオフは度々起こります。</p>
<ul> 
 <li>大部分は、ガベージコレクションのコストは、償却コストとして、メモリを大きくしてガベージコレクションのアルゴリズムを使えば減らせます。</li> 
 <li>ガベージコレクションの一時停止を含む、観察される最悪の停止時間は、ライブセットを含んで、ヒープサイズを小さくすることで減らせます。</li> 
 <li>一時停止が起きる頻度は、ヒープとジェネレーションサイズを管理し、アプリケーションのオブジェクトの割当レートをコントロールすることで減らせます。</li> 
 <li>長い一時停止の頻度は、時にはスループットを犠牲にして、アプリケーションで同時にGCを動かすことで減らせます。</li> 
</ul>
<h2>オブジェクトのライフタイム</h2>
<p>ガベージコレクションのアルゴリズムは、ほとんどのオブジェクトがわずかな時間存続し、相対的にほんの少しのオブジェクトが長時間存続するという予想に基づいて、最適化されています。大抵のアプリケーションでは、非常に長い時間存続するオブジェクトは、時間をかけて割り当てられたオブジェクトのほんのわずかなパーセントを構成する傾向があります。ガベージコレクションの理論では、この観察されたふるまいは、しばしば「初期死亡率」や「弱い世代仮説」として知られています。例えば、スタティックのStringが効率的に永続する一方で、ループするイテレータは、大抵、非常に短命です。</p>
<p>実験によると、ジェネレーションのガベージコレクタは、通常、非ジェネレーションコレクタよりも、10倍以上のスループットをサポートできるので、サーバJVMではほとんどどこでも使われています。オブジェクトのジェネレーションを分けることで、新しく割り当てられたオブジェクトの領域は、ライブオブジェクトがわずかになることが分かっています。そのため、この新しい領域にある数少ないライブオブジェクトを取り出し、古いオブジェクトのための別の領域にコピーするコレクタは、とても効率的です。Hotspotガベージコレクタは、生き残ったGCサイクルの数を把握するため、オブジェクトの存続時間を記録します。</p>
<p>注: アプリケーションが、かなり長い時間存続するオブジェクトを連続して生成する場合、そのアプリケーションは、大部分の時間をガベージコレクションに費やし、ホットスポットガベージコレクタのチューニングに時間がかかると予想できます。これは、GCの効率が下がったためであり、ジェネレーションの「フィルタ」があまり効率的ではないときに起こります。そのため、より長く存続するジェネレーションをより頻繁に収集することになります。Oldジェネレーションほど数は少なくならず、その結果、Oldジェネレーションの収集アルゴリズムはずっと遅くなります。通常、ジェネレーションのガベージコレクタは、2つの異なる収集サイクルで実施されます。マイナーコレクションでは存続期間の短いオブジェクトが収集され、あまり実行されないメジャーコレクションでは、古い領域が収集されます。</p>
<h2>Stop-The-Worldイベント</h2>
<p>ガベージコレクション中にアプリケーションが一時停止する原因は、stop-the-worldイベントとして知られています。ガベージコレクタがこのイベントを実行するのは、実際のエンジニアリング上の理由により、メモリを管理するために、実行中のアプリケーションを定期的に停止する必要があるためです。アルゴリズムにより、種々のコレクタは、様々な存続時間で実行される特定のポイントで、stop-the-worldが起こります。アプリケーションを完全に停止させるには、動いているスレッドをすべて停止する必要があります。ガベージコレクタは、スレッドが「Safepoint」に来たら停止するシグナルを出して、スレッドを停止させます。「Safepoint」とは、すべてのGCルートが認識されていて、すべてのヒープオブジェクトの内容が一致する、プログラム実行中のポイントです。スレッドが何をしているかによって、Safepointに到達するにはいくらか時間がかかるかもしれません。Safepointチェックは、通常、メソッドリターンやループバックのエッジで実行されますが、動的にあまりチェックしないようにするために、ある場所では最適化により取り除かれます。例えば、スレッドが大きな配列をコピーしたり、大きなオブジェクトをクローンしたり、単純に計算する有限のループを実行したりする場合、Safepointに到達する前に、何ミリセコンドもの時間がかかるでしょう。Safepointまでの時間は、低遅延アプリケーションでは、十分に考慮すべき点です。この時間は、GCの他のフラグに<br /> <strong>-XX:+PrintGCApplicationStoppedTime</strong>フラグを付けて表示できます。</p>
<p>注<strong>:</strong> 動いているスレッドが沢山あるアプリケーションでstop-the-worldイベントが起きると、Safepointから開放されたスレッドが再開する時に、システムは非常に大きなスケジューリングのプレッシャを受けます。そのため、stop-the-worldにあまり頼らないアルゴリズムが、もしかするとより効率的かもしれません。</p>
<h2>ホットスポットのヒープ組織</h2>
<p>様々なコレクタがどのように動作するのかを理解するには、Javaヒープがジェネレーションコレクタをサポートするためにどのように組織化されているかを探るのが一番良いでしょう。</p>
<p><i>Eden</i>は、ほとんどのオブジェクトが最初に割り当てられる領域です。<i>survivor</i>スペースはEdenスペースのコレクションを生き残ったオブジェクトの一時保管場所です。Survivorスペースの使用は、<i>minor</i>コレクションについて述べるときに説明しましょう。ひとまとめにして、<i>Eden</i>と<i>survivor</i>スペースは、「<i>young</i>」、または、「<i>new</i>」ジェネレーションとして知られています。</p>
<p>十分長く存続するオブジェクトは、最終的に<i>tenured</i> (終身) スペースに移動します。</p>
<p><i>perm</i> (永続) ジェネレーションは、クラスやスタティックなStringなど、実際に永続すると「分かっている」オブジェクトをランタイムに保持します。残念ながら、数多くのアプリケーションで継続してクラスローディングを共通的に利用するのは、クラスが永続する<i>perm</i>ジェネレーションの陰で動機づけられている仮定を間違ったものにします。Java 7で、intern()で返されたStringは、<i>permgen</i>から<i>tenured</i>に移動させられました。Java 8からは使われず、permジェネレーションについてこの記事ではこれ以上議論しません。他の商用コレクタのほとんどは、別々の<i>perm</i>スペースを使わず、長時間存続するすべてのオブジェクトをtenuredとして扱います。</p>
<p>注<strong>:</strong> 仮想スペースにおいて、コレクタはスループットと停止時間のターゲットに合うように、領域のサイズを調整できるようになっています。コレクタは、各コレクションフェーズの統計を保持し、ターゲットを達成できるように領域サイズを調整します。</p>
<h2>オブジェクトの割り当て</h2>
<p>競合を避けるために、各スレッドは、オブジェクトを割り当てるスレッドローカル割当バッファ (TLAB) が割り当てられます。TLABを使えば、1つのメモリリソースにおける競合を避けることで、オブジェクトの割り当てを多くのスレッドに拡大できます。TLABを使ったオブジェクトの割り当ては、ほとんどコストがかからない操作です。ほとんどのプラットフォームにおいて、おおよそ10命令でオブジェクトサイズのポインタを動かすだけです。Javaのヒープメモリ割り当ては、Cランタイムからmallocを使うよりも、コストがかかりません。</p>
<p><img alt="" src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/ja/resources/1Figure1.jpg" _href="img://1Figure1.jpg" _p="true" /></p>
<p>注<strong>:</strong> 個々のオブジェクト割り当てはコストがかかりませんが、<i>マイナー</i>コレクションが発生しなければならないレートは、オブジェクト割り当てのレートに直接比例します。</p>
<p>TLABが使い尽くされると、スレッドは単に<i>Eden</i>スペースから新しい割り当てを要求します。<i>Eden</i>がいっぱいになると、<i>マイナー</i>コレクションが始まります。</p>
<p>大きな配列のような大きなオブジェクト (-XX:PretenureSizeThreshold=n) は、<i>young</i>ジェネレーションに適合しなくなると、oldジェネレーションに割り当てなければなりません。しきい値がTLABサイズよりも低く設定されると、TLABに合うオブジェクトは<i>old</i>ジェネレーションの中には作られません。新しいG1コレクタは、大きなオブジェクトを別の方法で扱います。このことは、後ほど別のセクションで説明します。</p>
<h2>マイナーコレクション</h2>
<p><i>マイナー</i>コレクションは、Edenがいっぱいになると実行されます。<i>new</i>ジェネレーションにあるすべてのライブオブジェクトが、必要に応じて、<i>survivor</i>スペースか、<i>tenured</i>スペースにコピーされるのです。<i>tenured</i>スペースにコピーされることは、移動や終身として知られています。移動は、オブジェクトが十分に古くなったか (<strong>– XX:MaxTenuringThreshold</strong>)、<i>survivor</i>スペースがあふれた時に起こります。</p>
<p><i>ライブ</i>オブジェクトは、アプリケーションが到達できるオブジェクトです。他のオブジェクトは到達できず、<i>死んでいる</i>とみなされます。<i>マイナー</i>コレクションでは、ライブオブジェクトをコピーすることは、まずGCルートとして知られるものに従って実行され、到達できるものは何でも、繰り返し<i>survivor</i>スペースにコピーします。アプリケーションやJVM内部スタティクフィールドからの参照や、スレッドスタックフレームやアプリケーションの到達可能なオブジェクトのグラフを実際に示すポイントすべてからの参照を、GCルートは含んでいます。</p>
<p>ジェネレーションコレクションで、<i>new</i>ジェネレーションの到達可能なオブジェクトグラフのGCルートは、<i>old</i>ジェネレーションから<i>new</i>ジェネレーションへの参照も含んでいます。これらの参照は、<i>new</i>ジェネレーションのすべての到達可能なオブジェクトが<i>マイナー</i>コレクションを確実に生き残るように、処理されなければなりません。これらのジェネレーションに渡る参照は、「カードテーブル」を使って実現できます。Hotspotカードテーブルは、バイトの配列であり、各バイトは<i>old</i>ジェネレーションの512バイト領域に対応して、ジェネレーションに渡る参照が潜在的に存在することを追跡するために使われます。参照はヒープに保存されるので、「保存バリア」コードによってカードに記録し、<i>old</i>ジェネレーションから<i>new</i>ジェネレーションへの潜在的参照が、関連する512バイトヒープ領域に存在することを示します。コレクション中に、カードテーブルは、そのようなジェネレーションに渡る参照をスキャンするのに使われ、追加のGCルートを<i>new</i>ジェネレーションの中に効果的に示します。そのため、<i>マイナー</i>コレクションの重大な修正コストは、<i>old</i>ジェネレーションの大きさに直接比例します。</p>
<p>Hotspotの<i>new</i>ジェネレーションには、2つのsurvivorスペースがあり、「<i>to-space</i>」と「<i>from-space</i>」の役割を交替します。<i>マイナー</i>コレクションの初めに、「<i>to-space</i>」<i>survivor</i>スペースはいつも空で、<i>マイナー</i>コレクションのターゲットコピーエリアの役割をします。前の<i>マイナー</i>コレクションのターゲットsurvivorスペースは、「<i>from-space</i>」の一部であり、<i>Eden</i>を含みます。そこでは、コピーが必要なライブオブジェクトが見つかるかもしれません。</p>
<p><i>マイナー</i> GCコレクションのコストは、通常、<i>survivor</i>スペースと<i>tenured</i>スペースにオブジェクトをコピーするコストによって左右されます。<i>マイナー</i>コレクションで生き残れないオブジェクトは、事実上、自由に扱われます。<i>マイナー</i>コレクションの間に行われた作業は、見つかったライブオブジェクトの数にそのまま比例し、<i>new</i>ジェネレーションのサイズに比例するのではありません。<i>マイナー</i>コレクションを実行するのに使った全体の時間は、<i>Eden</i>のサイズが2倍になる度に、ほぼ二等分されます。メモリは、そのためスループットと交換されます。Edenのサイズを2倍にすることで、コレクション毎のコレクション時間を増やすことになりますが、移動されるオブジェクトの数と<i>old</i>ジェネレーションの大きさが変わらなければ、これは、比較的小さくなります。</p>
<p>注<strong>:</strong>Hotspotでは、<i>マイナー</i>コレクションはstop-the-worldイベントです。これは、ライブオブジェクトが増えてヒープが大きくなるにつれて、急激に大きな問題になります。そこで、私たちは、停止時間のターゲットを達成するために、<i>young</i>ジェネレーションのコンカレントコレクションの必要性を調べ始めています。</p>
<h2>メジャーコレクション</h2>
<p>メジャーコレクションが<i>old</i>ジェネレーションを収集すると、オブジェクトは<i>young</i>ジェネレーションから移動します。大抵のアプリケーションでは、大部分のプログラムの状態は、<i>old</i>ジェネレーションで終わります。GCアルゴリズムの最大の多様性は、<i>old</i>ジェネレーションに存在します。いっぱいになったときにスペース全体を圧縮したり、いっぱいになるのを防ぐためにアプリケーションで同時に収集したりします。</p>
<p><i>old</i>ジェネレーションのコレクタは、<i>young</i>ジェネレーションからの移動に失敗するのを避けるため、収集する必要がある時期を予想しようとします。コレクタは<i>old</i>ジェネレーションのいっぱいになる限界を追跡し、その限界を過ぎた時に、収集し始めます。この限界が移動の要件に十分合っていなければ、「FullGC」が始まります。FullGCは<i>old</i>ジェネレーションのコレクションとコンパクションに従い、<i>young</i>ジェネレーションからライブオブジェクトを移動させます。移動の失敗は、先に述べたように非常に高価な操作であり、このサイクルから移動したオブジェクトが解放されてから、FullGCイベントが発生します。</p>
<p>注<strong>:</strong> 移動の失敗を避けるために、oldジェネレーションが移動に適応できるようにする (XX:PromotedPadding=
 <n></n>) パディングを調節する必要があります。</p>
<p>注<strong>:</strong>ヒープが成長する必要がある時に、FullGCが発生します。これらのヒープをリサイズするFullGCは、<strong>–Xms</strong>と<strong>–Xmx</strong>に同じ値を設定することで避けられます。</p>
<p>FullGC以外、<i>old</i>ジェネレーションのコンパクションは、アプリケーションが経験する最も大きなstop-the-worldの停止でしょう。このコンパクションの時間は、<i>tenured</i>スペースのライブオブジェクトの数で段階的に増える傾向があります。</p>
<p><i>survivor</i>スペースのサイズと、<i>tenured</i>ジェネレーションに移動される前のオブジェクトの存続時間を増やすことで、<i>tenured</i>スペースがいっぱいになる割合を減らせます。しかし、<i>survivor</i>スペースのサイズと、移動前のマイナーコレクション (–XX:MaxTenuringThreshold) のオブジェクトの存続時間が増えることで、 <i>マイナー</i>コレクションの<i>survivor</i>スペース間におけるコピーのコストが増えるため、<i>マイナー</i>コレクションのコストと停止時間も増えるでしょう。</p>
<h2>シリアルコレクタ</h2>
<p>シリアルコレクタ (-XX:+UseSerialGC) は、最もシンプルなコレクタであり、シングルプロセッサシステムでは良い選択肢です。どのコレクタでも最も小さなfootprintしか必要としません。シリアルコレクタは、<i>マイナー</i>コレクションと<i>メジャー</i>コレクションのシングルスレッドを利用します。オブジェクトは、ポインタアルゴリズムを使ったポインタの移動により、<i>tenured</i>スペースに割り当てられます。メジャーコレクションは、<i>tenured</i>スペースがいっぱいになると始まります。</p>
<h2>パラレルコレクタ</h2>
<p>パラレルコレクタには2つの形式があります。パラレルコレクタ (-XX:+UseParallelGC) は、マルチスレッドでYoungジェネレーションの<i>マイナー</i>コレクションを実行し、シングルスレッドで<i>old</i>ジェネレーションのメジャーコレクションを実行します。Java 7u4からデフォルトになったパラレルオールドコレクタ (-XX:+UseParallelOldGC) は、<i>マイナー</i>コレクションと<i>メジャー</i>コレクションにマルチスレッドを利用します。オブジェクトは、ポインタアルゴリズムを使ったポインタの移動により<i>tenured</i>スペースに割り当てられます。メジャーコレクションは、<i>tenured</i>スペースがいっぱいになると始まります。</p>
<p>マルチプロセッサシステムにおいて、パラレルオールドコレクタはどのコレクタよりも大きなスループットを提供します。これは、コレクションが起きるまで実行アプリケーションには何も影響を与えず、最も効率的なアルゴリズムを使い、マルチスレッドのパラレルコレクションを実行します。このため、パラレルオールドコレクタはバッチアプリケーションに向いています。</p>
<p><i>old</i>ジェネレーションを収集するコストは、ヒープサイズよりも大部分は保存されるオブジェクトの数に影響されます。そのため、より多くのメモリを提供し、コレクションの停止を大きいけれども数を少なくすることで、より大きなスループットを達成してパラレルオールドコレクタの効率を向上させられます。</p>
<p><i>tenured</i>スペースへの移動は、ポインタの移動とコピー操作なので、このコレクタを使って最速のマイナーコレクションが期待できます。</p>
<p>サーバアプリケーションでは、パラレルオールドコレクタは最初の行先であるべきです。しかし、<i>メジャー</i>コレクションの停止がアプリケーションで許容できないほど長い場合、アプリケーション実行中に<i>tenured</i>オブジェクトを同時に収集するコンカレントコレクタの利用を検討する必要があります。</p>
<p>注<strong>:</strong> <i>old</i>ジェネレーションの圧縮中に、現代のハードウェア上でライブデータのGB毎に1秒から5秒の停止が予想されます。</p>
<h2>コンカレントマークスイープ (CMS) コレクタ</h2>
<p>CMS (-XX:+UseConcMarkSweepGC) コレクタは、<i>メジャー</i>コレクション中には到達できないtenuredオブジェクトを収集するOldジェネレーションで実行されます。CMSは<i>old</i>ジェネレーションで十分なフリースペースを確保するためにアプリケーションで同時に実行します。 そうすることで、<i>young</i>ジェネレーションからの移動の失敗を防いでいます。</p>
<p>移動の失敗によりFullGCが発生します。CMSは以下の複数のプロセスに従います。</p>
<ol> 
 <li>初期マーク
  <stop-the-world></stop-the-world>: GCルートを見つける</li> 
 <li>コンカレントマーク: GCルートから到達できるすべてのオブジェクトをマークする</li> 
 <li>コンカレントプレクリーン: 更新されたオブジェクトへの参照や、リマークによってコンカレントマークフェーズ中に移動したオブジェクトを確認する</li> 
 <li>リマーク &lt;stop-the-world&gt;: プレクリーンステージから更新されたオブジェクトの参照をとらえる</li> 
 <li>コンカレントスイープ: デッドオブジェクトでいっぱいになったメモリを再利用してフリーリストを更新する</li> 
 <li>コンカレントリセット: 次の実行のためにデータ構造をリセットする</li> 
</ol>
<p><i>tenured</i>オブジェクトに到達できなくなると、CMSによってスペースが再利用できるようになり、フリーリストに置かれます。移動が発生したら、移動されたオブジェクトに最適な大きさの部分をフリーリストから探さなければなりません。このため、移動のコストが上昇し、パラレルコレクタと比べて、マイナーコレクションのコストが増加します。</p>
<p>注<strong>:</strong> CMSは圧縮するコレクタではないため、時間が経つと、<i>old</i> ジェネレーションにフラグメンテーションが発生します。オブジェクトの移動は、<i>old</i>ジェネレーションの空き領域に適合せずに、失敗することがあります。失敗した場合、「promotion failed」メッセージがログに書き込まれて、ライブtenuredオブジェクトを圧縮するために、FullGCが発生します。このようなコンパクション形式のFullGCでは、パラレルオールドコレクタを使う<i>メジャー</i>コレクションよりも停止時間が長くなることが予想されます。それは、CMSがコンパクションにシングルスレッドを利用するからです。</p>
<p>CMSは大抵アプリケーションと同時に実行されるため、様々な影響があります。まず、CPU時間がコレクタによって使われ、アプリケーションの利用可能なCPUが減ります。CMSが要求する時間の長さは、<i>tenured</i>スペースへ移動するオブジェクトの数によって、段階的に長くなります。次に、コンカレントGCサイクルのいくつかのフェーズでは、GCルートをマークし、変更を確認するためにパラレルリマークを実行するSafepointへ、すべてのアプリケーションスレッドを置かなければなりません。</p>
<p>注<strong>:</strong> アプリケーションで、tenuredオブジェクトに大幅な変更がある場合、リマークフェーズは大きくなります。極端な場合、パラレルオールドコレクタのフルコンパクションよりも時間がかかります。</p>
<p>CMSは、スループットの削減やコストのかかる<i>minor</i>コレクション、より大きなfootprintを犠牲にして、FullGCの発生を抑えます。スループットの削減は、パラレルコレクタと比べて、移動の割合により10%-40%になります。CMSには、追加のデータストラクチャと「フローティングガベージ」を合わせるために、20%大きなfootprintが必要です。「フローティングガベージ」は、コンカレントマーキング中に見逃され、次のサイクルに持ち越されることもあります。</p>
<p>高い移動レートやフラグメンテーションの発生は、<i>young</i>ジェネレーションと<i>old</i>ジェネレーションのスペースを大きくすることで減らせます。</p>
<p>注<strong>:</strong> CMSでは、「コンカレントモードの失敗」が起きるかもしれません。移動を続けるために十分なレートでの収集に失敗するとログに書き込まれます。コレクションの開始が遅すぎる場合に発生しますが、これはチューニングで調節できます。しかし、コレクションレートが、移動レートやアプリケーションのオブジェクト変更レートに追いつかない場合に起きることもあります。移動レートやアプリケーションの変更レートが高すぎる場合、移動のプレッシャを減らすために、アプリケーションを変更する必要があるかもしれません。そのようなシステムにメモリを追加すると、CMSがより多くのメモリをスキャンしなければならなくなるため、状況が悪くなることがあります。</p>
<h2>ガベージファースト(G1)コレクタ</h2>
<p>G1 (-XX:+UseG1GC) は、Java 6で導入された新しいコレクタであり、今ではJava 7で正式にサポートされています。G1は、部分的にコンカレントコレクションのアルゴリズムを使い、フラグメンテーションでCMSを苦しめるFullGCイベントを最小化させるために、繰り返し発生するstop-the-worldの停止を短くして、<i>tenured</i>スペースを圧縮しようとします。G1は、ジェネレーションコレクタであり、他のコレクタとは異なる方法で、ヒープを管理します。同じ目的で連続する領域を使うのではなく、様々な目的で同一サイズの領域に分割します。</p>
<p>G1は、領域間の参照を追跡し、最も空きスペースのある領域でコレクションに集中するために、同時マーキング領域のアプローチをとります。 これらの領域は、空き領域へライブオブジェクトを退避させることで増加するstop-the-worldの停止中に収集されます。こうして、プロセスの中で圧縮しています。領域の50%よりも大きいオブジェクトは、様々な大きさの領域を持つ、非常に大きな領域に割り当てられます。非常に大きなオブジェクトの割り当てとコレクションは、G1では非常にコストがかかり、今までほとんど最適化が適用されていません。</p>
<p><img alt="" src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/ja/resources/Figure2.jpg" _href="img://Figure2.jpg" _p="true" /></p>
<p>圧縮しているコレクタは、オブジェクトを動かすのではなく、オブジェクトへの参照を更新します。オブジェクトが多くの領域から参照されている場合、これらの参照を更新することは、オブジェクトを移動するよりも、ずっと時間がかかります。領域のどのオブジェクトが「Remembered Set」を通して他の領域から参照されているかを、G1は追跡します。Remembered Setが大きくなると、G1は非常に遅くなります。1つの領域から別の領域へオブジェクトを退避する時、関連するstop-the-worldイベントの長さは、スキャンして、部分的にパッチをあてる必要のある参照を持つ領域の数に比例する傾向があります。</p>
<p>Remembered Setを維持するには、パラレルオールドやマイナーコレクションのCMSコレクタで見られるよりも待ち時間が長くなるため、<i>マイナー</i>コレクションのコストが増加します。</p>
<p>G1は、停止時間のターゲット <strong>–XX:MaxGCPauseMillis=&lt;n&gt;</strong> に対して動き、デフォルトは200msです。 ターゲットは、ベストエフォートに基づいて各サイクルで実行される作業量に影響を与えます。10ミリセコンド単位でターゲットを設定するのは大抵無駄であり、10ミリセコンド単位のターゲットを書くことは、G1の中心ではありません。</p>
<p>G1が向いているのは、コンパクションが増加し、0.5-1.0セコンドの範囲の停止にアプリケーションが耐えられなくなると、フラグメンテーションが生じがちな大きなヒープの汎用的コレクタです。G1は、拡張された<i>マイナー</i>コレクションと<i>old</i>ジェネレーションで増えていくコンパクションのために、CMSで見られる最悪な停止時間の発生を減少させます。ほとんどの停止時間は、フルヒープコンパクションよりも、領域で制限されます。</p>
<p>CMSのように、G1は移動レートに追いつけなくなって、stop-the-world FullGCに後退します。ちょうどCMSに「コンカレントモードの失敗」があるように、G1は退避失敗に陥り、「<i>to-space</i> overflow」とログに表示されます。これは、移動の失敗と同様、オブジェクトが退避できる空き領域がない場合に発生します。この失敗が発生した場合、より大きなヒープやより多くのマーキングスレッドを使用してください。しかし、割当レートを減らすには、アプリケーションの変更が必要になる場合もあります。</p>
<p>G1の難しい問題は、人気のあるオブジェクトや領域を扱うことです。他の領域からそれほど参照されないライブオブジェクトが領域にある場合、増加するstop-the-worldのコンパクションはうまく機能します。オブジェクトや領域の人気がある場合、Remembered Setは大きくなり、G1はこれらのオブジェクトを収集するのを避けようとします。結局、選択肢はなく、ヒープが圧縮されるにつれて、非常に頻繁に中程度の停止が発生します。</p>
<h2>もう1つのコンカレントコレクタ</h2>
<p>CMSとG1は、大抵コンカレントコレクタと呼ばれます。実行される作業をすべて見れば、<i>young</i>ジェネレーション、移動、そして、<i>old</i>ジェネレーションの大部分の作業でさえ、まったく同時には行われていません。 CMSは、大抵、<i>old</i>ジェネレーションでは同時に実行されます。G1は、stop-the-worldで増加していくコレクタです。CMSとG1は、定期的に発生する大きなstop-the-worldイベントがあり、最悪のシナリオでは、金融取引や反応型ユーザインタフェースのような、厳密な低遅延アプリケーションには適合しない場合があります。</p>
<p>代替するコレクタとして、Oracle JRockit Real TimeやIBM Websphere Real Time、Azul Zingなどを利用できます。JRockitやWebsphereコレクタは、CMSやG1よりも、大抵の場合、停止時間に関して有利ですが、しばしばスループットの制限が見られ、大きなstop-the-worldイベントが発生します。Zingは、Javaコレクタであり、全てのジェネレーションのスループットレートを高く保ちながら、コレクションとコンパクションが本当に同時に実行できます。Zingは、数ミリセコンドのstop-the-worldイベントが発生しますが、ライブセットのサイズとは関係なく、コレクションサイクルのフェーズが変わることが原因です。</p>
<p>JRockit RTにより、ヒープサイズを含んだ高い割り当てレートが、数10ミリセコンドという典型的な停止時間で達成できますが、時には、フルコンパクションの停止になってしまうこともあります。Websphere RTは、強制的な割り当てレートとライブセットのサイズにより、1桁のミリセコンドという停止時間を達成できます。Zingは、<i>マイナー</i>コレクションの間を含むすべての停止を同時に実行することで、高い割り当てレートで数ミリセコンドの停止を実現しています。Zingは、ヒープサイズに関わらず、同様のふるまいを維持できます。そのため、ユーザは、停止時間が増えることを心配せずに、アプリケーションのスループットやオブジェクトモデルの状態の必要性に合わせて、必要であれば大きなヒープサイズを適用できます。</p>
<p>停止時間をターゲットにするすべてのコンカレントコレクタでは、ある程度のスループットをあきらめなければならず、footprintが増えることになります。コンカレントコレクタの効率により、あきらめるスループットは少しかもしれませんが、常に大きなfootprintが追加されます。もし、ほんのわずかなstop-the-worldイベントがあるだけで本当に同時に実行されるのであれば、同時操作を可能にして、スループットを維持するために、より多くのCPUコアが必要です。</p>
<p>注: すべてのコンカレントコレクタは、大きなスペースが割り当てられている時に、より効率的に機能する傾向があります。最初の経験則から、効率的な操作のためには、少なくともライブセットのサイズの2倍から3倍のヒープを確保すべきです。しかし、コンカレント操作を維持するためのスペースの要求は、アプリケーションスループットと、関連する割り当てレートや移動レートにより増えていきます。そのため、スループットの高いアプリケーションには、ライブセットの割合に対して、大きなヒープサイズが保証になります。今日のシステムのfootprintに非常に大きなメモリスペースを割り当てることが、サーバサイドで問題になることはめったにありません。</p>
<h2>ガベージコレクションのモニタリングとチューニング</h2>
<p>アプリケーションとガベージコレクタの動きを理解するには、少なくとも以下の設定でJVMを起動します。</p>
<pre>
-verbose:gc<br />-Xloggc:
 <filename></filename><br />-XX:+PrintGCDetails<br />-XX:+PrintGCDateStamps<br />-XX:+PrintTenuringDistribution<br />-XX:+PrintGCApplicationConcurrentTime <br />-XX:+PrintGCApplicationStoppedTime</pre>
<p>それから、分析のために<a href="https://github.com/chewiebug/GCViewer">Chewiebug</a>のようなツールでログを読み込みます。</p>
<p>GCが動的に動く様子を見るには、JVisualVMを起動し、Visual GCプラグインをインストールします。そうすれば、以下のようにアプリケーションで動いているGCを見られます。</p>
<p><img alt="" src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/ja/resources/Figure3.jpg" _href="img://Figure3.jpg" _p="true" /></p>
<p>アプリケーションのGCの必要性を理解するには、繰り返し実行できる典型的なロードテストが必要です。各コレクタがどのように動くかを理解し始めたら、ターゲットとするスループットと停止時間に到達するまで、実験として、様々な設定でロードテストを走らせます。この時に重要なのは、エンドユーザの視点で停止時間を測ることです。そうするために、ヒストグラムの各テスト要求の応答時間を把握すると良いでしょう。詳細は、<a href="https://github.com/giltene/HdrHistogram">こちら</a>で読むことができます。停止時間が許容範囲を超えている場合は、GCが原因かどうか見極めるためにGCのログと対応させてみましょう。別の原因で停止時間が増加している可能性もあります。もう1つの役に立つツールは、<a href="http://www.jhiccup.com/">jHiccup</a>であり、JVM内やシステム全体の停止を追跡するのに利用できます。</p>
<p>停止時間の増加の原因がGCにある場合は、停止時間のターゲットに合うかどうかみるために、CMSか、G1をチューニングします。高い割り当てレートや移動レートが、非常に低い遅延要求と組み合わされているためにチューニングできない時があるかもしれません。GCのチューニングには、しばしばオブジェクトの割り当てレートやオブジェクトライフタイムを減らすためにアプリケーションの修正が必要になり、高いスキルが必要とされることがあります。この場合には、GCのチューニングやアプリケーションの修正に時間と費用をかけるか、JRockit Real TimeやAzul Zingなどの商用の同時に圧縮するJVMの1つを購入するかのトレードオフになるでしょう。</p>
<h2>著者について</h2>
<p><strong><img alt="" align="left" src="http://www.infoq.com/resource/articles/Java_Garbage_Collection_Distilled/ja/resources/MARTIN20THOMPSON20-1.jpg" _href="img://MARTIN20THOMPSON20-1.jpg" _p="true" />Martin Thompson</strong>氏は、ハイパフォーマンスと低遅延の専門家であり、大規模トランザクションとビックデータシステムに20年以上取り組んできた経験を持っています。Martin氏は、上質でハイパフォーマンスなソリューションを提供するために、基礎としてハードウェアの理解をソフトウェア製作に適用するようなMechanical Sympathy (機械的共感) を信じています。Disruptorフレームワークは、Mechanical Sympathyが作り出した1つの例にすぎません。 Martin氏は、LMAXの共同創立者でCTOです。ブログは<a href="http://mechanical-sympathy.blogspot.com">こちら</a>で、パフォーマンスやコンカレンシやシステムをより良くするためのコードハッキングのトレーニングコースを見つけられます。</p><br><br><br><br><br><br></body></html>