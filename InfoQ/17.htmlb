<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>浅谈Java 8的函数式编程</h3><p>关于“Java 8为Java带来了函数式编程”已经有了很多讨论，但这句话的真正意义是什么？</p>
<p>本文将讨论函数式，它对一种语言或编程方式意味着什么。在回答“Java 8的函数式编程怎么样”之前，我们先看看Java的演变，特别是它的类型系统，我们将看到Java 8的新特性，特别是Lambda表达式如何改变Java的风景，并提供函数式编程风格的主要优势。</p>
<h2>函数式编程语言是什么？</h2>
<p>函数式编程语言的核心是它以处理数据的方式处理代码。这意味着函数应该是第一等级（First-class）的值，并且能够被赋值给变量，传递给函数等等。</p>
<p>事实上，很多函数式语言比这走得更远，将计算和算法看得比它们操作的数据更重要。其中有些语言想分离程序状态和函数（以一种看起来有点对立的方式，使用面向对象的语言，这通常会将它们联系得更紧密）。</p>
<p>Clojure编程语言就是一个这样的例子，尽管它运行于基于类的Java虚拟机，Clojure的本质是函数式语言，并且在高级语言源程序中不直接公布类和对象（尽管提供了与Java良好的互操作性）。</p>
<p>下面显示的是一个Clojure函数，用于处理日志，是一等公民（First-class citizen），并且不需要绑定一个类而存在。</p>
<div id="lowerFullwidthVCR"></div>
<pre>
(defn build-map-http-entries [log-file]
 (group-by :uri (scan-log-for-http-entries log-file)))
</pre>
<p>当写在函数中的程序，对给定的输入（不论程序中的其它状态如何）总是返回相同的输出，并且不会产生其它影响，或者改变任何程序状态，这时候函数式编程是最有用的。它们的行为与数学函数相同，有时候把遵循这个标准的函数称为“纯”函数。</p>
<p>纯函数的巨大好处是它们更容易推论，因为它们的操作不依赖于外部状态。函数能够很容易地结合在一起，这在开发者工作流风格中很常见，例如Lisp方言和其它具有强函数传统的语言中很普遍的<a href="https://www.google.com/search?q=define:repl">REPL</a>(Read, Execute, Print, Loop)风格。</p>
<h2>非函数式编程语言中的函数式编程</h2>
<p>一种语言是不是函数式并不是非此即彼的状态，实际上，语言存在于图谱上。在最末端，基本上是强制函数式编程，通常禁止可变的数据结构。Clojure就是一种不接受可变数据的语言。</p>
<p>不过，也有一些其它语言，通常以函数方式编程，但语言并不强制这一点。Scala就是一个例子，它混和了面向对象和函数式语言。允许函数作为值，例如：</p>
<pre>
val sqFn = (x: Int) =&gt; x * x
</pre>
<p>同时保留与Java非常接近的类和对象语法。</p>
<p>另一个极端，当然，使用完全非函数式语言进行函数式编程是可能的，例如C语言，只要维持好合适的程序员准则和惯例。</p>
<p>考虑到这一点，函数式编程应该被看作是有两个因素的函数，其中一个与编程语言相关，另一个是用该语言编写的程序：</p>
<p>1）底层编程语言在多大程度上支持，或者强制函数式编程？</p>
<p>2）这个特定的程序如何使用语言提供的函数式特性？它是否避免了非函数式特性，例如可变状态？</p>
<h2>Java的一些历史</h2>
<p>Java是一种固执己见的语言，它具有很好的可读性，初级程序员很容易上手，具有长期稳定性和可支持性。但这些设计决定也付出了一定的代价：冗长的代码，类型系统与其它语言相比显得缺乏弹性。</p>
<p>然而，Java的类型系统已经在演化，虽然在语言的历史当中相对比较慢。我们来看看这些年来它的一些形式。</p>
<h2>Java最初的类型系统</h2>
<p>Java最初的类型系统至今已经超过15年了。它简单而清晰，类型包括引用类型和基本类型。类、接口或者数组属于引用类型。</p>
<ul> 
 <li>类是Java平台的核心，类是Java平台将会加载、或链接的功能的基本单位，所有要执行的代码都必须驻留于一个类中。</li> 
 <li>接口不能直接实例化，而是要通过一个实现了接口API的类。</li> 
 <li>数组可以包含基本类型、类的实例或者其它数组。</li> 
 <li>基本类型全部由平台定义，程序员不能定义新的基本类型。</li> 
</ul>
<p>从最早开始，Java的类型系统一直坚持很重要的一点，每一种类型都必须有一个可以被引用的名字。这被称为“标明类型（Nominative typing）”，Java是一种强标明类型语言。</p>
<p>即使是所谓的“匿名内部类”也仍然有类型，程序员必须能引用它们，才能实现那些接口类型：</p>
<pre>
Runnable r = new Runnable() { public void run() { System.out.println(&quot;Hello World!&quot;); } };
</pre>
<p>换种说法，Java中的每个值要么是基本类型，要么是某个类的实例。</p>
<h2>命名类型（Named Type）的其它选择</h2>
<p>其它语言没有这么迷恋命名类型。例如，Java没有这样的Scala概念，一个实现（特定签名的）特定方法的类型。在Scala中，可以这样写：</p>
<pre>
x : {def bar : String}
</pre>
<p>记住，Scala在右侧标示变量类型（冒号后面），所以这读起来像是“x是一种类型，它有一个方法bar返回String”。我们能用它来定义类似这样的Scala方法：</p>
<pre>
def showRefine(x : {def bar : String}) = { print(x.bar) }
</pre>
<p>然后，如果我们定义一个合适的Scala对象：</p>
<pre>
object barBell { def bar = &quot;Bell&quot; }
</pre>
<p>然后调用showRefine(barBell)，这就是我们期待的事：</p>
<pre>
showRefine(barBell) Bell
</pre>
<p>这是一个精化类型（Refinement typing）的例子。从动态语言转过来的程序员可能熟悉“鸭子类型（Duck typing）”。结构精化类型（Structural refinement typing）是类似的，除了鸭子类型（如果它走起来像鸭子，叫起来像鸭子，就可以把它当作鸭子）是运行时类型，而这些结构精化类型作用于编译时。</p>
<p>在完全支持结构精化类型的语言中，这些精化类型可以用在程序员可能期望的任何地方，例如方法参数的类型。而Java，相反地，不支持这样的类型（除了几个稍微怪异的边缘例子）。</p>
<h2>Java 5类型系统</h2>
<p>Java 5的发布为类型系统带来了三个主要新特性，枚举、注解和泛型。</p>
<ul> 
 <li>枚举类型（Enum）在某些方面与类相似，但是它的属性只能是指定数量的实例，每个实例都不同并且在类描述中指定。主要用于“类型安全的常量”，而不是当时普遍使用的小整数常量，枚举构造同时还允许附加的模式，有时候这非常有用。</li> 
 <li>注解（Annotation）与接口相关，声明注解的关键字是@interface，以@开始表示这是个注解类型。正如名字所建议的，它们用于给Java代码元素做注释，提供附加信息，但不影响其行为。此前，Java曾使用“标记接口（Marker interface）”来提供这种元数据的有限形式，但注解被认为更有灵活性。</li> 
 <li>Java泛型提供了参数化类型，其想法是一种类型能扮演其它类型对象的“容器”，无需关心被包含类型的具体细节。装配到容器中的类型通常称为类型参数。</li> 
</ul>
<p>Java 5引入的特性中，枚举和注解为引用类型提供了新的形式，这需要编译器特殊处理，并且有效地从现有类型层级结构分离。</p>
<p>泛型为Java的类型系统增加了显著额外的复杂性，不仅仅因为它们是纯粹的编译时特性，还要求Java开发人员应注意，编译时和运行时的类型系统彼此略有不同。</p>
<p>尽管有这些变化，Java仍然保持标明类型。类型名称现在包括List（读作：“List-of-String”）和Map, CachedObject&gt;（“Map-of-Class-of-Unknown-Type-to-CachedObject”），但这些仍然是命名的类型，并且每个非基本类型的值仍是某个类的实例。</p>
<h2>Java 6和7引入的特性</h2>
<p>Java 6基本上是一个性能优化和类库增强的版本。类型系统的唯一变化是扩大注解角色，发布可插拔注解处理功能。这对大多数开发者没有任何影响，Java 6中也没有真正提供可插拔类型系统。</p>
<p>Java 7的类型系统没有重大改变。仅有的一些新特性，看起来都很相似：</p>
<ul> 
 <li>javac编译器中类型推断的小改进。</li> 
 <li>签名多态性分派（Signature polymorphic dispatch），用于方法句柄（Method handle）的实现细节，而这在Java 8中又反过来用于实现Lambda表达式。</li> 
 <li>Multi-catch提供了一些“代数数据类型”的小跟踪信息，但这些完全是javac内部的，对最终用户程序员没有任何影响。</li> 
</ul>
<h2>Java 8的类型系统</h2>
<p>纵观其历史，Java基本上已经由其类型系统所定义。它是语言的核心，并且严格遵守着标明类型。从实际情况来看，Java类型系统在Java 5和7之间没有太大变化。</p>
<p>乍一看，我们可能期望Java 8改变这种状况。毕竟，一个简单的Lambda表达式似乎让我们移除了标明类型：</p>
<pre>
() -&gt; { System.out.println(&quot;Hello World!&quot;); }
</pre>
<p>这是个没有名字、没有参数的方法，返回void。它仍然是完全静态类型的，但现在是匿名的。</p>
<p>我们逃脱了名词的王国？这真的是Java的一种新的类型形式？</p>
<p>也许不幸的是，答案是否定的。JVM上运行的Java和其它语言，非常严格地限制在类的概念中。类加载是Java平台的安全和验证模式的中心。简单地说，不通过类来表示一种类型，这是非常非常难的。</p>
<p>Java 8没有创建新的类型，而是通过编译器将Lambda表达式自动转换成一个类的实例。这个类由类型推断来决定。例如：</p>
<pre>
Runnable r = () -&gt; { System.out.println(&quot;Hello World!&quot;); };
</pre>
<p>右侧的Lambda表达式是个有效的Java 8的值，但其类型是根据左侧值推断的，因此它实际上是Runnable类型的值。需要注意的是，如果没有正确地使用Lambda表达式，可能会导致编译器错误。即使是引入了Lambda，Java也没有改变这一点，仍然遵守着标明类型。</p>
<h2>Java 8的函数式编程怎么样？</h2>
<p>最后，让我们回到本文开头提出的问题，“Java 8的函数式编程怎么样？”</p>
<p>Java 8之前，如果开发者想以函数式风格编程，他或她只能使用嵌套类型（通常是匿名内部类）作为函数代码的替代。默认的Collection类库不会为这些代码提供任何方便，可变性的魔咒也始终存在。</p>
<p>Java 8的Lambda表达式没有神奇地转变成函数式语言。相反，它的作用仍是创建强制的强命名类型语言，但有更好的语法支持Lambda表达式函数文本。与此同时，Collection类库也得到了增强，允许Java开发人员开始采用简单的函数式风格（例如filter和map）简化笨重的代码。</p>
<p>Java 8需要引入一些新的类型来表示函数管道的基本构造块，如java.util.function中的Predicate、Function和Consumer接口。这些新增的功能使Java 8能够“稍微函数式编程”，但Java需要用类型来表示它们（并且它们位于工具类包，而不是语言核心），这说明标明类型仍然束缚着Java语言，它离纯粹的Lisp方言或者其它函数式语言是多么的遥远。</p>
<p>除了以上这些，这个函数式语言能量的小集合很可能是所有大多数开发者日常开发所真正需要的。对于高级用户，还有（JVM或其它平台）其它语言，并且毫无疑问，将继续蓬勃发展。</p>
<h2>关于作者</h2>
<p><img style="float: left; margin-right: 10px" src="http://infoqstatic.com/resource/articles/How-Functional-is-Java-8/zh/resources/0519002.jpg" alt="" _href="img://null" _p="true" /><strong>Ben Evans</strong>是jClarity公司的CEO，这是一家Java/JVM性能分析的初创公司。工作之余他是伦敦Java社区领导之一，同时是JCP执行委员会成员。他之前的项目包括Google IPO性能测试、金融交易系统，为90年代的一些大电影等等编写获奖网站。</p>
<div style="clear: both"></div>
<p><strong>原文链接：</strong><a href="http://www.infoq.com/articles/How-Functional-is-Java-8">How Functional is Java 8?</a></p><br><br><br><br><br><br></body></html>