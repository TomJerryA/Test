<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>何时在WPF中使用Async及Reactive Extensions</h3><p>Ian Griffiths发布了包含六部分的一系列文章，讨论了何时应该、及何时不应在WPF中使用.NET 4.5中的async特性。这个系列始于一篇名为“<a href="http://www.interact-sw.co.uk/iangblog/2013/02/14/wpf-async-too-fast">Too Much, Too Fast with WPF and Async</a>”的贴子。</p> 
<p>有了async这件神器，似乎有人就想在应用程序中到处使用，并时时刻刻调用它。不幸的是，如果每个batch的大小（即async调用之间的时间差）小于创建Task对象及对应的上下文切换的消耗，这种情况下async就不那么好用了。</p> 
<p>Ian写道，大的batch可以减少任务完成的总体时间，但又可能影响到UI的响应。</p> 
<blockquote> 
 <p>虽然这远远快于8.5秒的情况，但我们也作出了牺牲：那个总体速度较慢的例子反而为UI更快地提供了有用的信息。实际上，用户可能会更倾向于较慢的那个版本，因为有用的信息能够立即出现，你可能不会感觉到装载整个列表的速度慢了三倍——将整个列表拖动到底部的时间说不定都远远长于8.5秒了。按照这个重要的指标来看，单纯地使用异步方法是更好的选择：它为用户更快地提供了有用的信息。</p> 
</blockquote> 
<p>Ian Griffiths也谈到了使用<a href="http://www.interact-sw.co.uk/iangblog/2013/02/19/wpf-threads-too-fast">线程池与WPF 4.5中的集合同步（Collection Synchronization）新特性</a>。如果你要使用ConfigureAwait(false)方法来避免强制在UI线程上进行处理，这项技巧也是必不可少的。</p> 
<blockquote> 
 <p>调用ConfigureAwait表示我们并不关心方法在哪个线程上继续执行。要点在于，某个不能立即完成的读操作最终会完成，而方法的余下部分会在一个线程池的线程上延迟执行。这意味着使用await不会再导致WPF的调度占用。但当然，它也意味着列表的全部更新都会发生在一个工作线程上，因此我们需要使用同样的小花招以避免产生问题：要么等到方法完成后再绑定数据并显示列表，要么就必须处理跨线程的变更通知。</p> 
</blockquote> 
<p>Ian所演示的另一个技巧是<a href="http://www.interact-sw.co.uk/iangblog/2013/02/20/wpf-rx-threads-chunking">使用Reactive Extensions分块处理数据</a>。它使用了Buffer函数将batch大小限制为100ms，或是将总数限制为5000个（取决于先达到哪个数值），然后通过ObserveOnDispatcher函数将其封装回送至UI线程。这种模式比起其它技巧显得冗余，但它“几乎能够立即开始显示[…]数据，并在2.3秒内完成加载并显示所有数据”，这比原来的同步实现还是有所改进。</p> 
<p><b>查看英文原文</b>：<a href="http://www.infoq.com/news/2013/03/WPF-Async;jsessionid=EB7EE5163F32481A859C96A349B68AA5">When to Use WPF with Async and Reactive Extensions</a></p> 
<hr /> 
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action;jsessionid=EB7EE5163F32481A859C96A349B68AA5?authorName=杨赛">杨赛</a>对本文的审校。</p> 
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p> 
<p id="lastElm"></p><br><br><br><br><br><br></body></html>