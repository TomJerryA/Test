<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Go Fourth and Grow</h3><p>Yesterday marked the <a href="http://blog.golang.org/4years">fourth anniversary</a> of the open-source project. (Go1 was released in March 2012; the fourth anniversary is calculated from the <a href="http://golang.org/doc/faq#What_is_the_status_of_the_project">initial project creation</a>). Go was created by Robert Griesemer, Rob Pike and Ken Thompson at Google, joined by Ian Taylor and Russ Cox before it went open-source. From <a href="http://golang.org/doc/faq#creating_a_new_language">the FAQ</a>:</p>
<blockquote>
 <p> Go was born out of frustration with existing languages and environments for systems programming. Programming had become too difficult and the choice of languages was partly to blame. One had to choose either efficient compilation, efficient execution, or ease of programming; all three were not available in the same mainstream language. Programmers who could were choosing ease over safety and efficiency by moving to dynamically typed languages such as Python and JavaScript rather than C++ or, to a lesser extent, Java. </p>
 <p> Go is an attempt to combine the ease of programming of an interpreted, dynamically typed language with the efficiency and safety of a statically typed, compiled language. It also aims to be modern, with support for networked and multicore computing. Finally, it is intended to be fast: it should take at most a few seconds to build a large executable on a single computer. To meet these goals required addressing a number of linguistic issues: an expressive but lightweight type system; concurrency and garbage collection; rigid dependency specification; and so on. These cannot be addressed well by libraries or tools; a new language was called for. </p>
</blockquote>
<p>Go's most recent release was 1.1, released in May 2013. Go 1.2 is expected to launch later this month, and a <a href="http://golang.org/doc/go1compat">compatibility document</a> sets forward the compatibility of future programs with Go 1, suggesting a forward-looking approach to compatibility, something which other compiled languages lack. </p>
<p>Since its initial release, a number of companies have started using Go, including <a href="http://docker.io/">Docker</a>, a tool for packaging applications in lightweight containers; <a href="http://packer.io/">Packer</a>, a tool for automating the creation of machine images; <a href="http://bitly.github.io/nsq/">Bitly's NSQ</a>, which provides a distributed messaging platform; <a href="https://juju.ubuntu.com/">Canonical's JuJu</a>, which provides an infrastructure automation system, and <a href="http://golang.org/wiki/Projects">many others</a>. Even the Free Software Foundation are talking about <a href="http://gcc.gnu.org/ml/gcc/2013-11/msg00153.html">replacing Java with Go</a> as a default language. The Docker team have <a href="http://www.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go">given a presentation</a> on why they chose to use Go.</p>
<p>The main benefit for devops people is that Go programs are always statically linked into a single executable which can be deployed onto the target platform. As a result, the system does not need to have any additional binaries pre-installed or has any concern with running different versions side-by-side without conflict. This compares favourably to packaging systems like Linux and Java which have their libraries spread out over multiple locations and require either a specific setup in place or a resolver to build a path ahead of time. (The downside is that common libraries are repeated in the static binaries of all programs, but disk space is cheap. Memory pressure on servers, which would otherwise be able to load a single image of the library is perhaps a more realistic concern for systems with many processes running, but the devops tools tend to not run for any length of time.)</p>
<p>The main benefit for high availability and multi threaded programs is the use of Go's <a href="http://golang.org/doc/faq#goroutines">goroutines</a>, which permit multiple threads of execution to serve incoming requests in a way similar to Erlang or Occam. All three are based on Hoare's <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a> or CSP. Instead of having to deal with memory and threading access, CSPs each have an incoming queue of messages/tasks, and can in turn send those messages/tasks to other CSPs. There are blocking and asynchronous operations and each (blocking) CSP can have a return value typically sent as a return message to the originating CSP.</p>
<p>Cloud Foundry has <a href="http://blog.cloudfoundry.com/2013/11/09/announcing-cloud-foundry-cf-v6/">recently moved from Ruby to Go</a> as its command line tool, to avoid any particular pre-requisites to use the command. In fact, it is now a lightweight tool for communicating with back-end services, and instead of the client performing complex validation routines it now communicates with a back-end service to do the heavy lifting. This means the tool now no longer needs to be updated as frequently, and is smaller as well.</p>
<p>With <a href="http://golang.org/doc/go1.2">Go 1.2</a> expected in the upcoming weeks, there is one change to the language in that three-index slices are now possible. Where before a <code>a[1:10]</code> expression would slice out the elements from the array a from 1 to 10, now <code>a[1:2:10]</code> will slice out every other value. A minor clarification on where <code>nil</code> is used will cause a panic if dereferenced. Other changes are listed in the <a href="http://golang.org/doc/go1.2">release notes</a>.</p>
<p>Go's critics point out that the language uses an older return-code style of programming instead of the more widely adopted <a href="http://golang.org/doc/faq#exceptions">exception based ones</a>, and that unlike Erlang (which as a functional language has no mutable state), goroutines can pass maps around which are unsynchronized by default and can therefore <a href="http://golang.org/doc/faq#atomic_maps">lead to memory corruption</a>. What is clear is that Go applies well to particular niche use-cases, and whatever its comparisons to languages like Java and Erlang, Go can be seen as a lightweight and perhaps safer alternative to raw C.</p><br><br><br><br><br><br></body></html>