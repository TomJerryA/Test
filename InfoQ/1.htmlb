<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>使用Spring Boot构建RESTful Web服务以访问存储于Aerospike集群中的数据</h3><p>Spring Boot是对Spring快速入门的强大工具。Spring Boot能够帮助你很容易地构建基于Spring的应用。<br /> <br /> Aerospike是分布式和可复制的内存数据库，不管使用DRAM还是原生的flash/SSD，Aerospike都进行了优化。<br /> <br /> Aerospike具有高可靠性并且遵循ACID。开发人员能够在不停止数据库服务的情况下，很快地将数据库集群从两个节点扩展到二十个节点。</p>
<h2>你所要构建的是什么</h2>
<p>本文将会引领你使用Spring Boot创建一个简单的RESTful Web服务。<br /> <br /> 要构建的服务接受一个<a href="http://localhost:8080/as/test/flights/getAll/1234">HTTP GET</a>请求。它的响应是如下的JSON：</p>
<pre>
{&quot;expiration&quot;:121023390,&quot;bins&quot;:{&quot;DISTANCE&quot;:2446,&quot;DEST_CITY_NAME&quot;:&quot;New 
York&quot;,&quot;DEST&quot;:&quot;JFK&quot;,&quot;YEAR&quot;:2012,&quot;ORI_AIRPORT_ID&quot;:&quot;14679&quot;,&quot;DEP_TIME&quot;:
&quot;802&quot;,&quot;DAY_OF_MONTH&quot;:12,&quot;DEST_STATE_ABR&quot;:&quot;NY&quot;,&quot;ORIGIN&quot;:&quot;SAN&quot;,&quot;FL_NUM&quot;
:160,&quot;CARRIER&quot;:&quot;AA&quot;,&quot;ORI_STATE_ABR&quot;:&quot;CA&quot;,&quot;FL_DATE&quot;:&quot;2012/01/12&quot;,
&quot;AIR_TIME&quot;:291,&quot;ORI_CITY_NAME&quot;:&quot;San Diego&quot;,&quot;ELAPSED_TIME&quot;:321,
&quot;ARR_TIME&quot;:&quot;1623&quot;,&quot;AIRLINE_ID&quot;:19805},&quot;generation&quot;:1}</pre>
<p>这里所使用的数据是商业上的飞行航班详情（包含在样例代码中，这是一个名为flights_from.csv的数据文件，它包含了大约一百万条航班信息）。</p>
<p>在产品化（或其他）环境中，还会有很多内置的特性添加到应用中以管理服务。这个功能来源于Spring，参见Spring指导：<a href="http://spring.io/guides/gs/rest-service">Building a RESTful web service</a>。</p>
<h2>你所需要的是什么</h2>
<ul> 
 <li>喜欢的文本编辑器或IDE</li> 
 <li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK 7</a>或更高版本</li> 
 <li><a href="http://maven.apache.org/download.cgi">Maven 3.0+</a></li> 
 <li><a href="http://www.aerospike.com/aerospike-3-client-sdk/">Aerospike Java SDK 3.0+</a></li> 
</ul>
<h2>搭建工程</h2>
<p>在构建应用的时候，你可以使用任何喜欢的构建系统，不过在这里提供了<a href="https://maven.apache.org/">Maven</a>的代码。如果你不熟悉Maven的话，请参考Spring指导：<a href="http://spring.io/guides/gs/maven">Building Java Projects with Maven</a>。</p>
<p>你还需要构建并安装Aerospike的Java客户端到本地Maven仓库之中。下载源码发布版本，将其进行进行unzip/untar并运行如下的Maven命令：</p>
<div id="lowerFullwidthVCR"></div>
<ul> 
 <li>mvn install:install-file -Dfile=client/depends/gnu-crypto.jar -DgroupId=org.gnu -DartifactId=gnu-crypto -Dversion=2.0.1 -Dpackaging=jar</li> 
 <li>mvn clean</li> 
 <li>mvn package</li> 
</ul>
<h3>创建目录结构</h3>
<p>在你选择的工程之中，创建如下所示的子目录结构：</p>
<p>-&gt;src<br /> -&gt;main<br /> -&gt;java<br /> -&gt;com<br /> -&gt;aerospike<br /> -&gt;client<br /> -&gt;rest</p>
<h3>创建Maven的pom文件</h3>
<p>在工程的根目录下创建一个maven的pom.xml，其代码如下：</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.aerospike&lt;/groupId&gt;
      &lt;artifactId&gt;aerospike-restful-example&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;0.5.0.M4&lt;/version&gt;
    &lt;/parent&gt;
      &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
            &lt;!-- Aerospike client. --&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;com.aerospike&lt;/groupId&gt;
              &lt;artifactId&gt;aerospike-client&lt;/artifactId&gt;
              &lt;version&gt;3.0.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Apache command line parser. --&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;commons-cli&lt;/groupId&gt;
              &lt;artifactId&gt;commons-cli&lt;/artifactId&gt;
              &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;properties&gt;
      &lt;start-class&gt;com.aerospike.client.rest.AerospikeRESTfulService
&lt;/start-class&gt;
  &lt;/properties&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt; 
              &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 
              &lt;version&gt;2.3.2&lt;/version&gt; 
          &lt;/plugin&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
              &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;repositories&gt;
      &lt;repository&gt;
          &lt;id&gt;spring-snapshots&lt;/id&gt;
          &lt;name&gt;Spring Snapshots&lt;/name&gt;
          &lt;url&gt;http://repo.spring.io/libs-snapshot&lt;/url&gt;
          &lt;snapshots&gt;
              &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
      &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;pluginRepositories&gt; 
      &lt;pluginRepository&gt;
          &lt;id&gt;spring-snapshots&lt;/id&gt;
          &lt;name&gt;Spring Snapshots&lt;/name&gt;
          &lt;url&gt;http://repo.spring.io/libs-snapshot&lt;/url&gt;
          &lt;snapshots&gt;
              &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
       &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

&lt;/project&gt;</pre>
<p>乍看上去有些恐怖，但实际上并非如此。</p>
<h3>创建一个JSON转换类</h3>
<p>Aerospike API会返回一个Record对象，它会包含记录的generation、expiry以及bin值。但是你想让这些值以JSON格式返回。要达到这一点，最简单的方式就是使用一个转换类（translator class）。</p>
<p>所创建的转换类代码如下所示。这是一个工具类，能够将Aerospike Record转换为JSONObject。</p>
<pre><font color="#408080">src/main/java/com/aerospike/client/rest/JSONRecord.java</font>
package com.aerospike.client.rest;
import java.util.Map;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import com.aerospike.client.Record;
/**
* JSONRecord is used to convert an Aerospike Record
* returned from the cluster to JSON format
*
*/
@SuppressWarnings(&quot;serial&quot;)
public class JSONRecord extends JSONObject {
      @SuppressWarnings(&quot;unchecked&quot;)
      public JSONRecord(Record record){
            put(&quot;generation&quot;, record.generation);
            put(&quot;expiration&quot;, record.expiration);
            put(&quot;bins&quot;, new JSONObject(record.bins));
            if (record.duplicates != null){
                  JSONArray duplicates = new JSONArray();
                  for (Map&lt;String, Object&gt; duplicate : record.duplicates){
                        duplicates.add(new JSONObject(duplicate));
                  }
                  put(&quot;duplicates&quot;, duplicates);
             }
       }
}</pre>
<p>这个类并不复杂也很通用。你可能会希望为特定的记录指定使用你的JSON转换器。</p>
<h3>创建资源控制器</h3>
<p>在Spring中，REST端点（endpoint）是Spring MVC控制器。如下的代码能够处理对/as/{namespace}/{set}/getAll/1234的GET请求，并会返回key为1234的航班记录，在这里{namespace}是针对Aerospike命名空间的路径变量，{set}是针对Aerospike集合的路径变量。</p>
<pre><font color="#408080">src/main/java/com/aerospike/client/rest/RESTController.java</font>
package com.aerospike.client.rest;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;
import com.aerospike.client.AerospikeClient;
import com.aerospike.client.Bin;
import com.aerospike.client.Key;
import com.aerospike.client.Record;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.WritePolicy;

@Controller
public class RESTController {
      @Autowired
      AerospikeClient client;
    @RequestMapping(value=&quot;/as/{namespace}/{set}/getAll/{key}&quot;, 
method=RequestMethod.GET)
    public @ResponseBody JSONRecord getAll(@PathVariable
(&quot;namespace&quot;) String namespace, 
            @PathVariable(&quot;set&quot;) String set,
            @PathVariable(&quot;key&quot;) String keyvalue) throws Exception {
    Policy policy = new Policy();
    Key key = new Key(namespace, set, keyvalue);
     Record result = client.get(policy, key);
     return new JSONRecord(result);
  }
}</pre>
<p>针对人类用户的控制器和针对REST端点控制器之间的区别在于响应体中要包含数据，在这个场景中也就是一个JSON对象，它代表了从Aerospike读取到的记录。</p>
<p>@ResponseBody注解会告知Spring MVC将返回的对象写入到响应体之中。</p>
<h3>创建可执行的主类</h3>
<p>现在要实现主方法来创建Spring MVC控制器，最简单的方式就是使用SpringApplication帮助类。</p>
<pre><font color="#408080">src/main/java/com/aerospike/client/rest/AerospikeRESTfulService.java</font>
package com.aerospike.client.rest;
import java.util.Properties;
import javax.servlet.MultipartConfigElement;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import com.aerospike.client.AerospikeClient;
import com.aerospike.client.AerospikeException;
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class AerospikeRESTfulService {
      @Bean
      public AerospikeClient asClient() throws AerospikeException {
            Properties as = System.getProperties();
            return new AerospikeClient(as.getProperty(&quot;seedHost&quot;), 
                  Integer.parseInt(as.getProperty(&quot;port&quot;)));
      }
      @Bean
      public MultipartConfigElement multipartConfigElement() {
            return new MultipartConfigElement(&quot;&quot;);
      }
      public static void main(String[] args) throws ParseException {
             Options options = new Options();
             options.addOption(&quot;h&quot;, &quot;host&quot;, true, 
                   &quot;Server hostname (default: localhost)&quot;);
             options.addOption(&quot;p&quot;, &quot;port&quot;, true, &quot;Server port (default: 3000)&quot;);
             // parse the command line args
             CommandLineParser parser = new PosixParser();
             CommandLine cl = parser.parse(options, args, false);
             // set properties
             Properties as = System.getProperties();
             String host = cl.getOptionValue(&quot;h&quot;, &quot;localhost&quot;);
             as.put(&quot;seedHost&quot;, host);
             String portString = cl.getOptionValue(&quot;p&quot;, &quot;3000&quot;);
             as.put(&quot;port&quot;, portString);
             // start app
             SpringApplication.run(AerospikeRESTfulService.class, args);
      }
}</pre>
<p>这里添加了<a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/context/annotation/EnableAutoConfiguration.html">@EnableAutoConfiguration</a>注解：它会对一些内容进行默认的加载（如嵌入式的servlet容器），这取决于类路径的内容以及其他的一些事情。</p>
<p>它还使用了<a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/context/annotation/ComponentScan.html">@ComponentScan</a>注解，这个注解会告诉Spring扫描rest包来查找控制器（以及其他有注解的组件类）。</p>
<p>最后，这个类还使用了<a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>注解。它允许你将<a href="http://www.aerospike.com/java_api/">AerospikeClient</a>实例配置为一个Spring的bean。</p>
<p>这里还定义了一个MultipartConfigElement bean。它能够让你使用这个服务处理POST操作。</p>
<p>主方法中大部分的主体内容都是读取命令行参数以及系统属性，以便指定Aerospike集群的seed主机和端口。</p>
<p>非常简单！</p>
<h2>上传数据</h2>
<p>你可能希望往这个服务中上传数据。要做到这一点的话，我们需要为RESTController类添加一个额外的方法来处理上传的文件。在这个例子中，这会是包含航行记录的CSV文件。</p>
<pre><font color="#408080">src/main/java/com/aerospike/client/rest/RESTController.java</font>
@Controller
public class RESTController {
   . . . (code omitted) . . .
   /*
    * CSV flights file upload
    */
   @RequestMapping(value=&quot;/uploadFlights&quot;, method=RequestMethod.GET)
   public @ResponseBody String provideUploadInfo() {
       return &quot;You can upload a file by posting to this same URL.&quot;;
   }
   @RequestMapping(value=&quot;/uploadFlights&quot;, method=RequestMethod.POST)
   public @ResponseBody String handleFileUpload(@RequestParam(&quot;name&quot;) String name, 
          @RequestParam(&quot;file&quot;) MultipartFile file){
     if (!file.isEmpty()) {
           try {
                 WritePolicy wp = new WritePolicy();
                 String line = &quot;&quot;;
                 BufferedReader br = new BufferedReader(new 
InputStreamReader(file.getInputStream()));
                 while ((line = br.readLine()) != null) {
                       // use comma as separator
                       String[] flight = line.split(&quot;,&quot;);

                       /*
                        * write the record to Aerospike
                        * NOTE: Bin names must not exceed 14 characters
                        */
                            client.put(wp,
                 new Key(&quot;test&quot;, &quot;flights&quot;,flight[0].trim() ),
                 new Bin(&quot;YEAR&quot;, Integer.parseInt(flight[1].trim())),
                 new Bin(&quot;DAY_OF_MONTH&quot;, Integer.parseInt(flight[2].trim())),
                 new Bin(&quot;FL_DATE&quot;, flight[3].trim()),
                 new Bin(&quot;AIRLINE_ID&quot;, Integer.parseInt(flight[4].trim())),
                 new Bin(&quot;CARRIER&quot;, flight[5].trim()),
                 new Bin(&quot;FL_NUM&quot;, Integer.parseInt(flight[6].trim())),
                 new Bin(&quot;ORI_AIRPORT_ID&quot;, Integer.parseInt(flight[7].trim())),
                 new Bin(&quot;ORIGIN&quot;, flight[8].trim()),
                 new Bin(&quot;ORI_CITY_NAME&quot;, flight[9].trim()),
                 new Bin(&quot;ORI_STATE_ABR&quot;, flight[10].trim()),
                 new Bin(&quot;DEST&quot;, flight[11].trim()),
                 new Bin(&quot;DEST_CITY_NAME&quot;, flight[12].trim()),
                 new Bin(&quot;DEST_STATE_ABR&quot;, flight[13].trim()),
                 new Bin(&quot;DEP_TIME&quot;, Integer.parseInt(flight[14].trim())),
                 new Bin(&quot;ARR_TIME&quot;, Integer.parseInt(flight[15].trim())),
                 new Bin(&quot;ELAPSED_TIME&quot;, Integer.parseInt(flight[16].trim())),
                 new Bin(&quot;AIR_TIME&quot;, Integer.parseInt(flight[17].trim())),
                 new Bin(&quot;DISTANCE&quot;, Integer.parseInt(flight[18].trim()))
                            );
                            System.out.println(&quot;Flight [ID= &quot; + flight[0] 
                 + &quot; , year=&quot; + flight[1] 
                 + &quot; , DAY_OF_MONTH=&quot; + flight[2] 
                 + &quot; , FL_DATE=&quot; + flight[3] 
                 + &quot; , AIRLINE_ID=&quot; + flight[4] 
                 + &quot; , CARRIER=&quot; + flight[5] 
                 + &quot; , FL_NUM=&quot; + flight[6] 
                 + &quot; , ORIGIN_AIRPORT_ID=&quot; + flight[7] 
                 + &quot;]&quot;);
                        }
                        br.close();
                        return &quot;You successfully uploaded &quot; + name;
                  } catch (Exception e) {
          return &quot;You failed to upload &quot; + name + &quot; =&gt; &quot; + e.getMessage();
                  }
            } else {
                  return &quot;You failed to upload &quot; + name + 
&quot; because the file was empty.&quot;;
              }
       }
}</pre>
<p>新方法handleFileUpload()响应POST请求并且会读取上传的流，每次读取一行。每一行解析后，会构建一个Key对象和多个Bin对象，据此来形成Aerospike记录。最后，调用Aerospike的put()方法，将记录存储到Aerospike集群之中。</p>
<p>另外一个新方法provideUploadInfo()响应GET请求，并返回一条信息来表明允许进行上传。</p>
<h3>上传的客户端应用</h3>
<p>上传可以通过任何你希望的方式来实现。不过，你可以使用下面这个单独的Java类将数据上传到服务上。</p>
<pre><font color="#408080">src/test/java/com.aerospike.client.rest/FlightsUploader.java</font>
package com.aerospike.client.rest;
import org.junit.Before;
import org.junit.Test;
import org.springframework.core.io.FileSystemResource;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

public class FilghtsUploader {
      private static final String TEST_FILE = &quot;flights_from.csv&quot;;
      @Before
      public void setUp() throws Exception {
      }

      @Test
      public void upload() {
        RestTemplate template = new RestTemplate();
        MultiValueMap&lt;String, Object&gt; parts = new LinkedMultiValueMap
&lt;String, Object&gt;();
        parts.add(&quot;name&quot;, TEST_FILE);
        parts.add(&quot;file&quot;, new FileSystemResource(TEST_FILE));
        String response = template.postForObject
(&quot;<a href="http://localhost:8080/uploadFlights">http://localhost:8080/uploadFlights</a>&quot;,parts, String.class);
        System.out.println(response);
      }
}</pre>
<h3>航班数据</h3>
<p>这是来自2012年的真实数据，包括了大约一百万条的记录，所以请注意它需要几分钟的时间才能完成上传。</p>
<h2>构建并运行服务</h2>
<p>Maven的pom.xml会将服务打包为一个单独的jar文件。使用如下的命令：</p>
<p><strong>mvn clean package</strong></p>
<p>这样会生成独立的web服务应用，它会打包为一个可运行的jar文件，位于target子目录之中。这个jar文件中包含了一个Tomcat的实例，所以你可以直接运行这个jar文件，而没有必要将其安装到应用服务器之中。</p>
<p><strong>java -jar aerospike-restful-example-1.0.0.jar</strong></p>
<p><img width="600" src="http://infoqstatic.com/resource/articles/rest-webservice-spring-boot-aerospike/zh/resources/1230010.png" alt="" _href="img://null" _p="true" /></p>
<h2>总结</h2>
<p>恭喜你！你现在已经使用Spring开发了一个简单的RESTful服务，并且连接到了Aerospike集群之中。</p>
<h2>完整的样例代码</h2>
<p><a href="https://docs.google.com/a/aerospike.com/file/d/0B8luCpttpeaAVkpHZ1NWYy1TbnM/edit?usp=sharing">样例代码</a></p>
<h2>设计中的考量</h2>
<p>目前，访问控制是通过应用来处理的，并不是通过数据库。因为认证过程会拖慢数据库的速度，实际上，所有的NoSQL数据库均不支持这种功能。我们的大多数客户更关注于提升的速度，而不是集成的认证特性。</p>
<p>另外一个要求的通用特性就是两个不同数据集之间的连接（join）。对于所有的分布式数据库来讲，这都是一个挑战，因为要连接的数据是分布式的。在本例中，开发人员必须在应用中实现连接。</p>
<h2>关于作者</h2>
<p><img alt="" style="float: left; margin-right: 10px" src="http://infoqstatic.com/resource/articles/rest-webservice-spring-boot-aerospike/zh/resources/1230011.jpg" _href="img://null" _p="true" /><b>Peter Milne</b>是一位很有经验的IT专业人士，对于软件开发和产品的整个生命周期都有着丰富的经验。对于小型和大型的开发团队，他都具有技术技能和管理经验。Peter最近以来在Aerospike担任高级解决方案架构师。在此之前，他在MLC担任高级分析师和编码人员，并且在iTerative Consulting担任过CTO，在此期间，他构建了一个Forte/UDS到Java的转换工具，达到了99.999%准确率。Peter在悉尼科技大学获得了分布式计算的理科硕士学位，并且具有多个直升机安全许可和证书。</p>
<div style="clear:both">
 &nbsp;
</div>
<p>原文英文链接：<a href="http://www.infoq.com/articles/rest-webservice-spring-boot-aerospike">Building a RESTful Web Service with Spring Boot to Access Data in an Aerospike Cluster</a></p><br><br><br><br><br><br></body></html>