<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Designing and Implementing Hypermedia APIs</h3><p>This article (the second in the series) focuses on implementing a hypermedia server. The message design and problem domain description used in this implementation were covered in <a href="http://www.infoq.com/articles/hypermedia-api-tutorial-part-one;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3">the previous article</a>. We'll talk in general terms about the role of hypermedia servers (routing, evaluation and execution) and then walk through the basics of implementation including the component layer, the representation layer, and the connector layer. Finally, we'll briefly cover client-side browser of a hypermedia API; specifically the limitations of relying on Web browsers and command-line tools and the advantages of the &quot;explorer&quot; approach.</p><p>This article walks through the high-level details of a fully functional server built using Node.js. To keep things relatively simple, this example implementation does not take advantage of many custom Node modules or frameworks and even handles storage of simple disk files. Because the implementation is kept 'bare bones' and basic, it does not contain all the features and safety of a real production-level server, but you'll still be able to get the main point of the implementation pattern. Also, even though this server is built using Node.js, you should have no problem transferring the ideas shown here into your preferred programming language, framework and/or platform.</p><p><strong>NOTE: <br /> </strong>The full source code for this server implementation is available in <a href="https://github.com/apiacademy/class-scheduling">GitHub</a>.</p><h2>Hypermedia API Servers</h2><p>Hypermedia API Servers are basically Web Servers with a bit more work added. Like a common Web server, Hypermedia API servers accept requests, process them, and return responses. However, Hypermedia API servers do some additional work, too. They act as translators. Each request is sent in a predetermined message format, translated into something the server's components understand (storage, database, business logic), processed, and then translated back into some predetermined format that includes information on possible next steps&quot; for the client that made the request. Typical RPC-style API servers don't include that next step&quot; information.</p><p>This additional information can include whether this client can see related resources, can execute a search operation, can modify the data stored on the server, etc. All this is communicated by adding hypermedia controls (links and forms) based on the media type design understood by the client making the request. That client request may be tied to a user identity; one that may (or may not) have additional privileges, which affects what next steps&quot; are valid at the time of the request. This context-driven modification of the response is one of the key value-add&quot; elements to hypermedia-style implementations.</p><h3>Routing</h3><p>The first responsibility of an API server on the Web is to accept, parse, and route the incoming request. API servers on the Web are designed to use URIs as the primary means for routing requests once they arrive at the server. This is done by parsing the URI into path segments, the query string, etc. and, using that information, sending the details of that request (including possible request body data) to the right internal component for processing.</p><p>For example, this HTTP request:</p><pre>
GET/users/?search=pending
Host: http://www.example.org
Accept: application/vnd.collection+json
Authorization: q1w2e3r4t5=</pre><p>tells the server that a client wants to do a &quot;read&quot; operation searching for pending users on the www.example.org server. The client request indicates that the response should be represented in the collection+json format (a registered hypermedia type). Finally, this request has been made by an authenticated user as identified by the encrypted value in the Authorization header.</p><p>The server would likely break down the URI into it's parts:</p><ul> 
 <li>users</li> 
 <li>search=pending</li> 
</ul><p>and then formulate a valid request to an internal component to handle the task:</p><pre>
results = Users.Search('pending');</pre><p>The results would then be translated into the requested format and then returned to the client:</p><pre>
http.Response = Representation(results, 'collection+json');</pre><p>The example here is just pseudo-code, but you get the basic idea. API servers accept, route and process requests then create representations of the results to return to the client.</p><h3>Evaluation and Execution</h3><p>The details of processing requests involve evaluating the request (not just the URI but also the protocol details such as the method, additional headers, and any payload) and determining which internal routines need to be executed to fulfill the request. In the previous example, the server &quot;decided&quot; that <strong>/users/?search=pending</strong> meant that the server should pass the pending&quot; query string argument to the <strong>User</strong> module's <strong>Search</strong> function. The server also decided to format the reply as a collection+json representation based on the contents of the <strong>Accept</strong> header sent from the client.</p><p>The server acts as an intermediary between the outside world (which &quot;talks&quot; HTTP) and the internal components on the server (which talk whatever source code or local network language is in use). The server's role is to evaluate the request, convert that into &quot;component-speak&quot; and then format the reply appropriately. This make the servers' role a &quot;connector&quot; between the outside world and the internal components.</p><p><strong>NOTE:</strong> <br /> This &quot;component-connector&quot; model was referenced by Roy Fielding in his description of the Representation State Transfer (REST) architectural style for the Web.</p><p>In many implementations the responsibilities of components (internal) and connectors (external) are mixed together. Over the long term, this mixing of concerns can make maintenance and evolvability harder. For this reason, the implementation pattern shown in this article will emphasize the differences between component and connectors. You'll also see another responsibility identified as a separate concern; that of generating representations of internal data for responses.</p><h2>The Component Layer</h2><p>The component layer is where the work of solving problems for your domain happen; this is the stuff that no-one else does the same way. It's also work that usually has nothing to do with HTTP or the Web. For example, reading and writing data into storage, calculating formulas related to your business, enforcing business rules, etc. These are all component-level activities.</p><h3>Domain-Specific, Independent Implementation</h3><p>The problem domain identified in the previous article in this series was a Class Scheduling system. It handles managing students, teachers, courses, and combining all three of those into class schedules. These are all domain-specific details that live in the component layer. For that reason, our implementation has a module (called component.js) that handles this work. We'll also use a simple file-based storage module (called storage.js) to handle the read and write actions for this implementation.</p><p>These two modules (storage.js and component.js) are implemented to be unaware of any connector details (e.g. HTTP, WebSockets, etc.). The examples here are small but, in large systems, the component layer contains the unique details of the target domain (here that's the Class Scheduling domain). This layer is most often the value add&quot; of your implementation; the parts that no-one else does quite the same way.</p><p>Creating a separation of concerns (SoC) between the component layer and the rest of the system also improve the chances that new connectors (FTP, SMTP, etc.) can be added in the future with minimum disruption. It also means that optimizations at the connector layer (caching, scaling out with more servers, etc.) can be done without touching the components.</p><h3>Storage.js</h3><p>In this example, data storage is implemented as a simple file system. In production implementations this would likely be done using structured storage such as a document database (MongoDB, CouchDB, etc.), relational database (MySQL, Oracle, SQL Server, etc.), or some other storage system. It might even be done via a remote storage model using HTTP connectors!</p><p>Here's a snippet of code that shows how storage is implemented for our sample app:</p><pre><font color="#808080">var fs = require(<font color="#ff0000">'fs'</font>);<br />var folder <b>=</b> process.cwd()<b>+</b><font color="#ff0000">'/data/'</font>;<br /><br />module.exports <b>=</b> main;<br /><br />function main(object, action, arg1, arg2) {<br />&nbsp;&nbsp;&nbsp;&nbsp; var rtn;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; switch (action) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'list'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = getList(object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'filter'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = getList(object, arg1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'item'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = getItem(object, arg1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'add'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = addItem(object, arg1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'update'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = updateItem(object, arg1, arg2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <font color="#ff0000">'remove'</font>:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = removeItem(object, arg1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; return rtn;<br />}</font>
</pre><p><strong>NOTE:</strong> <br /> The full source code for this server implementation is available in <a href="https://github.com/apiacademy/class-scheduling">GitHub</a>.</p><p>Here's the detail of the <strong>addItem</strong> method:</p><pre><font color="#808080"><b>function</b> addItem(object, item) {<br />&nbsp;&nbsp;&nbsp;&nbsp; item.id <b>=</b> makeId();<br />&nbsp;&nbsp;&nbsp;&nbsp; item.dateCreated <b>=</b> <b>new</b> <font color="#0080ff">Date</font>();<br />&nbsp;&nbsp;&nbsp;&nbsp; fs.writeFileSync(folder<b>+</b>object<b>+</b>'/'<b>+</b>item.id, JSON.stringify(item));<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> getItem(object, item.id);<br />}</font></pre><p>And below is an example of the actual data stored on disk for a student record:</p><pre>
{
&nbsp;&nbsp;&nbsp;&nbsp; studentName: &quot;Mark Bunce&quot;,
&nbsp;&nbsp;&nbsp;&nbsp; standing: &quot;sophomore&quot;,
&nbsp;&nbsp;&nbsp;&nbsp; id: &quot;121drdhk3xh&quot;,
&nbsp;&nbsp;&nbsp;&nbsp; dateCreated: &quot;2013-01-26T01:47:01.057Z&quot;
}</pre><p>Basically, JSON objects are stored on the disk with unique names created by the makeId() routine. We'll take a look at how this storage module is called when we review the component.js module in the next section.</p><h3>Component.js</h3><p>In this example app, the component.js module handles all the domain-level details. It knows how to talk to storage and how to convert service requests such as &quot;Add Student&quot;, &quot;Assign Student to a class&quot;, etc. In a larger system, the component layer may include several modules but they would all still do the same basic type of work.</p><p>Along with storage handling, the component layer is responsible for the business logic for the solution. In our example the source code is in a single module (component.js) but in larger, more complete systems, you're likely to have multiple components; each handling different aspects of the business logic.</p><p>Below is some of the high-level code used to implement the business logic for handling schedule information:</p><pre><font color="#808080">exports.schedule <b>=</b> <b>function</b>(action, args1, args2) {<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>var</b> object, rtn;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; object <b>=</b> <font color="#ff0000">'schedule'</font>;<br />&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> <b>null</b>;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>switch</b>(action) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'list'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'list'</font>), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'read'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'item'</font>, args1), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'add'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'add'</font>, args1), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'update'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'update'</font>, args1, args2), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'remove'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'remove'</font>, args1), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br /><b> case</b> <font color="#ff0000">'assign'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; appendStudent(args1, args2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'item'</font>, args1), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addEditing(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>case</b> <font color="#ff0000">'unassign'</font><b>:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dropStudent(args1, args2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> loadList(storage(object, <font color="#ff0000">'item'</font>, args1), object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> addediting(rtn, object, args1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>break</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>default:</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b> <b>null</b>;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> rtn;<br />}</font></pre><p><strong>NOTE:</strong> <br /> The full source code for this server implementation is available in <a href="https://github.com/apiacademy/class-scheduling">GitHub</a>.</p><p>And here's the <strong>appendStudent</strong> function:&nbsp;</p><pre><font color="#808080"><b>function</b> appendStudent(skid, stid) {<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>var</b> schedule, student, coll, i, x, flg;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; schedule <b>=</b> storage(</font><font color="#ff0000">'schedule'</font><font color="#808080">,</font> <font color="#ff0000">'item'</font><font color="#808080">, skid);<br />&nbsp;&nbsp;&nbsp;&nbsp; student <b>=</b> storage(</font><font color="#ff0000">'student'</font><font color="#808080">,</font> <font color="#ff0000">'item'</font><font color="#808080">, stid);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; flg <b>=</b> <b>false</b>;<br /></font>
&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// make sure there's a collection</font></i>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(<b>!</b>schedule.students) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule.students <b>=</b> [];<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /></font>
&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// see if this student already exists</font></i>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">coll <b>=</b> schedule.students;<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(i<b>=</b><font color="#0080ff">0</font>, x<b>=</b>coll.length; i<b>&lt;</b>x; i<b>++</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(coll[i].id<b>===</b>student.id) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flg <b>=</b> <b>true</b>; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /></font>
&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// add it if needed</font></i>
&nbsp;&nbsp;&nbsp; <font color="#808080">&nbsp;<b>if</b>(flg<b>===false</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coll.push(student);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule.students <b>=</b> coll;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /></font>
&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// save results</font></i>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">storage(</font><font color="#ff0000">'schedule'</font><font color="#808080">,</font><font color="#ff0000"> 'update'</font><font color="#808080">, skid, schedule);<br />}</font></pre><p>Lastly, here is the routine that processes the list of one or more records from storage into an internal object graph. This is the format that is understood by all the component-level routines in this system.</p><pre><font color="#808080"><b>function</b> loadList(elm, name) {<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>var</b> coll, list, data, item, i, x;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(<font color="#0080ff">Array</font>.isArray(elm)<b>===false</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coll <b>=</b> [];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coll.push(elm);<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>else</b> {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coll <b>=</b> elm;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; item <b>=</b> [];<br />&nbsp;&nbsp;&nbsp;&nbsp; data <b>=</b> [];<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(i<b>=</b><font color="#0080ff">0</font>, x<b>=</b>coll.length; i<b>&lt;</b>x; i<b>++</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(prop <b>in</b> coll[i]) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d <b>=</b> {};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.name <b>=</b> prop;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.value <b>=</b> coll[i][prop];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.prompt <b>=</b> prop;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.push(d);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[i] <b>=</b> {};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[i].name <b>=</b> name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[i].display <b>=</b> {};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[i].display.data <b>=</b> data;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data <b>=</b> [];<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; list <b>=</b> {};<br />&nbsp;&nbsp;&nbsp;&nbsp; list.name <b>=</b> name;<br />&nbsp;&nbsp;&nbsp;&nbsp; list.item <b>=</b> item;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> list;<br />}</font></pre><p>Note that the component layer does not &quot;talk&quot; HTTP or XML; that's handled separately. The component layer only needs to be able to implement the internal business requirements and communicate with storage services (locally or remotely). The component layer does, however, include some links when appropriate. How they will be rendered (if at all) is left to the next element in our implementation: The Representation Service.</p><h2>The Representation Service</h2><p>HTTP is an unusual protocol because it is designed to allow the same data to be represented in different formats, called media types. These media types are well defined and (usually) registered with a standards body (the IANA). Clients and servers &quot;share understanding&quot; about how the data and transaction details are represented and that is what makes it possible for a client (e.g. an HTML-aware Web browser) to successfully communicate with a new-found server.</p><h3>Media-Type Focus</h3><p>It's not just the protocol semantics that the two parties share, but also the message semantics. For example the HTML A, LINK, FORM and INPUT elements in HTML all indicate transition details. In the previous article in this series a custom hypermedia type was designed (application/TK). That design has LINK, ACTION, and DATA elements that indicate transitions. The representation service is the place where the information from internal storage and the operations in the private component layer are translated into a public representation; one that both client and server understand.</p><p>This focus on using the message itself - the media type as the primary &quot;shared understanding&quot; between client and server is one of the important features of hypermedia systems. The media type is the way clients and server &quot;talk to each other without having to know what programming language (Ruby, Python, PHP, Node, etc.), coding style (Object Oriented, Functional, Procedural), or even operating system used by either party.</p><h3>Translating Domain-Specific Information</h3><p>Representation services do very important work. They accept requests from the public connector (we'll see what that looks like in the next section), make requests to the private component layer and act as a translator between these two &quot;worlds.&quot;</p><h3>Representation.js</h3><p>In this sample implementation, the representation layer is housed in a single module called representation.js. This module is able to &quot;talk&quot; application/TK.</p><p>Here is the high-level code that &quot;walks&quot; the internal object model supplied by the component layer and translates that into the public Class Scheduling hypermedia type:</p><pre><font color="#808080"><b>function</b> processCSDoc(object) {<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>var</b> doc, i, x, tmp, coll;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b></font> <font color="#ff0000">'&lt;root&gt;'</font><font color="#808080">;</font>

&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// handle action element</font></i>
&nbsp;&nbsp;&nbsp; <font color="#808080">&nbsp;<b>if</b>(object <b>&amp;&amp;</b> object.action) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b> actionElement(object.action);<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /></font>
&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#c0c0c0">// handle lists</font></i>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(object <b>&amp;&amp;</b> object.list) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(i<b>=</b>0,x<b>=</b>object.list.length; i<b>&lt;</b>x;i<b>++</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b> listElement(object.list[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; <font color="#c0c0c0">&nbsp;<i>// handle error</i></font><br /></font>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(object <b>&amp;&amp;</b> object.error) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b></font> <font color="#ff0000">'&lt;error&gt;'</font><font color="#808080">;<br /></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">coll <b>=</b> object.error.data;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>(i<b>=</b></font><font color="#0080ff">0</font><font color="#808080">,</font> <font color="#808080">x<b>=</b>coll.length; i<b>&lt;</b>x; i<b>++</b>) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b> dataElement(coll[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b></font><font color="#ff0000"> '&lt;/error&gt;'</font><font color="#808080">;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; doc <b>+=</b> </font><font color="#ff0000">'&lt;/root&gt;'</font><font color="#808080">;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> doc;<br />}</font></pre><p>NOTE: <br /> The full source code for this server implementation is available in <a href="https://github.com/apiacademy/class-scheduling">GitHub</a>.</p><p>The routine &quot;knows&quot; the layout of the internal object graph supplied via the object argument above. The routine also &quot;knows&quot; the layout of a valid Class Scheduling message. A private object graph goes in and a public hypermedia message comes out.</p><p>Here's the dataElement routine; the one that converts any data points in the private graph into valid data elements in the message.</p><pre><b>function</b> dataElement(data) {
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>var</b> rtn;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>=</b></font><font color="#ff0000"> '&lt;data '</font><font color="#808080">;<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(data.name) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>+=</b></font><font color="#ff0000"> 'name=&quot;'</font><font color="#808080"><b>+</b>data.name<b>+</b></font><font color="#ff0000">'&quot; '</font><font color="#808080">;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(data.prompt) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>+=</b></font><font color="#ff0000"> 'prompt=&quot;'</font><font color="#808080"><b>+</b>data.prompt<b>+</b></font><font color="#ff0000">'&quot; '</font><font color="#808080">;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(data.value) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>+=</b></font><font color="#ff0000"> 'value=&quot;'</font><font color="#808080"><b>+</b>data.value<b>+</b></font><font color="#ff0000">'&quot; '</font><font color="#808080">;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(data.embed) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>+=</b></font> <font color="#ff0000">'embed=&quot;'</font><font color="#808080"><b>+</b>data.embed<b>+</b></font><font color="#ff0000">&quot;' </font><font color="#808080">&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; rtn <b>+=</b></font><font color="#ff0000"> '/&gt;'</font><font color="#808080">;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> rtn;<br />}</font></pre><p>And, finally, here's an example of an internal object graph followed by the same information represented in the</p><pre>
application/vnd.apiacademy-scheduling+xml</pre><p>hypermedia format.</p><pre>
// internal object graph
{
&nbsp;&nbsp; &quot;action&quot;:
&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;link&quot;: [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;name&quot;:&quot;home&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;href&quot;:&quot;http://localhost:1337/&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;action&quot;:&quot;read&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prompt&quot;:&quot;Home&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;name&quot;:&quot;student&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;href&quot;:&quot;http://localhost:1337/student/&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;action&quot;:&quot;list&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prompt&quot;:&quot;Students&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;name&quot;:&quot;teacher&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;href&quot;:&quot;http://localhost:1337/teacher/&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;action&quot;:&quot;list&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prompt&quot;:&quot;Teachers&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;name&quot;:&quot;course&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;href&quot;:&quot;http://localhost:1337/course/&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;action&quot;:&quot;list&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prompt&quot;:&quot;Courses&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;name&quot;:&quot;schedule&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;href&quot;:&quot;http://localhost:1337/schedule/&quot;,
           &quot;action&quot;:&quot;list&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prompt&quot;:&quot;Schedules&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]
&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; }
}

// public hypermedia message
&lt;root&gt;
&nbsp;&nbsp; &lt;actions&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;link name=&quot;home&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; href=&quot;http://localhost:1337/&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action=&quot;read&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompt=&quot;Home&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;link name=&quot;student&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; href=&quot;http://localhost:1337/student/&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action=&quot;list&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompt=&quot;Students&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;link name=&quot;teacher&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; href=&quot;http://localhost:1337/teacher/&quot; 
       action=&quot;list&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompt=&quot;Teachers&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;link name=&quot;course&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; href=&quot;http://localhost:1337/course/&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action=&quot;list&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompt=&quot;Courses&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;link name=&quot;schedule&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; href=&quot;http://localhost:1337/schedule/&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action=&quot;list&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompt=&quot;Schedules&quot; /&gt;
&nbsp;&nbsp; &lt;/actions&gt;
&nbsp;&nbsp; &lt;/root&gt;</pre><p>You may notice that the layout of both the internal and public data is very similar. This is not a requirement to translate between private object graphs and public media types, but it does sometimes make things easier. However, this is not a common case; especially in systems that support more than one public message format. The similarities here were made to keep translation straightforward and the comparison relatively easy to view and analyze.</p><p>So, with a representation layer in place, the last step is to implement the Connector layer that converts incoming protocol requests (in this case, HTTP) into something the components can understand and then return the results of the representation layer's work back to the caller.</p><h2>The Connector Layer</h2><p>The Connector Layer is the layer that is exposed to the public Web. Connectors &quot;speak&quot; HTTP, DNS, etc. and are the gateways into which requests flow and responses return. Web server engines (Apache, IIS, nginx, etc.) are the most well known type of connector. Most of them support more than just blindly accepting requests and returning responses. They also support some level of routing and scripting. These make it possible to write code that inspects incoming requests, passes them to the proper component and provides the proper response once the component has completed it's work.</p><h3>Protocol-Level Interaction</h3><p>Connectors focus on protocol-level interaction. An HTTP connector understands the details of the HTTP protocol and makes those details available for inspection and manipulation. Inspecting the URL on the incoming request, validating the headers to determine what the response format should be, and routing the request (and any arguments) to the proper component is the job of the connector.</p><p>For this article series, Node.js is the connector. It is rather simple to start up an HTTP connector using Node.js. Using Node.js to provide routing and manipulation of HTTP messages is also easy.</p><h3>Mediating Between Internal and External World</h3><p>Since it is the connector that faces the external world, scripting the connector means deciding which requests are accepted, which URIs are valid, and what each of them return when executed. This means mapping the internal operations of our problem domain (Class Scheduling) to the external limitations of (in our case) HTTP. Much of this was described in the documentation created as part of the previous article in this series. The Protocol Mapping section of the Media Type document maps domain actions to HTTP methods. The Problem Domain document sets out which data elements are supplied when making HTTP requests. This material provides the basis for implementing connector scripts for our server.</p><h3>App.js</h3><p>In this example, the connector coding resides in the app.js module. This is the place when HTTP requests arrive and where HTTP responses originate. To keep things easy to read, no installed external modules or frameworks are used in this example. While that means some of the code is a bit &quot;wordy&quot;, that also means there are no &quot;hidden&quot; features and you don't need to know much about Node's external modules in order to understand what's going on in these examples.</p><p>The module uses simple regular expressions to identify request routing rules:</p><pre><i><font color="#c0c0c0">// routing rules</font></i>
<font color="#808080"><b>var</b> reHome <b>=</b> <b>new</b></font> <font color="#0080ff">RegExp</font>(<font color="#ff0000">'^\/$'</font>,<font color="#ff0000">'i'</font>);
<font color="#808080"><b>var</b> reCourse <b>=</b> <b>new</b></font> <font color="#0080ff">RegExp</font>(<font color="#ff0000">'^\/course\/.*'</font>,<font color="#ff0000">'i'</font>);
<font color="#808080"><b>var</b> reSchedule <b>=</b> <b>new</b></font> <font color="#0080ff">RegExp</font>(<font color="#ff0000">'^\/schedule\/.*'</font>,<font color="#ff0000">'i'</font>);
<font color="#808080"><b>var</b> reStudent <b>=</b> <b>new</b></font> <font color="#0080ff">RegExp</font>(<font color="#ff0000">'^\/student\/.*'</font>,<font color="#ff0000">'i'</font>);
<font color="#808080"><b>var</b> reTeacher <b>=</b> <b>new</b></font> <font color="#0080ff">RegExp</font>(<font color="#ff0000">'^\/teacher\/.*'</font>,<font color="#ff0000">'i'</font>);</pre><p>The code below uses one of the above rules to evaluate the incoming request and route it to the proper connector component.</p><pre><i><font color="#c0c0c0">// schedule</font></i>
<font color="#808080"><b>if</b>(flg<b>===false</b> <b>&amp;&amp;</b> reSchedule.test(req.url)) {</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">flg <b>=</b> <b>true</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> schedule(req, res, parts, root)</font>
<font color="#808080">}</font></pre><p><strong>NOTE:</strong> <br /> The full source code for this server implementation is available in <a href="https://github.com/apiacademy/class-scheduling">GitHub</a>.</p><p>There is similar code in the app.js module for each routing expression.</p><p>Now, here is the code inside the schedule connector module that inspects the details of the request, converts it into an internal representation and ships it off to the proper component.</p><pre><font color="#808080"><b>function</b> schedule(req, res, parts, base) {</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>var</b> code, doc;</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">root <b>=</b> base;</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>switch</b>(req.method) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'GET'</font><b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(parts[<font color="#0080ff">1</font>]) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b><font color="#0080ff">200</font>, doc<b>:</b>sendItem(req, res, parts[<font color="#0080ff">1</font>])};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>else</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b><font color="#0080ff">200</font>, doc<b>:</b>sendList(req, res)};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'POST'</font><b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(parts[<font color="#0080ff">1</font>]) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> errorDoc(req, res,<font color="#ff0000"> 'Method Not Allowed'</font>, <font color="#0080ff">405</font>);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>else</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>switch</b>(parts[<font color="#0080ff">0</font>].toLowerCase()) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'assign'</font> <b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b><font color="#0080ff">200</font>, doc<b>:</b>assignStudent(req, res)};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'unassign'</font> <b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b><font color="#0080ff">200</font>, doc<b>:</b>dropStudent(req, res)};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b> <font color="#ff0000">'schedule' </font><b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b><font color="#0080ff">200</font>, doc<b>:</b>addItem(req, res)};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>default</b> <b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> errorDoc(req, res, <font color="#ff0000">'Method Not Allowed'</font>, <font color="#0080ff">405</font>);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'PUT'</font><b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(parts[<font color="#0080ff">1</font>]) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b>200,doc<b>:</b>updateItem(req, res, parts[<font color="#0080ff">1</font>])};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>else</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> utils.errorDoc(req, res, <font color="#ff0000">'Method Not Allowed'</font>,<font color="#0080ff">405</font>);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>break</b>;</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>case</b><font color="#ff0000"> 'DELETE'</font><b>:</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>if</b>(parts[<font color="#0080ff">1</font>]) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> {code<b>:</b>204,doc<b>:</b>removeItem(req, res, parts[<font color="#0080ff">1</font>])};</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>else</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> utils.errorDoc(req, res, <font color="#ff0000">'Method Not Allowed'</font>, <font color="#0080ff">405</font>);</font>
&nbsp;&nbsp;&nbsp;          <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#808080">default:</font></b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> utils.errorDoc(req, res, <font color="#ff0000">'Method Not Allowed'</font>, <font color="#0080ff">405</font>);</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>return</b> doc;</font>
<font color="#808080">}</font></pre><p>You can see that the connector inspects the URL, checks the HTTP method, and then passes the work on to a local routine which processes an payload that was passed in and then passes things to the component layer.</p><p>Here's the bit of connector code that calls the component module to handle assigning a student to an existing class:</p><pre><font color="#808080"><b>function</b> assignStudent(req, res) {</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>var</b> body, doc, msg, item;</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">body <b>=</b> <font color="#ff0000">''</font>;</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">req.on(<font color="#ff0000">'data'</font>, <b>function</b>(chunk) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">body <b>+=</b> chunk;</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">});</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">req.on(<font color="#ff0000">'end'</font>, <b>function</b>() {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>try</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">msg <b>=</b> qs.parse(body);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">item <b>=</b> component.schedule(<font color="#ff0000">'assign'</font>, msg.scheduleId, msg.studentId);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> sendItem(req, res, msg.scheduleId);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>catch</b>(ex) {</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">doc <b>=</b> utils.errorDoc(req, res, <font color="#ff0000">'Server Error'</font>, <font color="#0080ff">500</font>);</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">}</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">});</font>

&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080"><b>return</b> doc;</font>
<font color="#808080">}</font></pre><p>Finally, once the component has done the work, an internal graph object is returned which must be represented in the public Class Scheduling hypermedia type and returned to the caller.</p><p>Here's the code in app.js that make the call to the representation layer and sends it back out over HTTP to the caller:</p><pre><i><font color="#c0c0c0">// send out response</font></i>
<font color="#808080"><b>if</b>(doc<b>!==null</b>) {</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">rtn <b>=</b> representation(doc.doc);</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">sendResponse(req, res, rtn, doc.code, doc.headers);</font>
<font color="#808080">}</font>
<font color="#808080"><b>else</b> {</font>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#808080">sendResponse(req, res, <font color="#ff0000">'&lt;root /&gt;'</font>, <font color="#0080ff">500</font>);</font>
<font color="#808080">}</font></pre><p>And that's all there is to connector coding. The connector layer routes and parses the requests, passes them off to the appropriate component and, when the internal response is returned, passes that to the representation layer and then returns that to the caller.</p><h2>Browsing the API</h2><p>Once you have the server up and running, you want to browse that API, validate the various operations, and explore it a bit. For the typical Web application, this can be done using a common Web browser. That works because almost all Web applications limit themselves to a single hypermedia type (HTML) and a handful of other standardized media formats (CSS, Javascript, binary images, etc.).</p><p>The common Web browser is also an incredibly fine-tuned application. By adhering closely to a handful of standards, browsers can successfully connect and interact with any Web server that also follows the same standards. We have discovery and interoperability working at the same time.</p><h3>The Limitations of the Common Web Browser</h3><p>When servers use uncommon registered media types such as Atom, HAL, Collection+JSON, Siren, etc. there is no assurance that common Web browsers will understand them and be able to interact successfully with the server. Browsers will not share understanding of the hypermedia controls (transitions) that appear in messages. Browsers may not &quot;know&quot; which HTTP method to apply for various transitions (GET, POST, PUT, DELETE, etc.). And browsers may not know which data element should be rendered locally (e.g. an image) or treated as a navigation (e.g. a link).</p><p>In the case of our XML-based hypermedia type created just for this article series, browsers can actually get us &quot;part of the way&quot; toward being able to browse our Server API. Since the format is XML, all common browsers will display the responses clearly. There are even some Web browser plug-ins that not only render XML well, they also parse it and allow users to click on links to navigate the API. Below is a screenshot from Google's Chrome browser with such a plug-in loaded and running while viewing a response from our Class Scheduling server.</p><p>(Click on the image to enlarge it)</p><p class="image-wide"><a href="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/fig1large.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" _href="resource://fig1large.jpg"><img vspace="3" hspace="3" _p="true" _href="img://7fig1small.jpg" src="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/7fig1small.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" alt="" /></a></p><p>This is helpful because we can move from one state to the next by simply clicking on the links in the responses. However, there is no support for executing transitions that support data parameters. In short, the plug-in does not know how to recognize and process the <strong>&lt;template /&gt;</strong> elements of our custom media type.</p><p>If we want to execute state transitions that include passing variables, we need to rely on other tools.</p><h3>The Limitations of the Command Line</h3><p>The most common approach for executing parameterized interactions for the Web are command-line tools like CURL and WGET. In fact, it's not unusual for API authors to claim they have a quality interface because &quot;you can just CURL it!&quot; For example, here is a command for creating a new student record for our server implementation using CURL.</p><p>First, a small file (post-student.txt) that contains the content to send to the server:</p><pre>
studentName=Marius%20Wingbat&amp;standing=junior</pre><p>and then the actual command line that uses CURL to send this content to the running server:</p><pre>
curl -X POST -d @post-student.txt http://localhost:1337/student/</pre><p>Of course you can also retrieve data from servers using command-line tools:</p><pre>
curl http://localhost:1337/course/</pre><p>but the resulting response is pretty much unusable (see screenshot below):</p><p>(Click on the image to enlarge it)</p><p class="image-wide"><a href="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/fig2arge.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" _href="resource://fig2arge.jpg"><img vspace="3" hspace="3" _p="true" _href="img://8fig2small.jpg" src="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/8fig2small.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" alt="" /></a></p><p>While it's possible to use command-line scripting tools to pipe these results to parsing tools in order to present a more understandable version of the response, the current crop of client-side tools do not easily support an interactive hypermedia experience, either.</p><p>What is needed is something that blends the interactive value of read-only browser-based tooling with the power of command-line style &quot;write-able&quot; interactions.</p><h3>The Advantages of a Media Type Explorer</h3><p>One way to achieve a more fully functional browser-style interactive experience using custom media types is to create an &quot;explorer&quot; interface. This interface leads humans through a hypermedia-style UI similar to today's common Web browsers and offers the ability to execute parameterized transitions, too. In fact, any hypermedia-style media type can support this kind of experience. For example, the Hypertext Application Language (HAL) - an IANA-registered media type offer just such an experience today with it's HalTalk explorer (see screenshot below):</p><p>(Click on the image to enlarge it)</p><p class="image-wide"><a href="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/fig3large.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" _href="resource://fig3large.jpg"><img vspace="3" hspace="3" _p="true" _href="img://4fig3small.jpg" src="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/4fig3small.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" alt="" /></a></p><p>Explorers make it possible for humans to browse and interact with any hypermedia server that &quot;speaks&quot; the same language. This may not be at the level of supporting a stand-alone custom application platform for the media type, but it goes quite a ways toward making these hypermedia types available and &quot;surf-able&quot; in order to validate the functionality and inspect newly discovered servers and their APIs.</p><p>In the next article in this series, we'll build an explorer for our Class Scheduling media type as well as other more familiar clients including an automated bot to perform tasks without the direct intervention of humans at runtime.</p><h2>Summary</h2><p>In this article we looked at the details of building a server that supports a custom hypermedia format as the primary interface - a hypermedia API. Along the way, a general model for hypermedia server implementation was outlined. One based on a separation of concerns between private components and public connectors. Components handle the storage and business logic. Connectors handle the translation of the private data into a public format (in this example, the Class Scheduling media type) and the routing of requests to the proper internal components. The notion of a representation layer was introduced as a way to create a bridge between the private and public portions of the system and also as a way to allow for future support for multiple representation formats when needed. This combination of domain-specific components, and domain-agnostic connectors provides a solid, scalable basis for hypermedia-style servers.</p><p>The next installment in this series will explore the details of coding various types of hypermedia clients. Ones that provide a &quot;faithful rendering&quot; of the server's responses, ones that maintain their own &quot;custom view&quot; of server replies in order to establish their own application interface, and ones that act as automated robots that solve specific problems without the need for human intervention at runtime.</p><h2>About the Author</h2><p><strong><img vspace="3" hspace="3" align="left" _p="true" _href="img://mikeAmundsen 2.jpg" src="/resource/articles/hypermedia-api-tutorial-part-two/en/resources/mikeAmundsen 2.jpg;jsessionid=76BD464320105C7D7C707F7A4CF1F0F3" alt="" />Mike Amundsen</strong> is Principal API Architect for Layer 7 Technologies, helping people build great APIs for the Web. An internationally known author and lecturer, Mike travels throughout the US and Europe consulting and speaking on distributed network architecture, Web application development, Cloud computing, and other subjects. He has more than a dozen books to his credit.</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>REMINDER:</strong></p><p>All the source code for the server implementation discussed here is available at the <a href="https://github.com/apiacademy/class-scheduling">GitHub</a> repository for this series. Readers are encouraged to download the code and provide contributions and comments in the public repo.</p><div class="clearer-space"></div></body></html>