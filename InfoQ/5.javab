<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>Application Security Testing: The Double-sided Black Box</h3><p>One of the biggest risks with software security is the opaque nature of verification tools and processes, and the potential for false negatives not covered by a particular verification technique (e.g. automated dynamic testing).</p><p>Despite many <a href="https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/sdlc/326-BSI.html">best practices</a> around secure Software Development Lifecycle (SDLC) most organizations tend to <a href="http://www.quocirca.com/media/articles/072012/721/Quo%20CRN%20-%20Sw%20sx%20-%20for%20web.pdf">primarily rely on testing</a> to build secure software. One of the most significant byproducts from current methods of testing is that organizations rarely understand what is being tested - and more importantly - what is NOT being tested by their solution. Our <a href="http://sdelements.com/security-requirements/">research</a> suggests that any single automated assurance mechanism can verify a maximum of 44% security requirements. The NIST <a href="http://samate.nist.gov/docs/NIST_Special_Publication_500-283.pdf">Static Analysis Tool Exposition</a> found that all static analysis tools combined reported warnings on 4 out of 26 known vulnerabilities in Tomcat. Because the practice of relying on opaque verification processes is so pervasive, it has become the industry standard and consequently many organizations are content with testing as the primary means to secure software.</p><p>Suppose, for example, you hire a consultancy to perform a penetration test on your software. Many people call this testing &quot;black box&quot; based on the QA technique of the same name, where testers do not have detailed knowledge of the system internals (e.g. system code). After executing the test, the firm produces a report outlining several vulnerabilities with your application. You remediate the vulnerabilities, submit the application for re-testing, and the next report comes back &quot;clean&quot; – i.e. without any vulnerabilities. At best, this simply tells you that your application can't be broken into by the same testers in the same time frame. On the other hand, it doesn't tell you:</p><ul> 
 <li>What are the potential threats to your application?</li> 
 <li>Which threats is your application “not vulnerable” to?</li> 
 <li>Which threats did the testers <i>not</i> assess your application for? Which threats were not possible to test from a runtime perspective?</li> 
 <li>How did time and other constraints on the test affect the reliability of results? For example, if it the testers had 5 more days, what other security tests would they have executed?</li> 
 <li>What was the skill level of the testers and would you get the same set of results from a different tester or another consultancy?</li> 
</ul><p>In our experience, organizations aren’t able to answer most of these questions. The black box is double-sided: the tester doesn't understand application internals and the organization requesting the test doesn't know much about the security posture of their software. We're not the only ones who acknowledge this issue: Haroon Meer discussed the <a href="http://blog.thinkst.com/2012/03/penetration-testing-considered-harmful.html">challenges of penetration testing</a> at 44con. Most of these issues apply to every form of verification: automated dynamic testing, automated static testing, manual penetration testing, and manual code review. In fact a <a href="http://www.cs.berkeley.edu/%7Edaw/papers/coderev-essos13.pdf">recent paper</a> describes similar challenges in source code review.</p><h2>Examples of Requirements</h2><p>To better illustrate this issue, let’s take a look at some common high-risk software security requirements and examine how common verification methods apply to them.</p><h3><b>Requirement</b>: Hash <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">user passwords</a> using a secure hashing algorithm (e.g. SHA-2) and a unique salt value. Iterate the algorithm multiple times.</h3><p>This requirement is particularly timely with well-known passwords breaches in <a href="http://mashable.com/2012/06/06/linkedin-passwords-hacked-confirmation/">LinkedIn</a>, <a href="http://www.zdnet.com/last-fm-password-leak-could-affect-millions-of-users-3040155353/">Last FM</a>, and <a href="http://www.zdnet.com/twitter-user-passwords-reset-after-accounts-breached-7000007108/">Twitter</a> in the past year.</p><p><b>How common verification methods apply</b>:</p><ul> 
 <li>Automated run-time testing: Unlikely to have access to stored passwords, therefore unable to verify this requirement <br /> &nbsp;</li> 
 <li>Manual run-time testing: Only able to verify this requirement if another exploit results in a dump of stored passwords. This is unreliable, therefore you cannot count on run-time testing to verify the requirement <br /> &nbsp;</li> 
 <li>Automated static analysis: Only able to verify this requirement under the following conditions: 
  <ol> 
   <li>The tool understands how authentication works (i.e. uses a standard component, such as <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnbxj.html">Java Realms</a>)</li> 
   <li>The tool understands which specific hashing algorithm the application uses</li> 
   <li>The tool understands if the application uses unique salt values for each hash</li> 
  </ol> </li> 
</ul><p style="margin-left: 40px">In practice, there are so many ways to implement authentication that it is unrealistic to expect a static analysis tool to be able to verify this requirement across the board. A more realistic scenario is for the tool to simply recognize authentication and point out that secure hashing and salting are necessary. Another scenario is for you to create custom rules to identify the algorithm and hash value and verify they meet your own policy, although in our experience this practice is rare.</p><ul> 
 <li>Manual code review: The most reliable common verification method for this requirement. Manual assessors can understand where authentication happens in the code, and verify that hashing and salting meets best practices.</li> 
</ul><h3><b>Requirement</b>: Bind variables in SQL statements to <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">prevent SQL injection</a></h3><p>SQL Injection is one of the most devastating application vulnerabilities. A recent flaw in <a href="http://www.infoworld.com/d/security/ruby-rails-patches-more-critical-vulnerabilities-210434">Ruby on Rails</a> allowed SQL Injection for applications built on its stack.</p><p><b>How common verification methods apply</b>:</p><ul> 
 <li>Automated run-time testing: While run-time testing may be able to find the presence of SQL injection by <a href="https://www.owasp.org/index.php/Testing_for_SQL_Injection_(OWASP-DV-005)">analyzing behavior</a>, it cannot verify the absence of it. Therefore, automated testing run-time testing cannot verify this requirement completely <br /> &nbsp;</li> 
 <li>Manual run-time testing: Same limitations as automated run-time testing <br /> &nbsp;</li> 
 <li>Automated static analysis: Generally able to verify this requirement, particularly if you are using a standard library to access a SQL database. The tool should be able to understand if you are dynamically concatenating SQL statements with user input, or using proper variable binding. There is a chance, however, that static analysis may miss SQL injection vulnerabilities in the following scenarios: 
  <ul> 
   <li>You use stored procedures on the database and are unable to scan the database code. In some circumstances, stored procedures <a href="http://palizine.plynt.com/issues/2006Jun/injection-stored-procedures/">can be susceptible</a> to SQL injection</li> 
   <li>You use an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object Relational Mapping (ORM)</a> library which your static analysis tool does not support. ORMs can also be susceptible to <a href="http://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-hibernate">injection</a>.</li> 
   <li>You use non-standard drivers / libraries for database connectivity, and the drivers do not properly implement common security controls such as prepared statements</li> 
  </ul> <br /> &nbsp;</li> 
 <li>Manual code review: Like static analysis, manual code review can confirm the absence of SQL injection vulnerabilities. In practice, however, production applications may have hundreds or thousands of SQL statements. Manually reviewing each one can be very time consuming and error prone.</li> 
</ul><h3><b>Requirement</b>: Apply authorization checks to ensure users cannot view another user’s data.</h3><p>Every year we hear about <a href="http://www.ynetnews.com/articles/0,7340,L-4279655,00.html">new</a> <a href="http://www.wptv.com/dpp/news/science_tech/photobucket-hacked-fusking-software-used-to-gain-access-to-private-images">instances</a> of <a href="http://www.theregister.co.uk/2012/04/18/toshiba_slapped_by_ico/">this</a> <a href="http://www.ftc.gov/opa/2011/02/settlement.shtm">vulnerability</a>.</p><p><b>How common verification methods apply</b>:</p><ul> 
 <li>Automated run-time testing: By accessing data from two different users and then attempting to access one user’s data from another user’s account, automated tools can perform some level of testing on this requirement. However, these tools are unlikely to know which data in a user’s account is sensitive or if changing the parameter &quot;data=account1&quot; to &quot;data=account2&quot; represents a breach of authorization. <br /> &nbsp;</li> 
 <li>Manual run-time testing: Manual run-time tests are generally the most effective method of catching this vulnerability because human beings can have the domain knowledge required to spot this attack. There are some instances, however, where a runtime tester may not have all of the information necessary to find a vulnerability. For example, if appending a hidden parameter such as “admin=true” allows you to access another user’s data without an authorization check. <br /> &nbsp;</li> 
 <li>Automated static analysis: Without rule customization, automated tools are generally ineffective in finding this kind of vulnerability because it requires domain understanding. For example, a static analysis tool is unable to know that the “data” parameter represents confidential information and requires an authorization check. <br /> &nbsp;</li> 
 <li>Manual code review: Manual code review can reveal instances of missing authorization that can be difficult to find with run-time testing, such as the impact of adding an “admin=true” parameter. However, actual verifying the presence of authorization checks with manual code review can be laborious. An authorization check can appear in many different parts of code, so a manual reviewer may need to trace through several different execution paths to detect the presence or absence of authorization.</li> 
</ul><h2>Impact to you</h2><p>The opaque nature of verification means effective <a href="http://www.infoq.com/articles/managing-security-requirements-in-agile-projects;jsessionid=7CD61B1B423EFF9C47AB8CD03059B5B0">management of software security requirements</a> is essential. With requirements listed, testers can specify both whether they have assessed a particular requirement and the techniques they used to do so. Critics argue that penetration testers shouldn't follow a &quot;checklist approach to auditing&quot; because no checklist can cover the breadth of obscure and <a href="http://labs.securitycompass.com/appsec-2/domain-driven-security/">domain-specific vulnerabilities</a>. Yet the flexibility to find unique issues does not obviate the need to verify well understood requirements. The situation is very similar for standard software Quality Assurance (QA): good QA testers both verify functional requirements AND think outside the box about creative ways to break functionality. Simply testing blindly and reporting defects without verifying functional requirements would dramatically reduce the utility of quality assurance. Why accept a lower standard from security testing?</p><p>Before you perform your next security verification activity, make sure you have <a href="http://sdelements.com/media/pdf/article-what-are-security-requirements.pdf">software security requirements</a> to measure against and that you define which requirements are in-scope for the verification. If you engage manual penetration testers or source code reviewers, it should be relatively simple for them to specify which requirements they tested for. If you use an automated tool or service, work with your vendor to find out what requirements their tool or service cannot reliably test for. Your tester/product/service is unlike to guarantee an absence of false negatives (i.e. certify that your application is not vulnerable to SQL injection), but knowing what they did and did not test for can dramatically help increase the confidence that your system does not contain known, preventable security flaws.</p><h2>About the Author</h2><p><strong><img hspace="3" alt="" vspace="3" align="left" _p="true" _href="img://rohit.jpg" src="/resource/articles/rohit-application-security-testing/en/resources/rohit.jpg;jsessionid=7CD61B1B423EFF9C47AB8CD03059B5B0" />Rohit Sethi</strong> (@rksethi on Twitter) is lucky to work with amazing people at <a href="http://www.sdelements.com/">SD Elements</a>, focusing on application security requirements. He has helped improve software security at some of the world’s most security sensitive organizations in financial services, software, ecommerce, healthcare, telecom and other industries. Rohit has built and taught SANS courses on Secure J2EE development. He has spoken and taught at FS-ISAC, RSA, OWASP, Secure Development Conference, Shmoocon, CSI National, Sec Tor, Infosecurity, CFI-CIRT, and many others. Mr. Sethi has written articles for InfoQ, Dr. Dobb's Journal, TechTarget, Security Focus and the Web Application Security Consortium (WASC), has appeared on Fox News Live, and has been quoted as an expert in application security for <a href="http://money.cnn.com/2013/01/31/technology/security/antivirus/index.html">CNN</a>, Discovery News and Computer World. He also created the OWASP Design Patterns Security Analysis project.</p><div class="clearer-space"></div></body></html>