<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /></head><body><h3>ActiveJPA – Active Record Pattern for JPA</h3><p>ActiveRecord is a Ruby on Rails’ ORM layer, roughly comparable to Hibernate in Java. ActiveRecord is based on conventions rather than configuration, so it is easier to work with than Hibernate. It really shines when it comes to simplifying the basic operations for creating, reading, updating, and deleting data.</p>
<p>With ActiveRecord, your model class doubles as a Data Access Object (DAO) to perform the CRUD operations. After my early investigations I was so impressed with ActiveRecord that I started looking for solutions that simplify usage of ORMs based on the Java Persistence API (JPA).</p>
<p>Most JPA applications have some kind of Data Access Layer (DAL) to interact with the database. Usually a DAL consists of Data Access Objects (DAO) or classes of the <a href="http://martinfowler.com/eaaCatalog/repository.html">Repository design pattern</a>.</p>
<p>While a DAO is usually implemented in a one-to-one relationship with an entity object, repositories are implemented per <a href="http://martinfowler.com/bliki/DDD_Aggregate.html">aggregate root</a>. In either case these applications end up creating multiple classes to interact with the database. While the right kind of abstraction can limit the number of classes created, it still introduces an additional layer that you have to maintain and test in your application.</p>
<p><a href="https://github.com/activejpa/activejpa">ActiveJPA</a> is a Java implementation of <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">Martin Fowler’s Active Record pattern</a> over JPA. It wraps around JPA and provides useful abstractions to simplify data access. With ActiveJPA, models themselves act as a DAO and interact with the database without you having to write any additional code for the DAL.</p>
<p>Since ActiveJPA uses the JPA spec, all ORM implementations (Hibernate, EclipseLink, OpenJPA, etc.) that implement JPA can be used with ActiveJPA.</p>
<div id="lowerFullwidthVCR"></div>
<h2>Converting your existing JPA model to ActiveJPA</h2>
<p>To convert your model to ActiveJPA, just extend your model implementation from org.activejpa.entity. Model:</p>
<pre>
@java.persistence.Entity    <br />
public class YourModel extends org.activejpa.entity.Model {    <br />
}</pre>
<h3>Performing CRUD operations</h3>
<p>Your models will inherit a bunch of CRUD functions from the ActiveJPA model class.</p>
<pre>
// Get order by id    <br />Order order = Order.findById(12345L);<br /><br />// Get all orders for a customer that are shipped   <br />List orders = Order.where(&quot;customerEmail&quot;, &quot;dummyemail@dummy.com&quot;, &quot;status&quot;, &quot;shipped&quot;);<br /><br />// Get the first order matching the filter   <br />Long count = Order.first(&quot;customerEmail&quot;, &quot;dummyemail@dummy.com&quot;, &quot;status&quot;, &quot;shipped&quot;);<br /><br />// Get the unique order matching the conditions   <br />Long count = Order.one(&quot;customerEmail&quot;, &quot;dummyemail@dummy.com&quot;, &quot;status&quot;, &quot;shipped&quot;);<br /><br />// Dump everything   <br />List orders = Order.all();<br /><br />// Check if order exists with the given identifier   <br />boolean exists = Order.exists(1234L);<br /><br />// Save order   <br />order.persist();<br /><br />// Delete order   <br />order.delete();<br /><br />// Refresh the order<br /><br />order.refresh();<br /><br />// Merge order with the one in persistence context<br /><br />order.merge();</pre>
<h2>Filters &amp; Pagination</h2>
<p>You don’t need to create JPQL or criteria queries to filter records. ActiveJPA exposes a sophisticated filter to perform conjunctions across different operations:</p>
<pre>
// Get all orders matching the given email and billing amount greater than 1000 &amp; paginate it    <br />Filter filter = new Filter();    <br />filter.setPageNo(1);    <br />filter.setPerPage(25);    <br />filter.addCondition(new Condition(&quot;customerEmail&quot;, Operator.eq, &quot;dummyemail@dummy.com&quot;);<br /><br />filter.addCondition(new Condition(&quot;billingAmount&quot;, Operator.gt, 1000.00);   <br />List orders = Order.where(filter);<br /><br />// Count of orders matching the filter   <br />Long count = Order.count(filter);<br /><br />// Delete all orders matching the filter   <br />Long count = Order.deleteAll(filter);</pre>
<h3>Nested queries</h3>
<p>ActiveJPA allows nesting of the filter parameters. This makes it easier for creating dynamic queries on the fly. For instance you can get all orders that have at least one order item created out of a product of category ‘book’.</p>
<pre>
// Get all orders containing at the least one book item  <br />Filter filter = new Filter();    <br />filter.setPageNo(1);    <br />filter.setPerPage(25);    <br />filter.addCondition(new Condition(&quot;orderItems.product.category&quot;, Operator.eq, &quot;books&quot;);    <br />List orders = Order.where(filter);</pre>
<h2>Working with collections</h2>
<p>All the CRUD operations discussed above can be performed at the collection level as well. The query scope is set to collection class in such cases:</p>
<pre>
// Find order item by id within an order    <br />order.collections(&quot;orderItems&quot;).findById(123L);<br /><br />// Get the first order item that is shipped:   <br />order.collections(“orderItems”).first(“status”, “shipped”);<br /><br />// Get all order items that are cancelled   <br />order.collections(“orderItems”).where(“status”, “cancelled”);<br /><br />// Get all the items in the collection   <br />order.collections(“orderItems”).all();<br /><br />// Add an item to the collection   <br />order.collections(“orderItems”).add(orderItem);<br /><br />// Add an item to the collection   <br />order.collections(“orderItems”).remove(orderItem);</pre>
<p>Filters and pagination can be applied to a collection as well.</p>
<pre>
// Search order items by filter within an order and paginate it<br /><br />Filter filter = new Filter();   <br />filter.setPageNo(1);    <br />filter.setPerPage(25);<br /><br />filter.addCondition(new Condition(“status”, “shipped”);   <br />order.collections(&quot;orderItems&quot;).where(filter);<br /><br />// Get count of order items matching the filter in the order<br /><br />order.collections(“orderItems”).count(filter);</pre>
<h2>Dynamic updates</h2>
<p>ActiveJPA supports dynamically updating a model. This is quite useful in scenarios where, for example, a user updates a form from the browser. Instead of calling a setter method for each individual attribute, you can pass a map of attributes to update:</p>
<pre>
// Update attributes    <br />
Map attributes = new HashMap();    <br />
attributes.put(&quot;billingAmount&quot;, 1000.0);    <br />
order.updateAttributes(attributes);</pre>
<p>You can also update non-primitive/non-wrapper fields by passing maps to those objects. The example below shows updating a shipping address and billing amount of an order.</p>
<pre>
// Update billing amount and shipping address of an order<br />
Map attributes = new HashMap();<br />
Map address = new HashMap();<br />
address.put(“city”, “Bangalore”);<br />
address.put(“state”, “Karnataka”);<br />
attributes.put(“shippingAddress”, address);<br />
attributes.put(&quot;billingAmount&quot;, 1000.0);<br />
order.updateAttributes(attributes);</pre>
<p><b>Note</b>: Updating list/set/array fields are not supported yet. It will be supported in the future versions</p>
<h2>Transaction Handling</h2>
<p>By default ActiveJPA starts a transaction for all the update operations if one doesn’t already exist, but you can also wrap a unit of work under a transaction as follows:</p>
<pre>
JPAContext context = JPA.instance.getDefaultConfig().getContext();    <br />context.beginTxn();    <br />boolean failed = true;    <br />try {    <br /> // Your unit of work here    <br />failed = false;    <br />} finally {    <br /> // Commit or rollback the transaction    <br />context.closeTxn(failed);    <br />}</pre>
<p>If an outer transaction exists already, ActiveJPA will use that but will not commit or rollback the transaction. It will be the responsibility of the application to close the transaction.</p>
<h2>Testing your Models</h2>
<p>ActiveJPA provides a base test class for TestNG that hooks ActiveJPA into test runtime. Just ensure your test classes extends <i>org.activejpa.entity.testng.BaseModelTest</i> class. Below is a sample code,</p>
<pre>
public class OrderTest extends BaseModelTest {<br />
     @Test<br />
     public void testCreateOrder() {<br />
       Order order = new Order();<br />
       order.setCustomerEmail(&quot;dummyemail@dummy.com&quot;);<br />
       ...<br />
       ...<br />
       order.persist();<br />
       Assert.assertEquals(Order.where(&quot;customerEmail&quot;, &quot;dummyemail@dummy.com&quot;).get(0), order);<br />
    }<br />
  }<br />
}</pre>
<h2>Getting Started</h2>
<h3>Setting up Maven</h3>
<p>ActiveJPA is available as a Maven artifact and should be fairly simple to integrate with your application. Just add the following maven dependency to your pom.xml file</p>
<pre>
&lt;dependencies&gt;    <br />&lt;dependency&gt;    <br />&lt;groupId&gt;org.activejpa&lt;/groupId&gt;    <br />&lt;artifactId&gt;activejpa-core&lt;/artifactId&gt;    <br />&lt;version&gt;0.1.5&lt;/version&gt;    <br />&lt;/dependency&gt;    <br />&lt;/dependencies&gt;
<br />&lt;repositories&gt;   <br />&lt;repository&gt;    <br />&lt;id&gt;activejpa-repo&lt;/id&gt;    <br />&lt;url&gt;https://raw.github.com/ActiveJpa/activejpa/mvn-repo/releases&lt;/url&gt;    <br />&lt;snapshots&gt;    <br />&lt;enabled&gt;true&lt;/enabled&gt;    <br />&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;    <br />&lt;/snapshots&gt;    <br />&lt;/repository&gt;    <br />&lt;/repositories&gt;</pre>
<h3>Hooking into your application</h3>
<p>ActiveJPA needs to be hooked into your application before the entity classes are loaded. If you are running a Tomcat server, the ideal place would be ServletContextListener. Below is code you could write in the context listener contextInitialized() method.</p>
<pre>
// Loads the Java agent dynamically    <br />ActiveJpaAgentLoader.instance().loadAgent();<br /><br />// Add the persistence unit defined by persistence.xml identified by the name 'order'. The persistence.xml should be available in the classpath   <br />JPA.addPersistenceUnit(&quot;order&quot;);<br /><br />// If you have entity manager factory already created, you can attach the same to ActiveJpa   <br />// JPA.addPersistenceUnit(&quot;order&quot;, entityManagerFactory);</pre>
<h2>Integrating with Spring Framework</h2>
<p>Integrating ActiveJPA with frameworks like Spring is fairly simple. Most applications use Spring to configure JPA and manage the transactions using annotations. ActiveJPA can be configured in two ways - you can either let it create the entity manager factory or pass an already existing one. In the case of Spring configured JPA, we can use the entity manager factory created by Spring. This ensures ActiveJPA uses the same connections and transactions created by Spring and provides a seamless integration.</p>
<p>The code below demonstrates how to integrate ActiveJPA with a Spring application deployed on a servlet container. It uses a custom context loader listener to hook ActiveJPA into the application. Note that it is similar to the servlet example above, except that it uses the Spring Framework ContextLoaderListener:</p>
<pre>
public class CustomContextListener extends ContextLoaderListener {<br />
  @Override<br />
  public void contextInitialized(ServletContextEvent event) {<br /> 
          try {<br />
                    // This loads the javaagent dynamically<br />
                    ActiveJpaAgentLoader.instance().loadAgent();<br />
          } catch (Exception e) {<br />
                    throw new RuntimeException(e);<br />
          }<br />
          super.contextInitialized(event);<br />
          JPA.instance.addPersistenceUnit(&quot;default&quot;, getCurrentWebApplicationContext().getBean(EntityManagerFactory.class), true);<br />
   }<br />
}</pre>
<h2>Sample Application</h2>
<p>There are a lot more specific examples in the sample application from the <a href="https://github.com/ActiveJpa/activejpa">ActiveJPA Project Page</a> on GitHub, demonstrating <a href="https://github.com/ActiveJpa/activejpa/tree/master/activejpa-examples/activejpa-examples-spring">Spring-ActiveJPA</a> integration.</p>
<h2>About the Author</h2>
<p><strong><img src="http://www.infoq.com/resource/articles/ActiveJPA/en/resources/1ganesh.jpg" vspace="3" hspace="3" align="left" alt="" _href="img://1ganesh.jpg" _p="true" />Ganesh Subramanian</strong> is an Architect with <a href="http://www.hightail.com/">Hightail</a> and he has over 10+ years experience in architecting highly scalable, low latency distributed applications spanning across multiple domains. Ganesh was instrumental in architecting <a href="http://www.flipkart.com/">Flipkart's</a> (India's largest e-commerce player) Supply chain management platform and he is an active contributor to the open source community (<a href="https://github.com/activejpa/activejpa">ActiveJPA</a>, <a href="http://minnal.github.io/minnal/">Minnal</a>, <a href="https://github.com/minnal/autopojo">AutoPojo</a>, etc.). He is the author of the <a href="http://ganeshsubramanian.com/blog">tech blog</a> and he loves watching movies (all genres) and spending time with his family during his free time.</p><br><br><br><br><br><br></body></html>